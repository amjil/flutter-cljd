(ns flutter-cljd.animations
  (:require
   [cljd.core :as c]
   [cljd.set :refer [superset?]]
   [flutter-cljd.types :as t]
   [flutter-cljd.curves :as curves]
   ["package:flutter/widgets.dart" :as w]
   ["package:flutter/animation.dart" :as a]
   ["package:flutter/scheduler.dart" :as sc]
   ["dart:core" :as dc]
   [flutter-cljd.utils :as ut]
   [cljd.string :as str]))

(declare motion)

(extend-protocol c/IFn
  a/Curve
  (-invoke [this t]
    (.transform this t))

  a/Animatable
  (-invoke [this t]
    (.transform this t))

  a/AnimationController
  (-invoke [this animatable]
    (.drive this animatable)))

(deftype TransformedAnimation
         [^a/Animation parent transform]
  :extends a/Animation
  (value [this] ((.-transform this) (-> this .-parent .-value)))
  c/IEquiv
  (-equiv [o other] (identical? o other))
  ^:mixin a/AnimationWithParentMixin)

(defn ^TransformedAnimation map-anim
  "Transforms an animation using a transform function.\\
     `map-anim` takes an animation and a transform function and returns a new animation.\\
     The transform function takes the value of the parent animation and returns the transformed value.
     ```clojure
     (map-anim #(* % 2) parent)
     ```
     `Animation` implements `ILookup` to create a transformed animation that transforms the value of the parent animation.
     ```clojure
     (let [animation (always-stopped-animation {:x 10.0 :y 20})
           x-animation (:x animation) ;; an animation that always returns 10.0
           y-animation (get animation :y)] ;; an animation that always returns 20.0
     ```"
  [transform parent]
  (TransformedAnimation parent transform))

(extend-protocol c/ILookup
  a/Animation
  (-lookup [this key] (c/-lookup this key nil))
  (-lookup [this key not-found]
    (map-anim (fn [value] (c/-lookup value key not-found)) this))
  (-contains-key? [this key]
    (c/-contains-key? (.-value this) key)))

(defn- set-value [this new-value]
  (let [old-value (-> this .-tween .-end)
        tween (.-tween this)
        controller (.-controller this)]
    (when-not (= new-value old-value)
      (.-begin! tween (.evaluate tween this))
      (.-end! tween new-value)
      (if-not (.-isAnimating controller)
        (.forward controller .from 0.0)
        (let [progress (.-value controller)]
          (.forward controller .from 0.0)
          (.-value! controller progress)))
      nil)))

(defn- get-state [this]
  (-> this .-tween .-end))

(deftype AnimatedValue
         [tween
          ^a/AnimationController controller
          ^a/Animation parent]
  :extends (a/Animation)
  (value [^AnimatedValue this]
    (-> this .-tween (.lerp (-> this .-controller .-value))))
  c/IEquiv
  (-equiv [o other] (identical? o other))
  c/IDeref
  (-deref [^AnimatedValue this] (get-state this))
  c/ISwap
  (-swap! [^AnimatedValue this f] (set-value this (f (get-state this))))
  (-swap! [^AnimatedValue this f a] (set-value this (f (get-state this) a)))
  (-swap! [^AnimatedValue this f a b] (set-value this (f (get-state this) a b)))
  (-swap! [^AnimatedValue this f a b xs] (set-value this (apply f (get-state this) a b xs)))
  c/IReset
  (-reset! [^AnimatedValue this new-value] (set-value this new-value))
  (dispose [^AnimatedValue this]
    (.dispose (.-controller this)))
  ^:mixin a/AnimationWithParentMixin)

(defn ^AnimatedValue animated-value
  "Animation that can be used to animate value changes.\\
   `animated-value` takes an initial value and returns an animated value.\\
   The `vsync` argument is required and specifies the `TickerProvider` for the animation.\\
   The `options` argument is optional and specifies the animation options.\\
   The `options` argument can be a map with the following keys:
    - `:duration` - Duration of the animation.
    - `:curve` - Curve of the animation.
    - `:reverse-curve` - Reverse curve of the animation.
    - `:lerp` - Lerp function of the animation.
   
   ```clojure
   (animated-value 10.0 vsync)
   (animated-value 10.0 vsync {:duration 1000})
   ```
   To start the animation, change the value using `reset!` or `swap!`.
   ```clojure
   (reset! animated-value 20.0)
   ```"
  ([initial-value vsync] (animated-value initial-value vsync {}))
  ([initial-value vsync options]
   (let [options (t/animation-options options)
         controller (a/AnimationController
                     .vsync vsync
                     .duration (:duration options))]
     (AnimatedValue
      (t/tween (:lerp options) initial-value initial-value)
      controller
      (a/CurvedAnimation
       .parent controller
       .curve (:curve options a/Curves.linear)
       .reverseCurve (some-> options :reverse-curve t/curve))))))

(declare MotionController)

(defn- reset-cached-value [^MotionController controller]
  (.-cachedValue! controller nil)
  (.-cachedValueProgress! controller nil))

(defn- set-cached-value [^MotionController controller value]
  (.-cachedValue! controller value)
  (.-cachedValueProgress! controller (-> controller .-parent .-value)))

(defn- set-side-effects [side-effects object animation]
  (if side-effects
    (when (nil? (.-effectsStatusListener object))
      (let [listener
            (fn []
              (let [progress (-> animation .-value)
                    prevProgress (.-prevProgress object)
                    start (min progress (or prevProgress 0.0))
                    end (max progress (or prevProgress 0.0))]
                (when (not= progress prevProgress)
                  (.-prevProgress! object progress)
                  (doseq [effect (side-effects [start end])]
                    (effect)))))
            statusListener (fn [status]
                             (if (or (= status a/AnimationStatus.completed)
                                     (= status a/AnimationStatus.dismissed))
                               (when-let [listener (.-effectsListener object)]
                                 (.removeListener animation listener)
                                 (.-effectsListener! object nil))
                               (when (nil? (.-effectsListener object))
                                 (.-effectsListener! object listener)
                                 (.-prevProgress! object (-> animation .-value))
                                 (.addListener animation listener))))]
        (.-effectsStatusListener! object statusListener)
        (.addStatusListener animation statusListener)))
    (when-let [listener (.-effectsStatusListener object)]
      (.removeStatusListener animation listener)
      (.-effectsStatusListener! object nil))))

(defn- compute-motion [^MotionController controller]
  (when (or (.-needCompute controller) (nil? (.-interpolate controller)) (nil? (.-duration (.-parent controller))))
    (.-needCompute! controller false)
    (reset-cached-value controller)
    (let [{:keys [prepare-motion]} (.-motion controller)
          {:keys [duration interpolate side-effects]} (prepare-motion nil nil)
          duration (t/duration (or duration (get-in t/*anim-ctx* [:animation :duration])))]
      (.-interpolate! controller interpolate)
      (.-duration! (.-parent controller) duration)
      (set-side-effects side-effects controller (.-parent controller)))))

(deftype ^:private MotionAnimationController
         [^:mutable ^MotionController? motionController
          ^:mutable ^double val
          ^:mutable ^a/Duration? dur
          ^double lb
          ^double ub
          ^dc/String? dl
          ^a/TickerProvider vs
          ^a/AnimationBehavior ab]
  :extends (a/AnimationController
             .value val
             .duration dur
             .debugLabel dl
             .vsync vs
             .lowerBound lb
             .upperBound ub
             .animationBehavior ab)

  (^sc/TickerFuture forward [^MotionAnimationController this ^double? .from]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.forward ^super this .from (some-> from double)))

  (^sc/TickerFuture reverse [^MotionAnimationController this ^double? .from]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.reverse ^super this .from (some-> from double)))

  (^sc/TickerFuture animateTo [^MotionAnimationController this
                               ^double target
                               ^a/Duration? .duration
                               ^a/Curve? .curve]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.animateTo ^super this (double target) .duration (some-> duration t/duration) .curve (t/curve (or curve :linear))))

  (^sc/TickerFuture animateBack [^MotionAnimationController this
                                 ^double target
                                 ^a/Duration? .duration
                                 ^a/Curve? .curve]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.animateBack ^super this (double target) .duration (some-> duration t/duration) .curve (t/curve (or curve :linear))))

  (^sc/TickerFuture repeat [^MotionAnimationController this
                            ^double? .min
                            ^double? .max
                            ^bool? .reverse
                            ^a/Duration? .period
                            ^int? .count]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.repeat ^super this
             .min (some-> min double)
             .max (some-> max double)
             .reverse (boolean reverse)
             .period (some-> period t/duration)
             .count (some-> count int)))
  (^sc/TickerFuture toggle [^MotionAnimationController this ^double? .from]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.toggle ^super this .from (some-> from double))))

(deftype MotionController
         [^:mutable motion
          ^:mutable interpolate
          ^:mutable effectsListener
          ^:mutable effectsStatusListener
          ^:mutable prevProgress
          ^:mutable needCompute
          ^:mutable cachedValue
          ^:mutable cachedValueProgress
          ^:mutable motionString
          ^a/AnimationController parent]
  :extends (a/Animation)
  (value [^MotionController this]
    (if (and (not (.-isAnimating this)) (= (.-cachedValueProgress this) (-> this .-parent .-value)))
      (.-cachedValue this)
      (do
        (compute-motion this)
        (let [result ((.-interpolate this) nil (-> this .-parent .-value))]
          (when-not (.-isAnimating this)
            (set-cached-value this result))
          result))))
  dc/Object
  (toString [^MotionController this]
    (-> this .-motionString))
  c/IEquiv
  (-equiv [o other] (identical? o other))
  (dispose [^MotionController this]
    (.dispose (.-parent this)))
  (^sc/TickerFuture animateBack [^MotionAnimationController this target .duration .curve]
    (.animateBack (.-parent this) (double target) .duration (some-> duration t/duration) .curve (t/curve (or curve :linear))))
  (^sc/TickerFuture animateTo [^MotionAnimationController this target .duration .curve]
    (.animateTo (.-parent this) (double target) .duration (some-> duration t/duration) .curve (t/curve (or curve :linear))))
  (^sc/TickerFuture forward [^MotionController this ^double? .from]
    (.forward (.-parent this) .from (some-> from double)))
  (^sc/TickerFuture repeat [^MotionController this .min .max .reverse .period .count .synced]
    (when synced
      (.sync this))
    (.repeat (.-parent this)
             .min (some-> min double)
             .max (some-> max double)
             .reverse (boolean reverse)
             .period (some-> period t/duration)
             .count (some-> count int)))
  (sync [^MotionController this]
    (reset-cached-value this)
    (compute-motion this)
    (let [duration (-> this .-parent .-duration .-inMilliseconds)]
      (when (< 0 duration)
        (.-value! (.-parent this) (/ (mod (.-millisecondsSinceEpoch (dc/DateTime.now)) duration) duration)))))
  (reset [^MotionController this]
    (.reset (.-parent this)))
  (resync [^MotionController this vsync]
    (.resync (.-parent this) vsync))
  (^sc/TickerFuture reverse [^MotionController this .from]
    (.reverse (.-parent this) .from (some-> from double)))
  (stop [^MotionController this .canceled]
    (.stop (.-parent this) .canceled (boolean (or (nil? canceled) canceled))))
  (^sc/TickerFuture toggle [^MotionController this .from]
    (.toggle (.-parent this) .from (some-> from double)))
  ^:mixin a/AnimationWithParentMixin)

(defn ^double progress
  "Returns the current progress of the motion controller.
   
   The progress is a value between 0.0 and 1.0 representing how far along
   the animation has progressed. 0.0 is the start and 1.0 is the end.
   
   ```clojure
   (let [controller (motion-controller vsync (to 0 100))]
     (progress controller)) ;; Returns current progress, e.g. 0.5
   ```"
  [^MotionController controller]
  (-> controller .-parent .-value))

(defn progress!
  "Sets the current progress of the motion controller.
   
   Takes a controller and a progress value between 0.0 and 1.0.
   Immediately updates the animation to that progress point without animating.
   
   ```clojure
   (let [controller (motion-controller vsync (to 0 100))]
     (progress! controller 0.5) ;; Jumps to 50% progress
     (.-value controller)) ;; Returns 50
   ```"
  [^MotionController controller ^double new-value]
  (.-value! (.-parent controller) new-value))

(defn- in-mcs [duration]
  (some-> duration t/duration .-inMicroseconds double))

(defn- from-mcs [mcs]
  (when mcs (t/duration {:microseconds mcs})))

(def ^:private options-keys #{:duration :dur :rel-dur :rel-delay :curve :lerp :relative-duration :delay :relative-delay})

(defn- is-options? [x]
  (and
   (map? x)
   (superset? options-keys (set (keys x)))))

(defn- motion-options [value]
  {:duration (:duration value (:dur value))
   :delay (:delay value)
   :relative-delay (:relative-delay value (:rel-delay value))
   :relative-duration (:relative-duration value (:rel-dur value))
   :curve (:curve value)
   :lerp (:lerp value)})

(defn- const-anim
  ([value]
   (constantly value))
  ([value duration]
   {:interpolate (const-anim value)
    :duration duration}))

(defn- separate-options [args]
  (if (is-options? (first args))
    {:options (first args) :items (drop 1 args)}
    (reduce
     (fn [res arg]
       (let [{:keys [key options items finished]} res]
         (if (not finished)
           (if (nil? key)
             (if (and (keyword? arg) (options-keys arg))
               (assoc res :key arg)
               (assoc res :items (conj items arg) :finished true))
             (assoc res :key nil :options (assoc options key arg)))
           (assoc res :items (conj items arg)))))
     {:options {} :items []}
     args)))

(defn- separate-last-options [args]
  (if (is-options? (last args))
    {:options (last args) :items (drop-last 1 args)}
    (reduce
     (fn [res arg]
       (let [{:keys [options items]} res]
         (if (and (= (count items) 1) (keyword? arg) (options-keys arg))
           {:items [] :options (assoc options arg (first items))}
           {:items (cons arg items) :options options})))
     {:options {} :items []}
     (reverse args))))

(declare Motion)

(deftype ^:private MotionAnimationWrapper
         [^:mutable effectsListener
          ^:mutable effectsStatusListener
          ^:mutable prevProgress
          interpolate
          ^#/(a/Animation double) parent]
  :extends a/Animation
  (value [^MotionAnimationWrapper this] (interpolate nil (-> this .-parent .-value)))
  ^:mixin a/AnimationWithParentMixin)

(defn- compute-motion-if-needed [^Motion this]
  (when (nil? (.-interpolate this))
    (let [{:keys [interpolate side-effects duration]} ((.-prepare this) nil nil)]
      (.-interpolate! this interpolate)
      (.-effects! this side-effects)
      (.-dur! this (some-> duration t/duration)))))

(deftype Motion [prepare
                 toStr
                 ^a/Duration? ^:mutable dur
                 ^:mutable effects
                 ^:mutable interpolate]
  :extends (a/Animatable)
  Motion
  (^a/Duration? ^:getter duration [^Motion this]
    (compute-motion-if-needed this)
    (.-dur this))
  a/Animatable
  (^a/Animation animate [^Motion this ^#/(a/Animation double) parent]
    (if (instance? a/AnimationController parent)
      (let [duration (.-duration parent)
            {:keys [interpolate side-effects duration]} ((.-prepare this) nil duration)
            result (MotionAnimationWrapper nil nil nil interpolate parent)]
        (when (and duration (not= duration (.-duration parent)))
          (.-duration! parent (t/duration duration)))
        (set-side-effects side-effects result parent)
        result)
      (do
        (compute-motion-if-needed this)
        (let [result (MotionAnimationWrapper nil nil nil (.-interpolate this) parent)]
          (set-side-effects (.-effects this) result parent)
          result))))
  (transform [^Motion this ^double t]
    (compute-motion-if-needed this)
    ((.-interpolate this) nil t))
  (^dc/String toString [^Motion this] ((.-toStr this)))
  (^bool == [^Motion this ^dc/Object other]
    (= (.toString this) (.toString other))))

(defn ^Motion motion
  [prepare to-string]
  (Motion prepare to-string nil nil nil))

(defn- motion-to-map
  ([motion]
   (cond
     (instance? Motion motion)
     {:prepare-motion (.-prepare motion)
      :to-string (.-toStr motion)}

     (instance? w/Animatable motion)
     {:prepare-motion (fn [_ duration]
                        {:interpolate (fn [_ t] (.transform motion t))
                         :duration duration})
      :to-string #(.toString motion)}

     (nil? motion)
     nil

     :else
     (throw (ex-info "Invalid motion" {:motion motion})))))

(defn set-motion!
  "Sets the motion of the motion controller.
   
   Takes a motion controller and a new motion to animate.
   Updates the controller to use the new motion while preserving the current progress.
   If the controller is currently animating, it will continue with the new motion.
   
   ```clojure
   (let [controller (motion-controller vsync (to 0 100))]
     (.forward controller) ;; Start animating
     (set-motion! controller (to 200 300)) ;; Change destination mid-animation
     (.-value controller)) ;; Returns interpolated value between 200-300
   ```"
  [^MotionController controller motion]
  (let [motion-map (motion-to-map motion)
        string ((:to-string motion-map))]
    (.-motion! controller motion-map)
    (.-needCompute! controller (not= string (.-motionString controller)))
    (.-motionString! controller string)
    (when (.-isAnimating controller)
      (compute-motion controller))
    controller))

(defn ^MotionController motion-controller
  "Creates a motion controller that manages animations.

  Arguments:
   - vsync: A `TickerProvider` that drives the animation (usually obtained from a widget's state)
   - motion: The motion to animate (created with `to`, `par`, `seq`, etc.)
   - options (optional):
     - :progress - Initial progress value (default: 0.0)
     - :debug-label - Label for debugging (optional)
     - :animation-behavior - Animation behavior on hot reload (default: :preserve)

  Returns a `MotionController` instance that provides these methods:

  Animation Control:
   - .forward [from] - Start forward animation from optional progress value
   - .reverse [from] - Start reverse animation from optional progress value
   - .stop [canceled] - Stop animation (canceled defaults to true)
   - .toggle [from] - Toggle between forward/reverse from optional progress
   - .animateTo [target duration curve] - Animate to target value over duration with curve
   - .animateBack [target duration curve] - Animate back to target over duration with curve
   - .sync - Sync progress with current time
   - .repeat [min max reverse period count synced] - Repeat animation with options:
      - min: Minimum progress value (optional)
      - max: Maximum progress value (optional) 
      - reverse: Whether to reverse direction (optional)
      - period: Duration of each repeat cycle (optional)
      - count: Number of times to repeat (optional)
      - synced: Whether to sync start progress with current time (optional)
   - .reset - Reset to initial state
   - .resync [vsync] - Resync with new vsync provider
   - .dispose - Clean up resources

  Properties:
   - .-value - Current animated value
   - .-parent - Underlying AnimationController
   - .-isAnimating - Whether animation is running

  Helper Functions:
   - progress [controller] - Get current progress (0.0 to 1.0)
   - progress! [controller value] - Set current progress
   - set-motion! [controller motion] - Change the motion being animated

  Examples:
  ```clojure
  ;; Basic usage
  (motion-controller vsync (to 0.0 10.0))

  ;; With initial progress
  (motion-controller vsync (to 0.0 100.0) :progress 0.5)

  ;; Parallel animations with child animations
  (let [controller (motion-controller 
                    vsync
                    (par {:dur 500}
                         :opacity (to 0.0 1.0 :delay 100)
                         :offset (to 0.0 100)))]
    ;; Use child animations in widgets
    (widget
      :managed [animation controller]
      (->> (text \"Hello\")
           (animated (:opacity animation) opacity) ;; (:opacity animation) returns the child animation 
           (animated (:offset animation) #(offset %1 0)))))

  ;; Complex animation sequence with curves and relative durations
  (widget
    :managed [animation (motion-controller 
                         vsync
                         (seq
                           ;; Initial state
                           {:opacity 0.0
                            :scale 0.8
                            :offset 0.0}
                           ;; Fade in and scale up with ease-out
                           (par {:dur 400 :curve :ease-out}
                                :opacity (to 1.0 :relative-duration 0.5)
                                :scale 1.0)
                           ;; Wait a bit
                           (wait 200)
                           ;; Slide and bounce
                           (par
                             :offset (-> (to 0.0 20.0 0.0)
                                       (with {:dur 600 :curve :ease-in-out}))
                             ;; Scale effect happens during middle of slide
                             :scale (-> (to 1.0 1.1 1.0)
                                      (with {:dur 300
                                            :rel-delay 0.25
                                            :curve :ease-in-out}))
                           ;; Trigger taptic feedback
                           (action! HapticFeedback.selectionClick)))]                 
    (->> (text \"Animated Title\")
         (animated (:opacity animation) opacity)
         (animated (:scale animation) scale)
         (animated (:offset animation) #(offset 0 %))))

  ;; Sequential animations with relative timing
  (widget
    :managed [animation (motion-controller
                         vsync
                         (seq {:dur 2000}
                           {:step :first
                            :opacity 0.0
                            :scale 0.5
                            :color Colors.blue
                            :rotation 0}
                           ;; Take 40% of total time
                           (par {:rel-dur 0.4 :curve :ease-out}
                                :opacity (to 1.0 :curve :ease-in-out)
                                :scale 1.0)
                           ;; Brief pause (10% of time)
                           (wait :rel-dur 0.1)
                           ;; Rest of animation (50% of time)
                           (par
                             :step (const :last)
                             :color Colors.red
                             :rotation (to 0.0 360.0 :curve :ease-in-out)))]
    (->> (container)
         (animated (:opacity animation) opacity)
         (animated (:scale animation) scale)
         (animated (:color animation) background-color)
         (animated (:rotation animation) rotate)))
  ```"
  ([vsync motion & {:keys [progress debug-label animation-behavior lower-bound upper-bound]
                    :or {progress 0.0 animation-behavior a/AnimationBehavior.preserve lower-bound 0.0 upper-bound 1.0}}]
   (let [^MotionAnimationController animation-controller (MotionAnimationController
                                                          nil
                                                          (double progress)
                                                          nil
                                                          (or (some-> lower-bound double) dc/double.negativeInfinity)
                                                          (or (some-> upper-bound double) dc/double.infinity)
                                                          (some-> debug-label str)
                                                          vsync
                                                          (t/animation-behavior animation-behavior))
         ^MotionController motion-controller (MotionController
                                              {}
                                              (constantly nil)
                                              nil
                                              nil
                                              nil
                                              true
                                              nil
                                              nil
                                              nil
                                              animation-controller)]
     (.-motionController! animation-controller motion-controller)
     (set-motion! motion-controller motion)
     motion-controller)))

(defn ^a/AnimationController animation-controller
  "Creates an animation controller that manages animations.
  
  Arguments:
    - vsync: A `TickerProvider` that drives the animation (usually obtained from a widget's state)
    - `:duration` or `:dur`: Duration of the animation
    - `:reverse-duration` or `:reverse-dur`: Duration of the reverse animation
    - `:value`: Initial value of the animation. Defaults to 0.0
    - `:debug-label`: Label for debugging (optional)
    - `:animation-behavior`: Animation behavior on hot reload (default: :preserve)
    - `:lower-bound`: Lower bound of the animation (default: 0.0)
    - `:upper-bound`: Upper bound of the animation (default: 1.0)"
  [vsync & {:keys [duration dur reverse-duration reverse-dur value debug-label animation-behavior lower-bound upper-bound]
            :or {value 0.0 animation-behavior a/AnimationBehavior.preserve lower-bound 0.0 upper-bound 1.0}}]
  (a/AnimationController
   .value (double value)
   .duration (some-> (or duration dur) t/duration)
   .reverseDuration (some-> (or reverse-duration reverse-dur) t/duration)
   .debugLabel (some-> debug-label str)
   .vsync vsync
   .lowerBound (or (some-> lower-bound double) dc/double.negativeInfinity)
   .upperBound (or (some-> upper-bound double) dc/double.infinity)
   .animationBehavior (t/animation-behavior animation-behavior)))

(defn ^Motion instant
  "Instant motion with zero duration.
   ```clojure
   (instant 10.0)
   (instant)
   ```"
  ([]
   (motion
    (fn [_ _] {:duration (t/duration 0)
               :interpolate (fn [value _] value)})
    (constantly "(instant)")))
  ([value]
   (motion
    (fn [_ _] (const-anim value 0))
    (fn [] (str "(instant " value ")")))))

(defn- time-mod [num div]
  (if (zero? num)
    num
    (let [result (mod num div)]
      (if (zero? result) 1.0 result))))

(defn- transform-effect-t [t start end rel-dur]
  (if (zero? rel-dur)
    (cond
      (and (= t 0.0) (= start 0.0)) 0.0
      (= t end) 1.0
      (< end t) dc/double.infinity
      :else (- dc/double.infinity))
    (/ (- t start) rel-dur)))

(defn- ^Motion -sequential [motions]
  (let [motions (->> motions flatten (filter some?) (map motion-to-map))
        clamp #(min 1.0 (max 0.0 %))]
    (motion
     (fn [value exp-dur]
       (let [{:keys [sum-abs sum-rel cnt-any items intr-dur effects-cnt]}
             (reduce
              (fn [res motion]
                (if (some? motion)
                  (let [{:keys [last-value sum-abs sum-rel effects-cnt]} res
                        {:keys [duration relative-duration interpolate side-effects]} ((:prepare-motion motion) last-value nil)
                        next-value (interpolate last-value 1.0)
                        duration (in-mcs duration)
                        relative (when (and (nil? duration) relative-duration) (clamp relative-duration))]
                    {:last-value next-value
                     :sum-abs (if duration (+ duration (or sum-abs 0.0)) sum-abs)
                     :sum-rel (+ sum-rel (or relative 0.0))
                     :cnt-any (+ (:cnt-any res) (if (or duration relative) 0 1))
                     :cnt-abs (+ (:cnt-abs res) (if duration 1 0))
                     :intr-dur (when (and duration relative-duration (< 0 relative-duration)) (/ duration relative-duration))
                     :items (conj (:items res) {:duration duration
                                                :relative-duration relative
                                                :interpolate interpolate
                                                :side-effects side-effects})
                     :effects-cnt (+ effects-cnt (if side-effects 1 0))})
                  res))
              {:last-value value :sum-abs nil :sum-rel 0.0 :cnt-any 0 :cnt-abs 0 :items [] :effects-cnt 0}
              motions)
             rel-k (if (< 1 sum-rel) (/ sum-rel) 1.0)
             sum-rel (clamp sum-rel)
             min-dur (if (and sum-abs sum-rel (< sum-rel 1.0)) (/ sum-abs (- 1.0 sum-rel)) sum-abs)
             exp-dur (in-mcs exp-dur)
             res-dur (let [durs (->>
                                 [exp-dur intr-dur]
                                 (concat (if (< 0 cnt-any) [] [min-dur]))
                                 (filter some?))]
                       (when-not (empty? durs) (apply max durs)))
             any-dur (if (> cnt-any 0)
                       (if (and res-dur min-dur (> res-dur 0))
                         (/ (- (/ (- res-dur min-dur) res-dur) sum-rel) cnt-any)
                         (/ (- 1.0 sum-rel) cnt-any))
                       0.0)
             all-cnt (count items)
             all-items (reduce
                        (fn [res item]
                          (let [{:keys [duration relative-duration]} item
                                relative-duration (when relative-duration (* rel-k relative-duration))
                                t (if (empty? res) 0.0 (:end (last res)))
                                rel-dur (or relative-duration
                                            (when res-dur
                                              (if (< 0 res-dur)
                                                (if duration (/ duration res-dur) any-dur)
                                                (/ all-cnt)))
                                            any-dur)
                                end (+ t rel-dur)]
                            (conj res (assoc item :start t :end end :rel-dur rel-dur))))
                        []
                        items)]
         {:duration (from-mcs res-dur)
          :interpolate (fn [initial T]
                         (reduce
                          (fn [value {:keys [start end rel-dur interpolate]}]
                            (if (and (< 0 rel-dur) (or (<= start T end) (<= T 0)))
                              (let [t (if (zero? rel-dur) 1.0 (/ (- T start) rel-dur))
                                    anim-t (cond->> t
                                             (< end 1) (min 1.0)
                                             (< 0 start) (max 0.0))]
                                (reduced (interpolate value anim-t)))
                              (interpolate value 1.0)))
                          initial
                          all-items))
          :side-effects (when (< 0 effects-cnt)
                          (let [effects
                                (filter
                                 some?
                                 (map
                                  (fn [{:keys [start end rel-dur side-effects]}]
                                    (when side-effects
                                      (let [transform #(transform-effect-t % start end rel-dur)]
                                        #(side-effects (map transform %)))))
                                  all-items))]
                            (fn [range]
                              (apply concat (map #(% range) effects)))))}))
     (fn [] (str "(seq " (str/join " " (map #((:to-string %)) motions)) ")")))))

(defn- ^Motion -parallel [motions]
  (let [is-map? (seq? (first motions))
        default (if is-map? {} (vec (c/repeat (count motions) nil)))
        motions (if is-map?
                  (map (fn [[k v]] [k (motion-to-map v)]) motions)
                  (map-indexed (fn [i v] [i (motion-to-map v)]) motions))]
    (motion
     (fn [value exp-dur]
       (let [value (or value default)
             exp-dur-in-mcs (in-mcs exp-dur)

             {:keys [max-dur items side-effects-cnt]}
             (reduce
              (fn [res [k v]]
                (let [{:keys [duration relative-duration interpolate side-effects]} ((:prepare-motion v) (get value k) exp-dur)
                      {:keys [max-dur items side-effects-cnt]} res
                      dur-abs (or
                               (in-mcs duration)
                               (when (and relative-duration exp-dur-in-mcs) (* exp-dur-in-mcs relative-duration)))
                      max-dur (if dur-abs (max dur-abs (or max-dur 0.0)) max-dur)
                      rel-dur (or
                               relative-duration
                               (when (and dur-abs exp-dur-in-mcs (< 0 exp-dur-in-mcs)) (/ dur-abs exp-dur-in-mcs))
                               1.0)]
                  {:max-dur max-dur
                   :side-effects-cnt (+ side-effects-cnt (if side-effects 1 0))
                   :items (assoc items k {:duration dur-abs :interpolate interpolate :rel-dur rel-dur :side-effects side-effects})}))
              {:max-dur nil :items {} :side-effects-cnt 0}
              motions)
             full-dur (if (and exp-dur-in-mcs max-dur)
                        (max exp-dur-in-mcs max-dur)
                        (or exp-dur-in-mcs max-dur))
             items (if (and full-dur (not= full-dur exp-dur-in-mcs) (< 0 full-dur))
                     (update-vals
                      items
                      (fn [{:keys [duration interpolate side-effects]}]
                        {:interpolate interpolate
                         :rel-dur (if duration (/ duration full-dur) 1.0)
                         :side-effects side-effects}))
                     items)]
         {:duration (some-> (or (from-mcs full-dur) exp-dur) t/duration)
          :interpolate (fn [initial T]
                         (let [from (or initial default)
                               results (mapcat
                                        (fn [[k {:keys [interpolate rel-dur]}]]
                                          (let [transform-t #(cond
                                                               (zero? rel-dur) (if (= % 0.0) 0.0 1.0)
                                                               (= 1.0 rel-dur) %
                                                               :else (min 1.0 (/ % rel-dur)))
                                                t (transform-t T)]
                                            [k (interpolate (get from k) t)]))
                                        items)]
                           (apply assoc (cons from results))))
          :side-effects (when (< 0 side-effects-cnt)
                          (let [effects
                                (filter
                                 some?
                                 (map
                                  (fn [[_ {:keys [rel-dur side-effects]}]]
                                    (when side-effects
                                      (let [transform #(transform-effect-t % 0.0 rel-dur rel-dur)]
                                        #(side-effects (map transform %)))))
                                  items))]
                            (fn [range]
                              (apply concat (map #(% range) effects)))))}))
     (fn [] (str "(par " (str/join " " (map (fn [[k v]] (if is-map? (str k " " ((:to-string v))) ((:to-string v)))) motions)) ")")))))

(defn ^Motion action-with!
  "Action motion that calls a function with the value.
   ```clojure
   (seq
     (to 10.0)
     (action-with! :prn println)) ;; Prints 10.0
   ```
   
   If you need to call a function without the value, you can use `action!`"
  [id action]
  (motion
   (fn [value _]
     {:duration 0
      :interpolate (constantly value)
      :side-effects (fn [[start end]]
                      (if (and (< start 1.0) (<= 1.0 end)) [#(action value)] []))})
   (constantly (str "(action-with! " id ")"))))

(defn ^Motion action!
  "Action motion that calls a function.
   ```clojure
   (seq
     (to 10.0)
     (action! :tap HapticFeedback.selectionClick)
     (to 20.0))
   ```
   
   If you need to call a function with the value, you can use `action-with!`"
  [id action]
  (motion
   (.-prepare (action-with! id (fn [_] (action))))
   (constantly (str "(action! " id ")"))))

(defn ^Motion duration
  "Set the duration of the motion.\\
   `duration` takes a duration and an motion and returns a new motion with the provided duration.\\
   The duration is applied to the motion.
   ```clojure
   (duration 100 (to 10.0))
   ```"
  [duration motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value _]
       (let [{:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value duration)
             duration-mcs (in-mcs duration)
             dur-mcs (in-mcs duration)
             max-duration (if (and duration-mcs dur-mcs) (max duration-mcs dur-mcs) (or duration-mcs dur-mcs))
             end (when (and dur-mcs (not= dur-mcs max-duration) (< 0 max-duration)) (/ dur-mcs max-duration))
             curve (when end (curves/interval nil end :linear))]
         {:interpolate (if curve
                         (fn [value t] (interpolate value (.transform curve (double t))))
                         interpolate)
          :relative-duration relative-duration
          :duration (from-mcs max-duration)
          :side-effects (when side-effects
                          (if curve
                            (fn [interval]
                              (side-effects (map #(.transform curve (double %)) interval)))
                            side-effects))}))
     (fn [] (str "(duration " duration " " ((:to-string motion)) ")")))))

(defn ^Motion curve
  "Set the curve of the motion.\\
   `curve` takes a curve and an motion and returns a new motion with the provided curve.\\
   The curve is applied to the motion.
   ```clojure
   (curve :ease-in-out (to 10.0))
   ```"
  [curve motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value exp-dur]
       (let [{:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value exp-dur)
             curve (t/curve curve)]
         {:interpolate (fn [value t] (interpolate value (.transform curve (double t))))
          :relative-duration relative-duration
          :duration duration
          :side-effects (when side-effects
                          (fn [range]
                            (side-effects (map #(.transform curve (double %)) range))))}))
     (fn [] (str "(curve " curve " " ((:to-string motion)) ")")))))

(defn ^Motion relative-duration
  "Set the duration of the motion relative to the parent animation.\\
   `relative-duration` takes a ratio and an motion and returns a new motion with the provided relative duration.\\
   The duration is applied to the motion.
   ```clojure
   (relative-duration 0.5 (to 10.0))
   ```"
  [ratio motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value exp-dur]
       (let [{:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value exp-dur)]
         {:interpolate interpolate
          :duration duration
          :relative-duration (if relative-duration (* ratio relative-duration) ratio)
          :side-effects side-effects}))
     (fn [] (str "(relative-duration " ratio " " ((:to-string motion)) ")")))))

(defn ^Motion relative-delay
  "Set the start time of the motion relative to the duration.\\
   `relative-delay` takes a ratio and an motion and returns a new motion with the provided relative delay.\\
   The delay is applied to the motion.
   ```clojure
   (relative-delay 0.5 (to 10.0))
   ```"
  [delay motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value exp-dur]
       (let [exp-dur-mcs (in-mcs exp-dur)
             delay-mcs (when exp-dur-mcs (* delay exp-dur-mcs))
             dur-mcs (when exp-dur-mcs (* exp-dur-mcs (- 1.0 delay)))
             {:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value (from-mcs dur-mcs))
             dur-mcs (when (and delay-mcs duration) (+ delay-mcs (in-mcs duration)))
             curve (curves/interval delay nil :linear)]
         {:interpolate (fn [value t] (interpolate value (.transform curve (double t))))
          :relative-duration (when relative-duration (+ delay relative-duration))
          :duration (from-mcs dur-mcs)
          :side-effects (when side-effects
                          (fn [interval]
                            (side-effects (map #(.transform curve (double %)) interval))))}))
     (fn [] (str "(relative-delay " delay " " ((:to-string motion)) ")")))))

(defn ^Motion delay
  "Set the start time of the motion.\\
   `delay` takes a duration and an motion and returns a new motion with the provided delay.\\
   The delay is applied to the motion.
   ```clojure
   (delay 100 (to 10.0))
   ```"
  [delay motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value exp-dur]
       (let [exp-dur-mcs (in-mcs exp-dur)
             delay-mcs (in-mcs delay)
             delay-ratio (when (and exp-dur-mcs (< 0 exp-dur-mcs)) (/ delay-mcs exp-dur-mcs))
             dur-mcs (when exp-dur-mcs (- exp-dur-mcs delay-mcs))
             {:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value (from-mcs dur-mcs))
             dur-mcs (in-mcs duration)
             relative-duration (when (and delay-ratio relative-duration) (+ delay-ratio relative-duration))
             full-dur-mcs (when dur-mcs (+ delay-mcs dur-mcs))
             start (when full-dur-mcs (/ delay-mcs full-dur-mcs))
             end (if (and start dur-mcs full-dur-mcs (< 0 full-dur-mcs))
                   (+ start (/ dur-mcs full-dur-mcs))
                   1.0)
             curve (when start (curves/interval start end :linear))]
         {:interpolate (if curve
                         (fn [value t] (interpolate value (.transform curve (double t))))
                         interpolate)
          :relative-duration relative-duration
          :duration (from-mcs full-dur-mcs)
          :side-effects (when side-effects
                          (if curve
                            (fn [interval]
                              (side-effects (map #(.transform curve (double %)) interval)))
                            side-effects))}))
     (fn [] (str "(delay " delay " " ((:to-string motion)) ")")))))

(defn ^Motion with
  "Add options to an animation.\\
   `with` takes a map or key value pairs of options and an motion and returns a new motion with the provided options.\\
   The options are merged with the existing options of the animation.\\
   Options:
    - `:duration` or `:dur` - Duration of the motion in milliseconds, or Duration object or map.
    - `:delay` - Start time of the motion in milliseconds or Duration object or map.
    - `:relative-duration` or `:rel-dur` - Duration of the motion relative to the parent animation.
    - `:relative-delay` or `:rel-delay` - Start time ratio of the motion relative to the duration.
    - `:curve` - Curve of the animation.
   
   ```clojure
   (with {:duration 100} w/Colors.blue)
   (with :dur 100 :curve :ease-in-out w/Colors.blue)
   (with :duration 100 (to 10.0))
   ```"
  ([k v & kvs-motion]
   (let [{:keys [options] [motion] :items} (separate-options (concat [k v] kvs-motion))]
     (with options motion)))
  ([options motion]
   (let [{:keys [relative-delay delay relative-duration duration curve]} (motion-options options)]
     (cond->> motion
       curve (flutter-cljd.animations/curve curve)
       duration (flutter-cljd.animations/duration duration)
       relative-duration (flutter-cljd.animations/relative-duration relative-duration)
       delay (flutter-cljd.animations/delay delay)
       relative-delay (flutter-cljd.animations/relative-delay relative-delay)))))

(defn ^Motion const
  "Creates a motion that steps through constant values.\\
   Takes one or more values and returns a motion that changes discretely between them.\\
   If only one value is provided, creates a constant motion with that value.\\
   Can accept animation options map or key-value pairs after values.\\
   The duration is divided evenly between the values.
   ```clojure
   (const 10.0)  ;; Stays at 10.0
   (const 0 50 100)  ;; Steps from 0 to 50 to 100
   (const 0 100 :dur 2000)  ;; Steps over 1 second
   ```"
  [value & values]
  (let [{:keys [options items]} (separate-last-options (cons value values))
        values (if (fn? (first items)) (map (first items) (rest items)) items)
        prepare (fn [value exp-dur]
                  (let [cnt (count values)
                        last-i (- cnt 1)]
                    (case cnt
                      0 (const-anim value exp-dur)
                      1 (const-anim (last values) exp-dur)
                      {:duration exp-dur
                       :interpolate (fn [_ T]
                                      (let [i (min last-i (int (* T cnt)))]
                                        (nth values i)))})))
        result  (motion
                 prepare
                 (fn [] (str "(const " (str/join " " values) ")")))]
    (if (empty? options) result (with options result))))

(defn ^Motion to
 "Animate to Target Values
 
 `to` creates a motion that animates from the current value to one or more target values. It handles value interpolation and timing.

  Basic Usage:
  ```clojure
  (to 5.0 10.0) ;; Single transition
  (to 5.0 10.0 5.0 1.0 10.0) ;; Multiple transitions
  (to 10.0 :dur 100) ;; With duration
  (to Colors.blue Colors.red Colors.green {:delay 10}) ;; With colors and delay
  ```

  Advantages over Tween:

  to respects the current value and works seamlessly in animation sequences:
  ```clojure
  ;; Traditional tween approach (verbose)
  (seq (tween 0 1) (tween 1 2) (tween 2 3))

  ;; Simplified with to (avoids value duplication)
  (seq (to 0 1) (to 2) (to 3))

  ;; Multiple values in one call  
  (to 0 1 2)
  ```

  Initial Value Behavior:
  
  When to is the first animation step, its first value becomes the initial value:
  ```clojure
  ;; Animate: 0 -> 1
  (seq (to 0 1))
  
  ;; No animation: 1 is initial value
  (seq (to 1))
  
  ;; Animate: 0 -> 1
  (seq (to 0) (to 1))
  
  ;; Animate: 0 -> 1 -> 2
  (seq (to 0) (to 1 2))
  ```

  Setting Initial Values:
  
  To explicitly set initial values, use either:
  ```clojure
  ;; Using from
  (from 0 (to 1))
  
  ;; Using from-to
  (from-to 0 1)
  ```
  
  Value Transformation:
  
  to accepts a transform function as its first argument:
  ```clojure
  ;; Transform color names to color values
  (to t/color :red :blue :green)  
  
  ;; Equivalent to:
  (apply to (map t/color [:red :blue :green]))
  ```

  Configuration Options:
  
  to accepts options as key-value pairs or a map after the values:
  - `:duration`, `:dur` - Animation duration in milliseconds or Duration object/map
  - `:delay` - Start time in milliseconds or Duration object/map
  - `:relative-duration`, `:rel-dur` - Duration relative to parent animation 
  - `:relative-delay`, `:rel-delay` - Start time ratio relative to duration
  - `:curve` - Animation easing curve
  - `:lerp` - Custom interpolation function for value transitions"
  [value & values]
  (let [{:keys [options items]} (separate-last-options (cons value values))
        values (if (fn? (first items)) (map (first items) (rest items)) items)
        lerp (:lerp options #(ut/lerp %1 %2))
        options (assoc options :lerp nil)
        prepare (fn [from exp-dur]
                  {:interpolate
                   (fn [initial T]
                     (let [values (if (some? initial) (cons initial values) values)
                           int-cnt (dec (count values))]
                       (condp = T
                         0.0 (first values)
                         1.0 (last values)
                         (let [k (* T int-cnt)
                               i (int k)
                               t (- k i)]
                           (if (< i int-cnt)
                             ((lerp (nth values i) (nth values (inc i))) t)
                             (last values))))))
                   :duration (if (< (+ (if (nil? from) 0 1) (count values)) 2)
                               (t/duration 0)
                               exp-dur)})
        result (motion
                prepare
                (fn [] (str "(to " (str/join " " values) ")")))]
    (if (empty? options)
      result
      (with options result))))

(defn ^Motion from
  "Set the initial value of the motion.\\
   `from` takes a value and an motion and returns a new motion with the provided initial value.\\
   The initial value is applied to the motion.
   ```clojure
   (from 10.0 (to 20.0))
   ```"
  ([from motion]
   (let [motion (motion-to-map motion)]
     (flutter-cljd.animations/motion
      (fn [_ exp-dur]
        (let [{:keys [duration interpolate side-effects]} ((:prepare-motion motion) from exp-dur)]
          {:duration duration
           :interpolate (fn [_ T] (interpolate from T))
           :side-effects side-effects}))
      (fn [] (str "(from " from " " ((:to-string motion)) ")"))))))

(defn ^Motion from-to
  "Animate from an initial value to final values. It's a shorthand for `(from value (to values))`.\\
   Same as Tween but accepts any number of values.\\
   `from-to` takes an initial value and final values and returns a new motion that animates between them.\\
   Can accept animation options map or key-value pairs after the values.
   ```clojure
   (from-to 0 100)
   (from-to 0 100 :dur 1000)
   ```"
  [value0 value1 & values]
  (if (fn? value0)
    (from (value0 value1) (apply to (cons value0 values)))
    (from value0 (apply to (cons value1 values)))))

(defn ^Motion wait
  "Do nothing for a given duration. Duration is optional.
   ```clojure
   (wait 100)
   ```
   To wait relative to the parent motion wrap the `wait` in `with`:
   ```clojure
   (wait :relative-duration 0.2)
   ```
   Can be used to fill the time between motions:
   ```clojure
   (seq {:duration 600}
     (with {:duration 100} w/Colors.blue)
     (wait) ;; Wait for 400ms
     (with {:duration 100} w/Colors.red))
   ```"
  ([& {:keys [duration dur relative-duration rel-dur delay relative-delay rel-del] :as options}]
   (let [result
         (motion
          (fn [_ exp-dur] {:duration exp-dur
                           :interpolate (fn [value _] value)})
          (constantly "(wait)"))]
     (if (empty? options) result (with options result))))
  ([duration & {:keys [relative-duration rel-dur delay relative-delay rel-del] :as options}]
   (let [result
         (motion
          (fn [_ _] {:duration (t/duration duration)
                     :interpolate (fn [value _] value)})
          (fn [] (str "(wait " duration ")")))]
     (if (empty? options) result (with options result)))))

(defn ^Motion seq
  "Sequential Animation of Values.
   
   `seq` applies a list of motions (or `Animatable` objects) in sequential order.
   
   Duration and Timing:
   - When seq has a duration, it's distributed among motions based on their options or evenly if not specified
   - When seq has a curve, it's distributed across motions and combined with individual motion curves if present
   - seq accepts options as key-value pairs or a map before the motion list
   
   Examples:
   
   ```clojure
   (seq
     (with {:duration 50} w/Colors.blue)
     (with {:duration 100} w/Colors.red))

   (seq {:duration 200 :curve :ease-in-out}   
     (par :color (with {:duration 50} w/Colors.blue)
          :offset (with {:duration 100} 10.0))
     (par :color (with {:duration 50} w/Colors.red)))
   
   (seq :duration 200 :delay 10
     (to w/Colors.blue :relative-duration 0.7)
     (to w/Colors.red))
   ```
   
   Value Consistency:
   
   All seq children must animate the same value type. To animate different values sequentially, use a map and par with keys to target nested values:
   
   ```clojure
   ;; ❌ Incorrect: Mixed value types
   (seq (to 0 100) (to Colors.red Colors.blue))
   (seq (to 0 100) (par :color (to Colors.red Colors.blue)))
   
   ;; ✅ Correct: Map with multiple keys animated sequentially
   (from {:value 0 :color Colors.red} ;; initial value
         (seq 
            (par :value (to 100)) 
            (par :color (to Colors.blue))))
   ```
   
   Note: For evenly spaced value animations, consider using `to` instead of `seq`."
  [& motions]
  (let [{:keys [options items]} (separate-options motions)]
    (if-not (empty? options)
      (with options (-sequential items))
      (-sequential items))))

(defn ^Motion par
  "Parallel Animation of Multiple Properties
  
   `par` enables simultaneous animation of multiple properties, accepting either key-value pairs or a sequence of motions (or Animatable objects). It can animate both maps and vectors.
  
   Basic Usage with Maps:
  
   ```clojure
   ;; Animate a value to {:color w/Colors.blue :offset 10}
   (par
     :color (to w/Colors.blue :duration 50)
     :offset (to 10.0 :duration 100))
   ```
  
   Nested Value Animation:
  
   `par` merges animated key-value pairs into the initial value, allowing animation of nested properties in maps or vectors:
  
   ```clojure
   ;; Sequential animation of map properties
   (from {:color Colors.red :offset 0}
        (seq
          (par :color (to Colors.blue))
          (par :offset (to 10))))
  
   ;; Sequential animation of vector elements
   (from [Colors.blue 0]
        (seq
          (par 0 (to Colors.blue))
          (par 1 (to 10))))
   ```
  
   Nested Properties:
  
   `par` calls can be nested to animate deeply nested properties:
  
   ```clojure
   (par :offset (par :dx (to 10.0)))
   ```
  
   Vector Animation:
  
   When par receives a list of motions, it produces a vector result:
  
   ```clojure
   ;; Animates from [0 0] to [100 30]
   (par (to 0 100) (to 0 30))

   ;; Animates from [0 0 0] to [1 1 1] with staggered delays
   (par (map #(to 0 1 :delay (* 10 %)) (range 3)))
   ```
  
   Configuration Options:
  
   par accepts options as either key-value pairs or a map before the motion list:
  
   ```clojure
   (par {:duration 200 :curve :ease-in-out}
     :color (to w/Colors.blue)
     :offset (to 10.0 :duration 100))
   ```
  
   Simplification with to:
  
   For simple cases, prefer using to directly:
  
   ```clojure
   ;; With par
   (par :first (to 0) :second (to 100))
  
   ;; Simplified with to
   (to {:first 0 :second 100})
  
   ;; With par
   (par (to 0) (to 100))
  
   ;; Simplified with to
   (to [0 100])
   ```"
  [& kvs]
  (let [{:keys [options items]} (separate-options kvs)
        values (->> items flatten (filter some?))
        result  (if (instance? w/Animatable (first values))
                  (-parallel values)
                  (-parallel (partition 2 values)))]
    (if-not (empty? options)
      (with options result)
      result)))

(defn ^Motion repeat
  "Repeats a motion a specified number of times.\\
   Takes a count and a motion, returns a new motion that repeats the input animation.\\
   The total duration will be the motion's duration multiplied by the count.\\
   If count is 0 or negative, returns an instant animation.\\
   If count is 1, returns the original motion unchanged.
   ```clojure
   (repeat 3 (to 0 100))  ;; Goes 0 -> 100 three times
   ```"
  ([cnt motion]
   (let [motion (motion-to-map motion)]
     (flutter-cljd.animations/motion
      (cond
        (<= cnt 0) (.-prepare (instant))
        (= cnt 1) (:prepare-motion motion)
        :else
        (fn [value exp-dur]
          (let [relative-duration (/ cnt)
                loop-dur (when exp-dur {:microseconds (* (in-mcs exp-dur) relative-duration)})
                {:keys [duration interpolate side-effects]} ((:prepare-motion motion) value loop-dur)
                transform #(if (= % 1.0) 1.0 (mod (* % cnt) 1.0))]
            {:interpolate #(interpolate %1 (transform %2))
             :duration (some-> (or (when duration {:microseconds (* (in-mcs duration) cnt)}) exp-dur) t/duration)
             :side-effects (when side-effects
                             (fn [[start end]]
                               (let [dur (- end start)]
                                 (if (<= relative-duration dur)
                                   (side-effects [0.0 1.0])
                                   (let [[x y] (map #(int (/ % cnt)) [start end])
                                         s (transform start)
                                         e (transform end)
                                         ranges (if (= x y) [[s e]] [[s 1.0] [0.0 e]])]
                                     (apply concat (map side-effects ranges)))))))})))
      (fn [] (str "(repeat " cnt " " ((:to-string motion)) ")"))))))

(defn ^Motion autoreverse
  "Creates a motion that plays forward then reverses.\\
   Takes a motion and returns a new motion that plays the input animation\\
   forward then plays it in reverse.\\
   The total duration will be double the original motion's duration.
   ```clojure
   (autoreverse (to 0 100))  ;; Goes 0 -> 100 -> 0
   ```"
  ([motion]
   (let [motion (motion-to-map motion)]
     (flutter-cljd.animations/motion
      (fn [value exp-dur]
        (let [loop-dur (when exp-dur {:microseconds (/ (in-mcs exp-dur) 2)})
              {:keys [duration interpolate side-effects]} ((:prepare-motion motion) value loop-dur)
              transform #(* (if (<= % 0.5) % (- 1.0 %)) 2)]
          {:interpolate
           (fn [value T]
             (let [t (transform T)]
               (interpolate value t)))
           :duration (some-> (or (when duration {:microseconds (* (in-mcs duration) 2)}) exp-dur) t/duration)
           :side-effects (when side-effects
                           (fn [[start end]]
                             (let [s (transform start)
                                   e (transform end)
                                   ranges
                                   (if (or (<= end 0.5) (<= 0.5 start))
                                     [[(min s e) (max s e)]]
                                     [[s 1.0] [e 1.0]])]
                               (apply concat (map #(side-effects %) ranges)))))}))
      (fn [] (str "(autoreverse " ((:to-string motion)) ")"))))))

(defn ^Motion synced
  "Creates a motion that syncs with the current time.\\
  Takes a motion and returns a new motion that syncs the input animation with the current time.\\
  The total duration will be the original motion's duration.
  ```clojure
  ;; Loader widget that is synced with the current time, so all loaders will be in sync.
  (widget
   :vsync vsync
   :managed [rotation-cntr (motion-controller
                              vsync
                              (synced (to 0.0 (* 2 π) :dur 1000)))]
   (->> (image \"loader.png\")
        (animated rotation-cntr rotated)
        (center)
        (on-create #(.repeat rotation-cntr))))
  ```"
  [motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value exp-dur]
       (let [{:keys [duration interpolate side-effects]} ((:prepare-motion motion) value exp-dur)
             dur-ms (when duration (.-inMilliseconds (t/duration duration)))
             transform (fn [_] (/ (mod (.-millisecondsSinceEpoch (dc/DateTime.now)) dur-ms) dur-ms))]
         {:interpolate (if (and dur-ms (< 0 dur-ms))
                         (fn [value t] (interpolate value (transform t)))
                         interpolate)
          :duration duration
          :side-effects (when side-effects
                          (if dur-ms
                            (fn [range] (side-effects (map transform range)))
                            side-effects))}))
     (fn [] (str "(synced " ((:to-string motion)) ")")))))

(defn ^Motion tile
  "Creates a motion that tiles/repeats within the parent duration.
   
   Takes a motion and returns a new motion that repeats the input animation to fill
   the parent duration. Unlike `repeat`, which multiplies the duration, `tile` fits
   the original motion into the parent duration as many times as possible.
   
   The total duration will match the parent duration, with the original motion repeating
   within that timeframe.
   
   ```clojure
   ;; Create a 2-second animation containing a repeating 500ms motion
   (seq {:duration 2000}
     (tile (to 0 100 :duration 500)))  ;; Repeats 0->100 four times
   
   ;; Useful for continuous animations like rotation or color cycling
   (widget
     :managed [controller (motion-controller 
                           vsync 
                           (seq {:duration 5000}
                             (tile (to 0 360 :duration 1000))))]
     (->> (image \"spinner.png\")
          (animated controller rotate)
          (on-create #(.repeat controller))))
   ```
   
   See also:
   - `repeat` - Repeats a motion a specific number of times
   - `synced` - Syncs a motion with the current time"
  [motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value exp-dur]
       (let [{:keys [duration interpolate side-effects]} ((:prepare-motion motion) value exp-dur)
             dur-mcs (in-mcs duration)
             exp-dur-mcs (in-mcs exp-dur)
             ratio (when (and exp-dur-mcs (< 0 exp-dur-mcs)) (/ dur-mcs exp-dur-mcs))
             transform (if ratio #(time-mod % ratio) identity)]
         {:interpolate (if ratio
                         (fn [value t] (interpolate value (transform t)))
                         interpolate)
          :duration (or exp-dur duration)
          :side-effects (when side-effects
                          (fn [range]
                            (side-effects (map transform range))))}))
     (fn [] (str "(tile " ((:to-string motion)) ")")))))

(defn ^Motion map-motion
  "Creates a motion that maps the value with a function.\\
   Takes a function and a motion and returns a new motion that applies the function to the value.\\
   ```clojure
   (map-motion inc (to 0 10))  ;; Goes 1 -> 11
   (map-motion int (to 0 10))  ;; Goes 0 -> 10 discretely
   ```"
  [f motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value exp-dur]
       (let [{:keys [duration interpolate side-effects]} ((:prepare-motion motion) value exp-dur)]
         {:interpolate (fn [value t] (f (interpolate value t)))
          :duration duration
          :side-effects side-effects}))
     (fn [] (str "(map-motion " ((:to-string motion)) ")")))))
