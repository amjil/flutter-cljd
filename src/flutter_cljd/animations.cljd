(ns flutter-cljd.animations
  (:require
   [cljd.core :as c]
   [cljd.set :refer [superset?]]
   [flutter-cljd.types :as t]
   [flutter-cljd.curves :as curves]
   ["package:flutter/widgets.dart" :as w]
   ["package:flutter/animation.dart" :as a]
   [flutter-cljd.utils :as ut]
   [cljd.string :as str]))

(extend-protocol c/IFn
  a/Curve
  (-invoke [this t]
    (.transform this t))

  a/Animatable
  (-invoke [this t]
    (.transform this t)))

;; (deftype TransformedAnimation
;;          [^a/Animation parent transform]
;;   :extends a/Animation
;;   (isAnimating [this] (-> this .-parent .-isAnimating))
;;   (isCompleted [this] (-> this .-parent .-isCompleted))
;;   (isDismissed [this] (-> this .-parent .-isDismissed))
;;   (isForwardOrCompleted [this] (-> this .-parent .-isForwardOrCompleted))
;;   (status [this] (-> this .-parent .-status))
;;   (value [this] ((.-transform this) (-> this .-parent .-value)))
;;   (addListener [this listener] (.addListener (.-parent this) listener))
;;   (removeListener [this listener] (.removeListener (.-parent this) listener))
;;   (addStatusListener [this listener] (.addStatusListener (.-parent this) listener))
;;   (removeStatusListener [this listener] (.removeStatusListener (.-parent this) listener)))

;; (defn animation-of
;;   ([^a/Animation value transform]
;;    (TransformedAnimation value transform)))

;; (defn- set-value [this new-value]
;;   (let [old-value (-> this .-tween .-end)
;;         tween (.-tween this)]
;;     (when-not (= new-value old-value)
;;       (.-begin! tween (.evaluate tween this))
;;       (.-end! tween new-value)
;;       (if-not (.-isAnimating this)
;;         (.forward this .from 0.0)
;;         (let [progress (.-value this)]
;;           (.forward this .from 0.0)
;;           (.-value! this progress)))
;;       nil)))

;; (defn- get-state [this]
;;   (-> this .-tween .-end))

;; (deftype AnimatedValue
;;          [tween
;;           ^a/TickerProvider vsync
;;           duration
;;           curve]
;;   :extends (a/AnimationController
;;              .vsync vsync
;;              .duration duration)
;;   c/IEquiv
;;   (-equiv [o other] (identical? o other))
;;   c/IDeref
;;   (-deref [this] (get-state this))
;;   c/ISwap
;;   (-swap! [this f] (set-value this (f (get-state this))))
;;   (-swap! [this f a] (set-value this (f (get-state this) a)))
;;   (-swap! [this f a b] (set-value this (f (get-state this) a b)))
;;   (-swap! [this f a b xs] (set-value this (apply f (get-state this) a b xs)))
;;   c/IReset
;;   (-reset! [this new-value] (set-value this new-value))
;;   c/IFn
;;   (-invoke [this transform]
;;     (animation-of this transform)))

;; (defn animated-value
;;   ([initial-value vsync] (animated-value initial-value vsync {}))
;;   ([initial-value vsync options]
;;    (let [options (t/animation-options options)]
;;      (AnimatedValue
;;       (t/tween (:lerp options) initial-value initial-value)
;;       vsync
;;       (:duration options)
;;       (:curve options)))))

;; (defn anim-cntr
;;   ([options motions])

;;   ([motions]))

(defn- in-mcs [duration]
  (some-> duration t/duration .-inMicroseconds double))

(defn- from-mcs [mcs]
  (when mcs (t/duration {:microseconds mcs})))

(defn- is-options? [x]
  (and
   (map? x)
   (superset? #{:duration :curve :lerp :relative-duration :delay :relative-delay} (set (keys x)))))

(defn- const-anim
  ([value]
   (fn [_ cache] {:value value :cache cache}))
  ([value duration]
   {:interpolate (const-anim value)
    :duration duration}))

(defn- no-cache-anim
  ([transform] (fn [t cache] {:value (transform t) :cache cache}))
  ([transform duration]
   {:interpolate (no-cache-anim transform)
    :duration duration}))

(defn to
  "Animate to a value.\\
     `to` takes a value and returns an motion that animates from the current value to the provided values.\\
     If the current value is nil, the first value is used as the initial value.
     ```clojure
     (to 10.0)
     (to 5.0 10.0)
     (to Colors.blue Colors.red Colors.green)
     ```"
  [value & values]
  (let [values (cons value values)]
    {:prepare-motion
     (fn [from exp-dur]
       (let [values (if (some? from) (concat [from] values) values)
             int-cnt (dec (count values))
             lerp #(ut/lerp %1 %2)]
         {:interpolate (case int-cnt
                         0 (const-anim (first values))
                         1 (no-cache-anim (lerp (first values) (second values)))
                         (no-cache-anim
                          (fn [T]
                            (condp = T
                              0.0 (first values)
                              1.0 (last values)
                              (let [k (* T int-cnt)
                                    i (int k)
                                    t (- k i)]
                                (if (< i int-cnt)
                                  ((lerp (nth values i) (nth values (inc i))) t)
                                  (last values)))))))
          :duration (if (zero? int-cnt) (t/duration 0) exp-dur)}))
     :description
     (str "(to " (str/join " " values) ")")}))

(defn into-motion
  ([motion string]
   (when motion
     (assoc (into-motion motion) :description string)))
  ([motion]
   (cond
     (and (map? motion) (superset? #{:prepare-motion :description} (set (keys motion))))
     motion

     (fn? motion)
     {:prepare-motion motion :description "motion"}

     (instance? w/Animatable motion)
     {:prepare-motion (fn [_ duration]
                        (no-cache-anim #(.transform motion %) duration))
      :description (.toString motion)}

     (nil? motion)
     nil

     :else
     (to motion))))

(defn instant
  "Instant motion with zero duration.
   ```clojure
   (instant 10.0)
   (instant)
   ```"
  ([]
   (into-motion
    (fn [value _] (const-anim value 0))
    "(instant)"))
  ([value]
   (into-motion
    (fn [_ _] (const-anim value 0))
    (str "(instant " value ")"))))

(defn action
  [action]
  (into-motion
   (fn [value _]
     {:duration 0
      :interpolate (fn [t cache]
                     (when (and
                            (= 1.0 t)
                            (:is-animating cache)
                            (not= 1.0 (:last-t cache)))
                       (action value))
                     {:value value :cache cache})})
   "(action fn)"))

(defn- flat-motions [motions]
  (->> motions
       (mapcat
        #(if (sequential? %) (flat-motions %) [%]))))

(defn- -sequential [motions]
  (let [motions (->> motions flat-motions (filter some?) (map into-motion))
        clamp #(min 1.0 (max 0.0 %))]
    (into-motion
     (fn [value exp-dur]
       (let [{:keys [sum-abs sum-rel cnt-any items intr-dur]}
             (reduce
              (fn [res motion]
                (if (some? motion)
                  (let [{:keys [value sum-abs sum-rel]} res
                        {:keys [duration relative-duration interpolate]} ((:prepare-motion motion) value nil)
                        next-value (:value (interpolate 1.0 {}))
                        duration (in-mcs duration)
                        relative (when (and (nil? duration) relative-duration) (clamp relative-duration))]
                    {:value next-value
                     :sum-abs (if duration (+ duration (or sum-abs 0.0)) sum-abs)
                     :sum-rel (+ sum-rel (or relative 0.0))
                     :cnt-any (+ (:cnt-any res) (if (or duration relative) 0 1))
                     :cnt-abs (+ (:cnt-abs res) (if duration 1 0))
                     :intr-dur (when (and duration relative-duration (< 0 relative-duration)) (/ duration relative-duration))
                     :items (conj (:items res) {:duration duration :relative-duration relative :interpolate interpolate})})
                  res))
              {:value value :sum-abs nil :sum-rel 0.0 :cnt-any 0 :cnt-abs 0 :items []}
              motions)
             rel-k (if (< 1 sum-rel) (/ sum-rel) 1.0)
             sum-rel (clamp sum-rel)
             min-dur (if (and sum-abs sum-rel (< sum-rel 1.0)) (/ sum-abs (- 1.0 sum-rel)) sum-abs)
             exp-dur (in-mcs exp-dur)
             res-dur (let [durs (->> 
                                 [exp-dur intr-dur]
                                 (concat (if (< 0 cnt-any) [] [min-dur]))
                                 (filter some?))]
                       (when-not (empty? durs) (apply max durs)))
             any-dur (if (> cnt-any 0)
                       (if (and res-dur min-dur (> res-dur 0))
                         (/ (- (/ (- res-dur min-dur) res-dur) sum-rel) cnt-any)
                         (/ (- 1.0 sum-rel) cnt-any))
                       0.0)
             final-items (reduce
                          (fn [res item]
                            (let [{:keys [duration relative-duration]} item
                                  relative-duration (when relative-duration (* rel-k relative-duration))
                                  t (if (empty? res) 0.0 (:end (last res)))
                                  rel-dur (or relative-duration
                                              (when res-dur
                                                (if (< 0 res-dur)
                                                  (if duration (/ duration res-dur) any-dur)
                                                  1.0))
                                              any-dur)
                                  end (+ t rel-dur)]
                              (conj res (assoc item :start t :end end :rel-dur rel-dur))))
                          []
                          items)
             cnt (count final-items)]
         {:duration (from-mcs res-dur)
          :interpolate (case cnt
                         0 (const-anim value)
                         1 (:interpolate (first final-items))
                         (fn [t cache]
                           (let [items-cache (:items cache {})
                                 last-t (:last-t cache)
                                 is-forward? (or (nil? last-t) (when last-t (< last-t t)) (= last-t t 0.0))
                                 start-key (if is-forward? :start :end)
                                 end-key (if is-forward? :end :start)
                                 start-point (if is-forward? 0.0 1.0)
                                 end-point (if is-forward? 1.0 0.0)
                                 strict-compare (if is-forward? < >)
                                 soft-compare (if is-forward? <= >=)
                                 last-i (- cnt 1)
                                 clamp-start #(if is-forward? (max 0.0 %) (min 1.0 %)) 
                                 clamp-end #(if is-forward? (min 1.0 %) (max 0.0 %))
                                 is-last? #(if is-forward? (= last-i %) (= 0 %))
                                 is-first? #(if is-forward? (= 0 %) (= last-i %))
                                 filtered (->> final-items
                                               (map-indexed (fn [i item] [i item]))
                                               (filter #(let [[i item] %
                                                              rel-dur (:rel-dur item)
                                                              start (start-key item)
                                                              end (end-key item)]
                                                          (and (not (and last-t (strict-compare end last-t)))
                                                               (or (and (soft-compare start t) (strict-compare t end))
                                                                   (and (zero? rel-dur) (= end t))
                                                                   (and (is-first? i) (strict-compare t start))
                                                                   (and (is-last? i) (soft-compare end t)))))))
                                 items (map (fn [[i {:keys [rel-dur interpolate] :as item}]]
                                              (let [start (start-key item)
                                                    end (end-key item)
                                                    transform-t #(if (zero? rel-dur) end-point (/ (- % (:start item)) rel-dur))
                                                    clamped-t #(cond 
                                                                 (is-first? i) (clamp-end (transform-t %)) 
                                                                 (is-last? i) (clamp-start (transform-t %))  
                                                                 :else (clamp (transform-t %)))
                                                    anim-t (clamped-t t)
                                                    last-anim-t (when last-t (clamped-t last-t))
                                                    item-cache-fn #(merge
                                                                    (assoc cache :items nil)
                                                                    (get items-cache i {})
                                                                    {:last-t %})
                                                    value-fn #(interpolate %1 %2)
                                                    last-t (or last-t start)
                                                    value (cond
                                                            (or (zero? rel-dur) (soft-compare last-t start end t))
                                                            (value-fn end-point (item-cache-fn start-point))

                                                            (soft-compare start last-t end t)
                                                            (value-fn end-point (item-cache-fn last-anim-t))

                                                            :else
                                                            (value-fn anim-t (item-cache-fn last-anim-t)))]
                                                [i value]))
                                            (if is-forward? filtered (reverse filtered)))
                                 new-value (some-> items last last :value)
                                 new-items-cache (into items-cache (map (fn [[i {:keys [cache]}]] [i cache]) items))]
                             {:value (if (empty? items) value new-value)
                              :cache (assoc cache :items new-items-cache)})))}))
     (str "(seq " (str/join " " (map :description motions)) ")"))))

(defn- -parallel [motions]
  (let [motions (map (fn [[k v]] [k (into-motion v)]) motions)]
    (into-motion
     (fn [value exp-dur]
       (let [value (or value {})
             exp-dur-in-mcs (in-mcs exp-dur)

             {:keys [max-dur items]}
             (reduce
              (fn [res [k v]]
                (let [{:keys [duration relative-duration interpolate]} ((:prepare-motion v) (get value k) exp-dur)
                      {:keys [max-dur items]} res
                      dur-abs (or
                               (in-mcs duration)
                               (when (and relative-duration exp-dur-in-mcs) (* exp-dur-in-mcs relative-duration)))
                      max-dur (if dur-abs (max dur-abs (or max-dur 0.0)) max-dur)
                      rel-dur (or
                               relative-duration
                               (when (and dur-abs exp-dur-in-mcs (< 0 exp-dur-in-mcs)) (/ dur-abs exp-dur-in-mcs))
                               1.0)]
                  {:max-dur max-dur
                   :items (assoc items k {:duration dur-abs :interpolate interpolate :rel-dur rel-dur})}))
              {:max-dur nil :items {}}
              motions)
             full-dur (if (and exp-dur-in-mcs max-dur)
                        (max exp-dur-in-mcs max-dur)
                        (or exp-dur-in-mcs max-dur))
             items (if (and full-dur (not= full-dur exp-dur-in-mcs) (< 0 full-dur))
                     (update-vals
                      items
                      (fn [{:keys [duration interpolate]}]
                        {:interpolate interpolate
                         :rel-dur (if duration (/ duration full-dur) 1.0)}))
                     items)]
         {:duration (some-> (or (from-mcs full-dur) exp-dur) t/duration)
          :interpolate (fn [T cache]
                         (let [last-T (:last-t cache)
                               items-cache (:items cache {})
                               results (map
                                        (fn [[k {:keys [interpolate rel-dur]}]]
                                          (let [transform-t #(cond
                                                               (zero? rel-dur) 1.0
                                                               (= 1.0 rel-dur) %
                                                               :else (min 1.0 (/ % rel-dur)))
                                                t (transform-t T)
                                                last-t (when last-T (transform-t last-T))]
                                            [k (interpolate
                                                t
                                                (merge
                                                 (assoc cache :items nil)
                                                 (get items-cache k {})
                                                 {:last-t last-t}))]))
                                        items)
                               new-value (into value (map (fn [[k {:keys [value]}]] [k value]) results))
                               new-items-cache (into items-cache (map (fn [[k {:keys [cache]}]] [k cache]) results))]
                           {:value new-value
                            :cache (assoc cache :items new-items-cache)}))}))
     (str "(par " (str/join " " (map (fn [[k v]] (str k " " (:description v))) motions)) ")"))))

(defn duration
  [duration motion]
  (let [motion (into-motion motion)]
    (into-motion
     (fn [value _]
       (let [{:keys [interpolate duration relative-duration]} ((:prepare-motion motion) value duration)
             duration-mcs (in-mcs duration)
             dur-mcs (in-mcs duration)
             max-duration (if (and duration-mcs dur-mcs) (max duration-mcs dur-mcs) (or duration-mcs dur-mcs))
             end (when (and dur-mcs (not= dur-mcs max-duration) (< 0 max-duration)) (/ dur-mcs max-duration))
             curve (when end (curves/interval 0.0 end :linear))]
         {:interpolate (if curve
                         #(interpolate (.transform curve (double %1)) %2)
                         interpolate)
          :relative-duration relative-duration
          :duration (from-mcs max-duration)}))
     (str "(duration " duration " " (:description motion) ")"))))

(defn curve
  [curve motion]
  (let [motion (into-motion motion)
        curve (t/curve curve)]
    (into-motion
     (fn [value exp-dur]
       (let [{:keys [interpolate duration relative-duration]} ((:prepare-motion motion) value exp-dur)]
         {:interpolate #(interpolate (.transform curve (double %1)) %2)
          :relative-duration relative-duration
          :duration duration}))
     (str "(curve " (.toString curve) " " (:description motion) ")"))))

(defn relative-duration
  [ratio motion]
  (let [motion (into-motion motion)]
    (into-motion
     (fn [value exp-dur]
       (let [{:keys [interpolate duration relative-duration]} ((:prepare-motion motion) value exp-dur)]
         {:interpolate interpolate
          :duration duration
          :relative-duration (if relative-duration (* ratio relative-duration) ratio)}))
     (str "(relative-duration" ratio " " (:description motion) ")"))))

(defn relative-delay
  [delay motion]
  (let [motion (into-motion motion)]
    (into-motion
     (fn [value exp-dur]
       (let [exp-dur-mcs (in-mcs exp-dur)
             delay-mcs (when exp-dur-mcs (* delay exp-dur-mcs))
             dur-mcs (when exp-dur-mcs (* exp-dur-mcs (- 1.0 delay)))
             {:keys [interpolate duration relative-duration]} ((:prepare-motion motion) value (from-mcs dur-mcs))
             dur-mcs (when (and delay-mcs duration) (+ delay-mcs (in-mcs duration)))
             curve (curves/interval delay 1.0 :linear)]
         {:interpolate #(interpolate (.transform curve (double %1)) %2)
          :relative-duration (when relative-duration (+ delay relative-duration))
          :duration (from-mcs dur-mcs)}))
     (str "(relative-delay" delay " " (:description motion) ")"))))

(defn delay
  [delay motion]
  (let [motion (into-motion motion)]
    (into-motion
     (fn [value exp-dur]
       (let [exp-dur-mcs (in-mcs exp-dur)
             delay-mcs (in-mcs delay)
             delay-ratio (when (and exp-dur-mcs (< 0 exp-dur-mcs)) (/ delay-mcs exp-dur-mcs))
             dur-mcs (when exp-dur-mcs (- exp-dur-mcs delay-mcs))
             {:keys [interpolate duration relative-duration]} ((:prepare-motion motion) value (from-mcs dur-mcs))
             dur-mcs (in-mcs duration)
             relative-duration (when (and delay-ratio relative-duration) (+ delay-ratio relative-duration))
             full-dur-mcs (when dur-mcs (+ delay-mcs dur-mcs))
             start (when full-dur-mcs (/ delay-mcs full-dur-mcs))
             end (if (and start dur-mcs full-dur-mcs (< 0 full-dur-mcs))
                   (+ start (/ dur-mcs full-dur-mcs))
                   1.0)
             curve (when start (curves/interval start end :linear))]
         {:interpolate (if curve
                         #(interpolate (.transform curve (double %1)) %2)
                         interpolate)
          :relative-duration relative-duration
          :duration (from-mcs full-dur-mcs)}))
     (str "(delay" delay " " (:description motion) ")"))))

(defn with
  "Add options to an animation.\\
   `with` takes a map of options and an motion and returns a new motion with the provided options.\\
   The options are merged with the existing options of the animation.\\
   Options:
    - `:duration` - Duration of the motion in milliseconds, or Duration object or map.
    - `:delay` - Start time of the motion in milliseconds or Duration object or map.
    - `:relative-duration` - Duration of the motion relative to the parent animation.
    - `:relative-delay` - Start time ratio of the motion relative to the duration.
    - `:curve` - Curve of the animation.
   
   ```clojure
   (with {:duration 100} w/Colors.blue)
   (with {:duration 100 :curve :ease-in-out} w/Colors.blue)
   (with {:duration 100} (to 10.0))
   ```"
  [{:keys [relative-delay delay relative-duration duration curve]} motion]
  (cond->> (into-motion motion)
    curve (flutter-cljd.animations/curve curve)
    duration (flutter-cljd.animations/duration duration)
    relative-duration (flutter-cljd.animations/relative-duration relative-duration)
    delay (flutter-cljd.animations/delay delay)
    relative-delay (flutter-cljd.animations/relative-delay relative-delay)))

(defn wait
  "Do nothing for a given duration. Duration is optional.
   ```clojure
   (wait 100)
   ```
   To wait relative to the parent motion wrap the `wait` in `with`:
   ```clojure
   (with {:relative-duration 0.2} (wait))
   ```
   Can be used to fill the time between motions:
   ```clojure
   (seq {:duration 600}
     (with {:duration 100} w/Colors.blue)
     (wait) ;; Wait for 400ms
     (with {:duration 100} w/Colors.red))
   ```"
  ([]
   (into-motion
    (fn [value, exp-dur] (const-anim value exp-dur))
    "(wait)"))
  ([duration]
   (into-motion
    (fn [value, _] (const-anim value duration))
    (str "(wait " duration ")"))))

(defn seq
  "Sequential motions of the value.\\
   `seq` takes a list of motions and applies them one after the other.
   
   If `seq` has a duration, the duration is partitioned between the motions according to their options or evenly if not provided.\\
   If `seq` has a curve, the curve is partitioned between the motions and merged with the motion's curve if provided.
   ```clojure
   (seq
     (with {:duration 50} w/Colors.blue)
     (with {:duration 100} w/Colors.red))
  
   (seq {:duration 200 :curve :ease-in-out}
     (par :color (with {:duration 50} w/Colors.blue)
          :offset (with {:duration 100} 10.0))
     (par :color (with {:duration 50} w/Colors.red)))
   ```
   
   `seq` can be used to define initial value of the motion:
   ```clojure
   (seq
     {:color w/Colors.blue
      :dx 0.0}
     (par
       :color (with {:duration 50} w/Colors.blue)
       :dx (with {:duration 100} 10.0)))
   ```
   If you need animate evenly spaced values, you can use `to` instead."
  [& motions]
  (if (is-options? (first motions))
    (with (first motions) (-sequential (drop 1 motions)))
    (-sequential motions)))

(defn par
  "Parallel motions of multiple properties of the value.\\
   `par` takes a list of key-value pairs, where the key is the property to animate and the value is the animation.\\
   It's useful when you want to animate multiple properties with different motions delay the same time.\\
   If `par` has a duration, the duration is applied to all animations.\\
   If `par` has a curve, the curve is applied to all animations.
   ```clojure
   (par
      :color (with {:duration 50} w/Colors.blue)
      :offset (with {:duration 100} 10.0))
   ```
   It's possible to nest `par` calls to animate nested properties:
   ```clojure
   (par :offset (par :dx (with {:duration 100} 10.0)))
   ```"
  [& kvs]
  (if (odd? (count kvs))
    (if (is-options? (first kvs))
      (with (first kvs) (-parallel (partition 2 (drop 1 kvs))))
      (throw (ex-info "Invalid arguments in par" {:args kvs})))
    (-parallel (partition 2 kvs))))

(defn repeat
  "Repeats an motion a specified number of times.\\
   Takes a count and an motion, returns a new motion that repeats the input animation.\\
   The total duration will be the motion's duration multiplied by the count.\\
   If count is 0 or negative, returns an instant animation.\\
   If count is 1, returns the original motion unchanged.
   ```clojure
   (repeat 3 (to 0 100))  ;; Goes 0->100 three times
   ```"
  ([cnt motion]
   (let [motion (into-motion motion)]
     (into-motion
      (cond
        (<= cnt 0) (instant)
        (= cnt 1) motion
        :else
        (fn [value exp-dur]
          (let [relative-duration (/ cnt)
                loop-dur (when exp-dur {:microseconds (* (in-mcs exp-dur) relative-duration)})
                prepare-motion (:prepare-motion motion)
                {:keys [duration interpolate]} (prepare-motion value loop-dur)]
            {:interpolate
             (fn [T cache]
               (let [transform-t #(if (= % 1.0) 1.0 (mod (* % cnt) 1.0))
                     t (transform-t T)
                     last-T (:last-t cache)
                     last-t (when last-T (transform-t last-T))]
                 (interpolate t (assoc cache :last-t last-t))))
             :duration (some-> (or (when duration {:microseconds (* (in-mcs duration) cnt)}) exp-dur) t/duration)})))
      (str "(repeat " cnt " " (:description motion) ")")))))

(defn autoreverse
  "Creates an motion that plays forward then reverses.\\
   Takes an motion and returns a new motion that plays the input animation\\
   forward then plays it in reverse.\\
   The total duration will be double the original motion's duration.
   ```clojure
   (autoreverse (to 0 100))  ;; Goes 0->100->0
   ```"
  ([motion]
   (let [motion (into-motion motion)]
     (into-motion
      (fn [value exp-dur]
        (let [loop-dur (when exp-dur {:microseconds (/ (in-mcs exp-dur) 2)})
              {:keys [duration interpolate]} ((:prepare-motion motion) value loop-dur)]
          {:interpolate
           (fn [T cache]
             (let [transform-t #(* (if (<= % 0.5) % (- 1.0 %)) 2)
                   t (transform-t T)
                   last-T (:last-t cache)
                   last-t (when last-T (transform-t last-T))]
               (interpolate t (assoc cache :last-t last-t))))
           :duration (some-> (or (when duration {:microseconds (* (in-mcs duration) 2)}) exp-dur) t/duration)}))
      (str "(autoreverse " (:description motion) ")")))))
