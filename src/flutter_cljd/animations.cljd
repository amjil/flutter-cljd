(ns flutter-cljd.animations
  (:require
   [cljd.core :as c]
   [cljd.set :refer [superset?]]
   [flutter-cljd.types :as t]
   [flutter-cljd.curves :as curves]
   ["package:flutter/widgets.dart" :as w]
   ["package:flutter/animation.dart" :as a]
   ["package:flutter/scheduler.dart" :as sc]
   ["dart:core" :as dc]
   [flutter-cljd.utils :as ut]
   [cljd.string :as str]))

(declare motion)

(extend-protocol c/IFn
  a/Curve
  (-invoke [this t]
    (.transform this t))

  a/Animatable
  (-invoke [this t]
    (.transform this t))

  a/AnimationController
  (-invoke [this animatable]
    (.drive this animatable)))

(deftype TransformedAnimation
         [^a/Animation parent transform]
  :extends a/Animation
  (value [this] ((.-transform this) (-> this .-parent .-value)))
  c/IEquiv
  (-equiv [o other] (identical? o other))
  ^:mixin a/AnimationWithParentMixin)

(defn map-anim
  "Transforms an animation using a transform function.\\
     `map-anim` takes an animation and a transform function and returns a new animation.\\
     The transform function takes the value of the parent animation and returns the transformed value.
     ```clojure
     (map-anim #(* % 2) parent)
     ```
     `Animation` implements `ILookup` to create a transformed animation that transforms the value of the parent animation.
     ```clojure
     (let [animation (always-stopped-animation {:x 10.0 :y 20})
           x-animation (:x animation) ;; an animation that always returns 10.0
           y-animation (get animation :y)] ;; an animation that always returns 20.0
     ```"
  [transform parent]
  (TransformedAnimation parent transform))

(extend-protocol c/ILookup
  a/Animation
  (-lookup [this key] (c/-lookup this key nil))
  (-lookup [this key not-found]
    (map-anim (fn [value] (c/-lookup value key not-found)) this))
  (-contains-key? [this key]
    (c/-contains-key? (.-value this) key)))

(defn- set-value [this new-value]
  (let [old-value (-> this .-tween .-end)
        tween (.-tween this)
        controller (.-controller this)]
    (when-not (= new-value old-value)
      (.-begin! tween (.evaluate tween this))
      (.-end! tween new-value)
      (if-not (.-isAnimating controller)
        (.forward controller .from 0.0)
        (let [progress (.-value controller)]
          (.forward controller .from 0.0)
          (.-value! controller progress)))
      nil)))

(defn- get-state [this]
  (-> this .-tween .-end))

(deftype AnimatedValue
         [tween
          ^a/AnimationController controller
          ^a/Animation parent]
  :extends (a/Animation)
  (value [^AnimatedValue this]
    (-> this .-tween (.lerp (-> this .-controller .-value))))
  c/IEquiv
  (-equiv [o other] (identical? o other))
  c/IDeref
  (-deref [^AnimatedValue this] (get-state this))
  c/ISwap
  (-swap! [^AnimatedValue this f] (set-value this (f (get-state this))))
  (-swap! [^AnimatedValue this f a] (set-value this (f (get-state this) a)))
  (-swap! [^AnimatedValue this f a b] (set-value this (f (get-state this) a b)))
  (-swap! [^AnimatedValue this f a b xs] (set-value this (apply f (get-state this) a b xs)))
  c/IReset
  (-reset! [^AnimatedValue this new-value] (set-value this new-value))
  (dispose [^AnimatedValue this]
    (.dispose (.-controller this)))
  ^:mixin a/AnimationWithParentMixin)

(defn ^AnimatedValue animated-value
  "Animation that can be used to animate value changes.\\
   `animated-value` takes an initial value and returns an animated value.\\
   The `vsync` argument is required and specifies the `TickerProvider` for the animation.\\
   The `options` argument is optional and specifies the animation options.\\
   The `options` argument can be a map with the following keys:
    - `:duration` - Duration of the animation.
    - `:curve` - Curve of the animation.
    - `:reverse-curve` - Reverse curve of the animation.
    - `:lerp` - Lerp function of the animation.
   
   ```clojure
   (animated-value 10.0 vsync)
   (animated-value 10.0 vsync {:duration 1000})
   ```
   To start the animation, change the value using `reset!` or `swap!`.
   ```clojure
   (reset! animated-value 20.0)
   ```"
  ([initial-value vsync] (animated-value initial-value vsync {}))
  ([initial-value vsync options]
   (let [options (t/animation-options options)
         controller (a/AnimationController
                     .vsync vsync
                     .duration (:duration options))]
     (AnimatedValue
      (t/tween (:lerp options) initial-value initial-value)
      controller
      (a/CurvedAnimation
       .parent controller
       .curve (:curve options a/Curves.linear)
       .reverseCurve (some-> options :reverse-curve t/curve))))))

(declare MotionController)

(defn- reset-cached-value [^MotionController controller]
  (.-cachedValue! controller nil)
  (.-cachedValueProgress! controller nil))

(defn- set-cached-value [^MotionController controller value]
  (.-cachedValue! controller value)
  (.-cachedValueProgress! controller (-> controller .-parent .-value)))

(defn- set-side-effects [side-effects object animation]
  (if side-effects
    (when (nil? (.-effectsStatusListener object))
      (let [listener
            (fn []
              (let [progress (-> animation .-value)
                    prevProgress (.-prevProgress object)
                    start (min progress (or prevProgress 0.0))
                    end (max progress (or prevProgress 0.0))]
                (when (not= progress prevProgress)
                  (.-prevProgress! object progress)
                  (doseq [effect (side-effects [start end])]
                    (effect)))))
            statusListener (fn [status]
                             (if (or (= status a/AnimationStatus.completed)
                                     (= status a/AnimationStatus.dismissed))
                               (when-let [listener (.-effectsListener object)]
                                 (.removeListener animation listener)
                                 (.-effectsListener! object nil))
                               (when (nil? (.-effectsListener object))
                                 (.-effectsListener! object listener)
                                 (.-prevProgress! object (-> animation .-value))
                                 (.addListener animation listener))))]
        (.-effectsStatusListener! object statusListener)
        (.addStatusListener animation statusListener)))
    (when-let [listener (.-effectsStatusListener object)]
      (.removeStatusListener animation listener)
      (.-effectsStatusListener! object nil))))

(defn- compute-motion [^MotionController controller]
  (when (or (.-needCompute controller) (nil? (.-interpolate controller)))
    (.-needCompute! controller false)
    (reset-cached-value controller)
    (let [{:keys [prepare-motion]} (.-motion controller)
          {:keys [duration interpolate side-effects]} (prepare-motion nil nil)
          {:keys [duration]} (t/animation-options {:duration duration})]
      (.-interpolate! controller interpolate)
      (.-duration! (.-parent controller) duration)
      (set-side-effects side-effects controller (.-parent controller)))))

(deftype ^:private MotionAnimationController
         [^:mutable ^MotionController? motionController
          ^:mutable ^double val
          ^:mutable ^a/Duration? dur
          ^dc/String? dl
          ^a/TickerProvider vs
          ^a/AnimationBehavior ab]
  :extends (a/AnimationController
             .value val
             .duration dur
             .debugLabel dl
             .vsync vs
             .animationBehavior ab)

  (^sc/TickerFuture forward [^MotionAnimationController this ^double? .from]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.forward ^super this .from (some-> from double)))

  (^sc/TickerFuture reverse [^MotionAnimationController this ^double? .from]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.reverse ^super this .from (some-> from double)))

  (^sc/TickerFuture animateTo [^MotionAnimationController this
                               ^double target
                               ^a/Duration? .duration
                               ^a/Curve? .curve]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.animateTo ^super this (double target) .duration (some-> duration t/duration) .curve (t/curve (or curve :linear))))

  (^sc/TickerFuture animateBack [^MotionAnimationController this
                                 ^double target
                                 ^a/Duration? .duration
                                 ^a/Curve? .curve]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.animateBack ^super this (double target) .duration (some-> duration t/duration) .curve (t/curve (or curve :linear))))

  (^sc/TickerFuture repeat [^MotionAnimationController this
                            ^double? .min
                            ^double? .max
                            ^bool? .reverse
                            ^a/Duration? .period
                            ^int? .count]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.repeat ^super this
             .min (some-> min double)
             .max (some-> max double)
             .reverse (boolean reverse)
             .period (some-> period t/duration)
             .count (some-> count int)))
  (^sc/TickerFuture toggle [^MotionAnimationController this ^double? .from]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.toggle ^super this .from (some-> from double))))

(deftype MotionController
         [^:mutable motion
          ^:mutable interpolate
          ^:mutable effectsListener
          ^:mutable effectsStatusListener
          ^:mutable prevProgress
          ^:mutable needCompute
          ^:mutable cachedValue
          ^:mutable cachedValueProgress
          ^:mutable motionString
          ^a/AnimationController parent]
  :extends (a/Animation)
  (value [^MotionController this]
    (if (and (not (.-isAnimating this)) (= (.-cachedValueProgress this) (-> this .-parent .-value)))
      (.-cachedValue this)
      (do
        (compute-motion this)
        (let [result ((.-interpolate this) nil (-> this .-parent .-value))]
          (when-not (.-isAnimating this)
            (set-cached-value this result))
          result))))
  dc/Object
  (toString [^MotionController this]
    (-> this .-motionString))
  c/IEquiv
  (-equiv [o other] (identical? o other))
  (dispose [^MotionController this]
    (.dispose (.-parent this)))
  (^sc/TickerFuture animateBack [^MotionAnimationController this target .duration .curve]
    (.animateBack (.-parent this) (double target) .duration (some-> duration t/duration) .curve (t/curve (or curve :linear))))
  (^sc/TickerFuture animateTo [^MotionAnimationController this target .duration .curve]
    (.animateTo (.-parent this) (double target) .duration (some-> duration t/duration) .curve (t/curve (or curve :linear))))
  (^sc/TickerFuture forward [^MotionController this ^double? .from]
    (.forward (.-parent this) .from (some-> from double)))
  (^sc/TickerFuture repeat [^MotionController this .min .max .reverse .period .count .synced]
    (when synced
      (.sync this))
    (.repeat (.-parent this)
             .min (some-> min double)
             .max (some-> max double)
             .reverse (boolean reverse)
             .period (some-> period t/duration)
             .count (some-> count int)))
  (sync [^MotionController this]
    (reset-cached-value this)
    (compute-motion this)
    (let [duration (-> this .-parent .-duration .-inMilliseconds)]
      (when (< 0 duration)
        (.-value! (.-parent this) (/ (mod (.-millisecondsSinceEpoch (dc/DateTime.now)) duration) duration)))))
  (reset [^MotionController this]
    (.reset (.-parent this)))
  (resync [^MotionController this vsync]
    (.resync (.-parent this) vsync))
  (^sc/TickerFuture reverse [^MotionController this .from]
    (.reverse (.-parent this) .from (some-> from double)))
  (stop [^MotionController this .canceled]
    (.stop (.-parent this) .canceled (boolean (or (nil? canceled) canceled))))
  (^sc/TickerFuture toggle [^MotionController this .from]
    (.toggle (.-parent this) .from (some-> from double)))
  ^:mixin a/AnimationWithParentMixin)

(defn ^double progress
  "Returns the current progress of the motion controller.
   
   The progress is a value between 0.0 and 1.0 representing how far along
   the animation has progressed. 0.0 is the start and 1.0 is the end.
   
   ```clojure
   (let [controller (motion-controller vsync (to 0 100))]
     (progress controller)) ;; Returns current progress, e.g. 0.5
   ```"
  [^MotionController controller]
  (-> controller .-parent .-value))

(defn progress!
  "Sets the current progress of the motion controller.
   
   Takes a controller and a progress value between 0.0 and 1.0.
   Immediately updates the animation to that progress point without animating.
   
   ```clojure
   (let [controller (motion-controller vsync (to 0 100))]
     (progress! controller 0.5) ;; Jumps to 50% progress
     (.-value controller)) ;; Returns 50
   ```"
  [^MotionController controller ^double new-value]
  (.-value! (.-parent controller) new-value))

(defn- in-mcs [duration]
  (some-> duration t/duration .-inMicroseconds double))

(defn- from-mcs [mcs]
  (when mcs (t/duration {:microseconds mcs})))

(def ^:private options-keys #{:duration :dur :rel-dur :rel-delay :curve :lerp :relative-duration :delay :relative-delay})

(defn- is-options? [x]
  (and
   (map? x)
   (superset? options-keys (set (keys x)))))

(defn- motion-options [value]
  {:duration (:duration value (:dur value))
   :delay (:delay value)
   :relative-delay (:relative-delay value (:rel-delay value))
   :relative-duration (:relative-duration value (:rel-dur value))
   :curve (:curve value)
   :lerp (:lerp value)})

(defn- const-anim
  ([value]
   (constantly value))
  ([value duration]
   {:interpolate (const-anim value)
    :duration duration}))

(defn- flat-motions [motions]
  (->> motions
       (mapcat
        #(if (sequential? %) (flat-motions %) [%]))))

(defn- separate-options [args]
  (if (is-options? (first args))
    {:options (first args) :items (drop 1 args)}
    (reduce
     (fn [res arg]
       (let [{:keys [key options items finished]} res]
         (if (not finished)
           (if (nil? key)
             (if (and (keyword? arg) (options-keys arg))
               (assoc res :key arg)
               (assoc res :items (conj items arg) :finished true))
             (assoc res :key nil :options (assoc options key arg)))
           (assoc res :items (conj items arg)))))
     {:options {} :items []}
     args)))

(defn- separate-last-options [args]
  (if (is-options? (last args))
    {:options (last args) :items (drop-last 1 args)}
    (reduce
     (fn [res arg]
       (let [{:keys [options items]} res]
         (if (and (= (count items) 1) (keyword? arg) (options-keys arg))
           {:items [] :options (assoc options arg (first items))}
           {:items (cons arg items) :options options})))
     {:options {} :items []}
     (reverse args))))

(declare Motion)
(defn motion
  [prepare to-string]
  (Motion prepare to-string nil nil nil))

(defn- motion-to-map
  ([motion]
   (cond
     (instance? Motion motion)
     {:prepare-motion (.-prepare motion)
      :to-string (.-toStr motion)}

     (instance? w/Animatable motion)
     {:prepare-motion (fn [_ duration]
                        {:interpolate (fn [_ t] (.transform motion t))
                         :duration duration})
      :to-string #(.toString motion)}

     (nil? motion)
     nil

     :else
     (throw (ex-info "Invalid motion" {:motion motion})))))

(deftype ^:private MotionAnimationWrapper
         [^:mutable effectsListener
          ^:mutable effectsStatusListener
          ^:mutable prevProgress
          interpolate
          ^#/(a/Animation double) parent]
  :extends a/Animation
  (value [^MotionAnimationWrapper this] (interpolate nil (-> this .-parent .-value)))
  ^:mixin a/AnimationWithParentMixin)

(defn- compute-motion-if-needed [^Motion this]
  (when (nil? (.-interpolate this))
    (let [{:keys [interpolate side-effects duration]} ((.-prepare this) nil nil)]
      (.-interpolate! this interpolate)
      (.-effects! this side-effects)
      (.-dur! this (some-> duration t/duration)))))

(deftype Motion [prepare
                 toStr
                 ^a/Duration? ^:mutable dur
                 ^:mutable effects
                 ^:mutable interpolate]
  :extends (a/Animatable)
  Motion
  (^a/Duration? ^:getter duration [^Motion this]
    (compute-motion-if-needed this)
    (.-dur this))
  a/Animatable
  (^a/Animation animate [^Motion this ^#/(a/Animation double) parent]
    (if (instance? a/AnimationController parent)
      (let [duration (.-duration parent)
            {:keys [interpolate side-effects duration]} ((.-prepare this) nil duration)
            result (MotionAnimationWrapper nil nil nil interpolate parent)]
        (when (and duration (not= duration (.-duration parent)))
          (.-duration! parent (t/duration duration)))
        (set-side-effects side-effects result parent)
        result)
      (do
        (compute-motion-if-needed this)
        (let [result (MotionAnimationWrapper nil nil nil (.-interpolate this) parent)]
          (set-side-effects (.-effects this) result parent)
          result))))
  (transform [^Motion this ^double t]
    (compute-motion-if-needed this)
    ((.-interpolate this) nil t))
  (^dc/String toString [^Motion this] ((.-toStr this)))
  (^bool == [^Motion this ^dc/Object other]
    (= (.toString this) (.toString other))))

(defn set-motion!
  "Sets the motion of the motion controller.
   
   Takes a motion controller and a new motion to animate.
   Updates the controller to use the new motion while preserving the current progress.
   If the controller is currently animating, it will continue with the new motion.
   
   ```clojure
   (let [controller (motion-controller vsync (to 0 100))]
     (.forward controller) ;; Start animating
     (set-motion! controller (to 200 300)) ;; Change destination mid-animation
     (.-value controller)) ;; Returns interpolated value between 200-300
   ```"
  [^MotionController controller motion]
  (let [motion-map (motion-to-map motion)
        string ((:to-string motion-map))]
    (.-motion! controller motion-map)
    (.-needCompute! controller (not= string (.-motionString controller)))
    (.-motionString! controller string)
    (when (.-isAnimating controller)
      (compute-motion controller))
    controller))

(defn motion-controller
  "Creates a motion controller that manages animations.

  Arguments:
   - vsync: A `TickerProvider` that drives the animation (usually obtained from a widget's state)
   - motion: The motion to animate (created with `to`, `par`, `seq`, etc.)
   - options (optional):
     - :progress - Initial progress value (default: 0.0)
     - :debug-label - Label for debugging (optional)
     - :animation-behavior - Animation behavior on hot reload (default: :preserve)

  Returns a `MotionController` instance that provides these methods:

  Animation Control:
   - .forward [from] - Start forward animation from optional progress value
   - .reverse [from] - Start reverse animation from optional progress value
   - .stop [canceled] - Stop animation (canceled defaults to true)
   - .toggle [from] - Toggle between forward/reverse from optional progress
   - .animateTo [target duration curve] - Animate to target value over duration with curve
   - .animateBack [target duration curve] - Animate back to target over duration with curve
   - .sync - Sync progress with current time
   - .repeat [min max reverse period count synced] - Repeat animation with options:
      - min: Minimum progress value (optional)
      - max: Maximum progress value (optional) 
      - reverse: Whether to reverse direction (optional)
      - period: Duration of each repeat cycle (optional)
      - count: Number of times to repeat (optional)
      - synced: Whether to sync start progress with current time (optional)
   - .reset - Reset to initial state
   - .resync [vsync] - Resync with new vsync provider
   - .dispose - Clean up resources

  Properties:
   - .-value - Current animated value
   - .-parent - Underlying AnimationController
   - .-isAnimating - Whether animation is running

  Helper Functions:
   - progress [controller] - Get current progress (0.0 to 1.0)
   - progress! [controller value] - Set current progress
   - set-motion! [controller motion] - Change the motion being animated

  Examples:
  ```clojure
  ;; Basic usage
  (motion-controller vsync (to 0.0 10.0))

  ;; With initial progress
  (motion-controller vsync (to 0.0 100.0) :progress 0.5)

  ;; Parallel animations with child animations
  (let [controller (motion-controller 
                    vsync
                    (par {:dur 500}
                         :opacity (to 0.0 1.0 :delay 100)
                         :offset (to 0.0 100)))]
    ;; Use child animations in widgets
    (widget
      :managed [animation controller]
      (->> (text \"Hello\")
           (animated (:opacity animation) opacity) ;; (:opacity animation) returns the child animation 
           (animated (:offset animation) #(offset %1 0)))))

  ;; Complex animation sequence with curves and relative durations
  (widget
    :managed [animation (motion-controller 
                         vsync
                         (seq
                           ;; Initial state
                           {:opacity 0.0
                            :scale 0.8
                            :offset 0.0}
                           ;; Fade in and scale up with ease-out
                           (par {:dur 400 :curve :ease-out}
                                :opacity (to 1.0 :relative-duration 0.5)
                                :scale 1.0)
                           ;; Wait a bit
                           (wait 200)
                           ;; Slide and bounce
                           (par
                             :offset (-> (to 0.0 20.0 0.0)
                                       (with {:dur 600 :curve :ease-in-out}))
                             ;; Scale effect happens during middle of slide
                             :scale (-> (to 1.0 1.1 1.0)
                                      (with {:dur 300
                                            :rel-delay 0.25
                                            :curve :ease-in-out}))
                           ;; Trigger taptic feedback
                           (action! HapticFeedback.selectionClick)))]                 
    (->> (text \"Animated Title\")
         (animated (:opacity animation) opacity)
         (animated (:scale animation) scale)
         (animated (:offset animation) #(offset 0 %))))

  ;; Sequential animations with relative timing
  (widget
    :managed [animation (motion-controller
                         vsync
                         (seq {:dur 2000}
                           {:step :first
                            :opacity 0.0
                            :scale 0.5
                            :color Colors.blue
                            :rotation 0}
                           ;; Take 40% of total time
                           (par {:rel-dur 0.4 :curve :ease-out}
                                :opacity (to 1.0 :curve :ease-in-out)
                                :scale 1.0)
                           ;; Brief pause (10% of time)
                           (wait :rel-dur 0.1)
                           ;; Rest of animation (50% of time)
                           (par
                             :step (const :last)
                             :color Colors.red
                             :rotation (to 0.0 360.0 :curve :ease-in-out)))]
    (->> (container)
         (animated (:opacity animation) opacity)
         (animated (:scale animation) scale)
         (animated (:color animation) background-color)
         (animated (:rotation animation) rotate)))
  ```"
  ([vsync motion & {:keys [progress debug-label animation-behavior]
                    :or {progress 0.0 animation-behavior a/AnimationBehavior.preserve}}]
   (let [^MotionAnimationController animation-controller (MotionAnimationController
                                                          nil
                                                          (double progress)
                                                          nil
                                                          debug-label
                                                          vsync
                                                          (t/animation-behavior animation-behavior))
         ^MotionController motion-controller (MotionController
                                              {}
                                              (constantly nil)
                                              nil
                                              nil
                                              nil
                                              true
                                              nil
                                              nil
                                              nil
                                              animation-controller)]
     (.-motionController! animation-controller motion-controller)
     (set-motion! motion-controller motion)
     motion-controller)))

(defn instant
  "Instant motion with zero duration.
   ```clojure
   (instant 10.0)
   (instant)
   ```"
  ([]
   (motion
    (fn [_ _] {:duration (t/duration 0)
               :interpolate (fn [value _] value)})
    (constantly "(instant)")))
  ([value]
   (motion
    (fn [_ _] (const-anim value 0))
    (fn [] (str "(instant " value ")")))))

(defn- time-mod [num div]
  (if (zero? num)
    num
    (let [result (mod num div)]
      (if (zero? result) 1.0 result))))

(defn- transform-effect-t [t start end rel-dur]
  (if (zero? rel-dur)
    (cond
      (and (= t 0.0) (= start 0.0)) 0.0
      (= t end) 1.0
      (< end t) dc/double.infinity
      :else (- dc/double.infinity))
    (/ (- t start) rel-dur)))

(defn- -sequential [motions]
  (let [motions (->> motions flat-motions (filter some?) (map motion-to-map))
        clamp #(min 1.0 (max 0.0 %))]
    (motion
     (fn [value exp-dur]
       (let [{:keys [sum-abs sum-rel cnt-any items intr-dur effects-cnt]}
             (reduce
              (fn [res motion]
                (if (some? motion)
                  (let [{:keys [last-value sum-abs sum-rel effects-cnt]} res
                        {:keys [duration relative-duration interpolate side-effects]} ((:prepare-motion motion) last-value nil)
                        next-value (interpolate last-value 1.0)
                        duration (in-mcs duration)
                        relative (when (and (nil? duration) relative-duration) (clamp relative-duration))]
                    {:last-value next-value
                     :sum-abs (if duration (+ duration (or sum-abs 0.0)) sum-abs)
                     :sum-rel (+ sum-rel (or relative 0.0))
                     :cnt-any (+ (:cnt-any res) (if (or duration relative) 0 1))
                     :cnt-abs (+ (:cnt-abs res) (if duration 1 0))
                     :intr-dur (when (and duration relative-duration (< 0 relative-duration)) (/ duration relative-duration))
                     :items (conj (:items res) {:duration duration
                                                :relative-duration relative
                                                :interpolate interpolate
                                                :side-effects side-effects})
                     :effects-cnt (+ effects-cnt (if side-effects 1 0))})
                  res))
              {:last-value value :sum-abs nil :sum-rel 0.0 :cnt-any 0 :cnt-abs 0 :items [] :effects-cnt 0}
              motions)
             rel-k (if (< 1 sum-rel) (/ sum-rel) 1.0)
             sum-rel (clamp sum-rel)
             min-dur (if (and sum-abs sum-rel (< sum-rel 1.0)) (/ sum-abs (- 1.0 sum-rel)) sum-abs)
             exp-dur (in-mcs exp-dur)
             res-dur (let [durs (->>
                                 [exp-dur intr-dur]
                                 (concat (if (< 0 cnt-any) [] [min-dur]))
                                 (filter some?))]
                       (when-not (empty? durs) (apply max durs)))
             any-dur (if (> cnt-any 0)
                       (if (and res-dur min-dur (> res-dur 0))
                         (/ (- (/ (- res-dur min-dur) res-dur) sum-rel) cnt-any)
                         (/ (- 1.0 sum-rel) cnt-any))
                       0.0)
             all-cnt (count items)
             all-items (reduce
                        (fn [res item]
                          (let [{:keys [duration relative-duration]} item
                                relative-duration (when relative-duration (* rel-k relative-duration))
                                t (if (empty? res) 0.0 (:end (last res)))
                                rel-dur (or relative-duration
                                            (when res-dur
                                              (if (< 0 res-dur)
                                                (if duration (/ duration res-dur) any-dur)
                                                (/ all-cnt)))
                                            any-dur)
                                end (+ t rel-dur)]
                            (conj res (assoc item :start t :end end :rel-dur rel-dur))))
                        []
                        items)]
         {:duration (from-mcs res-dur)
          :interpolate (fn [initial T]
                         (reduce
                          (fn [value {:keys [start end rel-dur interpolate]}]
                            (if (and (< 0 rel-dur) (or (<= start T end) (<= T 0)))
                              (let [t (if (zero? rel-dur) 1.0 (/ (- T start) rel-dur))
                                    anim-t (cond->> t
                                             (< end 1) (min 1.0)
                                             (< 0 start) (max 0.0))]
                                (reduced (interpolate value anim-t)))
                              (interpolate value 1.0)))
                          initial
                          all-items))
          :side-effects (when (< 0 effects-cnt)
                          (let [effects
                                (filter
                                 some?
                                 (map
                                  (fn [{:keys [start end rel-dur side-effects]}]
                                    (when side-effects
                                      (let [transform #(transform-effect-t % start end rel-dur)]
                                        #(side-effects (map transform %)))))
                                  all-items))]
                            (fn [range]
                              (apply concat (map #(% range) effects)))))}))
     (fn [] (str "(seq " (str/join " " (map #((:to-string %)) motions)) ")")))))

(defn- -parallel [motions]
  (let [motions (map (fn [[k v]] [k (motion-to-map v)]) motions)]
    (motion
     (fn [value exp-dur]
       (let [value (or value {})
             exp-dur-in-mcs (in-mcs exp-dur)

             {:keys [max-dur items side-effects-cnt]}
             (reduce
              (fn [res [k v]]
                (let [{:keys [duration relative-duration interpolate side-effects]} ((:prepare-motion v) (get value k) exp-dur)
                      {:keys [max-dur items side-effects-cnt]} res
                      dur-abs (or
                               (in-mcs duration)
                               (when (and relative-duration exp-dur-in-mcs) (* exp-dur-in-mcs relative-duration)))
                      max-dur (if dur-abs (max dur-abs (or max-dur 0.0)) max-dur)
                      rel-dur (or
                               relative-duration
                               (when (and dur-abs exp-dur-in-mcs (< 0 exp-dur-in-mcs)) (/ dur-abs exp-dur-in-mcs))
                               1.0)]
                  {:max-dur max-dur
                   :side-effects-cnt (+ side-effects-cnt (if side-effects 1 0))
                   :items (assoc items k {:duration dur-abs :interpolate interpolate :rel-dur rel-dur :side-effects side-effects})}))
              {:max-dur nil :items {} :side-effects-cnt 0}
              motions)
             full-dur (if (and exp-dur-in-mcs max-dur)
                        (max exp-dur-in-mcs max-dur)
                        (or exp-dur-in-mcs max-dur))
             items (if (and full-dur (not= full-dur exp-dur-in-mcs) (< 0 full-dur))
                     (update-vals
                      items
                      (fn [{:keys [duration interpolate side-effects]}]
                        {:interpolate interpolate
                         :rel-dur (if duration (/ duration full-dur) 1.0)
                         :side-effects side-effects}))
                     items)]
         {:duration (some-> (or (from-mcs full-dur) exp-dur) t/duration)
          :interpolate (fn [initial T]
                         (let [from (or initial {})
                               results (map
                                        (fn [[k {:keys [interpolate rel-dur]}]]
                                          (let [transform-t #(cond
                                                               (zero? rel-dur) (if (= % 0.0) 0.0 1.0)
                                                               (= 1.0 rel-dur) %
                                                               :else (min 1.0 (/ % rel-dur)))
                                                t (transform-t T)]
                                            [k (interpolate (get from k) t)]))
                                        items)]
                           (into value results)))
          :side-effects (when (< 0 side-effects-cnt)
                          (let [effects
                                (filter
                                 some?
                                 (map
                                  (fn [[_ {:keys [rel-dur side-effects]}]]
                                    (when side-effects
                                      (let [transform #(transform-effect-t % 0.0 rel-dur rel-dur)]
                                        #(side-effects (map transform %)))))
                                  items))]
                            (fn [range]
                              (apply concat (map #(% range) effects)))))}))
     (fn [] (str "(par " (str/join " " (map (fn [[k v]] (str k " " ((:to-string v)))) motions)) ")")))))

(defn action-with!
  "Action motion that calls a function with the value.
   ```clojure
   (seq
     (to 10.0)
     (action-with! :prn println)) ;; Prints 10.0
   ```
   
   If you need to call a function without the value, you can use `action!`"
  [id action]
  (motion
   (fn [value _]
     {:duration 0
      :interpolate (constantly value)
      :side-effects (fn [[start end]]
                      (if (and (< start 1.0) (<= 1.0 end)) [#(action value)] []))})
   (constantly (str "(action-with! " id ")"))))

(defn action!
  "Action motion that calls a function.
   ```clojure
   (seq
     (to 10.0)
     (action! :tap HapticFeedback.selectionClick)
     (to 20.0))
   ```
   
   If you need to call a function with the value, you can use `action-with!`"
  [id action]
  (motion
   (.-prepare (action-with! id (fn [_] (action))))
   (constantly (str "(action! " id ")"))))

(defn duration
  "Set the duration of the motion.\\
   `duration` takes a duration and an motion and returns a new motion with the provided duration.\\
   The duration is applied to the motion.
   ```clojure
   (duration 100 (to 10.0))
   ```"
  [duration motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value _]
       (let [{:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value duration)
             duration-mcs (in-mcs duration)
             dur-mcs (in-mcs duration)
             max-duration (if (and duration-mcs dur-mcs) (max duration-mcs dur-mcs) (or duration-mcs dur-mcs))
             end (when (and dur-mcs (not= dur-mcs max-duration) (< 0 max-duration)) (/ dur-mcs max-duration))
             curve (when end (curves/interval nil end :linear))]
         {:interpolate (if curve
                         (fn [value t] (interpolate value (.transform curve (double t))))
                         interpolate)
          :relative-duration relative-duration
          :duration (from-mcs max-duration)
          :side-effects (when side-effects
                          (if curve
                            (fn [interval]
                              (side-effects (map #(.transform curve (double %)) interval)))
                            side-effects))}))
     (fn [] (str "(duration " duration " " ((:to-string motion)) ")")))))

(defn curve
  "Set the curve of the motion.\\
   `curve` takes a curve and an motion and returns a new motion with the provided curve.\\
   The curve is applied to the motion.
   ```clojure
   (curve :ease-in-out (to 10.0))
   ```"
  [curve motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value exp-dur]
       (let [{:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value exp-dur)
             curve (t/curve curve)]
         {:interpolate (fn [value t] (interpolate value (.transform curve (double t))))
          :relative-duration relative-duration
          :duration duration
          :side-effects (when side-effects
                          (fn [range]
                            (side-effects (map #(.transform curve (double %)) range))))}))
     (fn [] (str "(curve " curve " " ((:to-string motion)) ")")))))

(defn relative-duration
  "Set the duration of the motion relative to the parent animation.\\
   `relative-duration` takes a ratio and an motion and returns a new motion with the provided relative duration.\\
   The duration is applied to the motion.
   ```clojure
   (relative-duration 0.5 (to 10.0))
   ```"
  [ratio motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value exp-dur]
       (let [{:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value exp-dur)]
         {:interpolate interpolate
          :duration duration
          :relative-duration (if relative-duration (* ratio relative-duration) ratio)
          :side-effects side-effects}))
     (fn [] (str "(relative-duration " ratio " " ((:to-string motion)) ")")))))

(defn relative-delay
  "Set the start time of the motion relative to the duration.\\
   `relative-delay` takes a ratio and an motion and returns a new motion with the provided relative delay.\\
   The delay is applied to the motion.
   ```clojure
   (relative-delay 0.5 (to 10.0))
   ```"
  [delay motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value exp-dur]
       (let [exp-dur-mcs (in-mcs exp-dur)
             delay-mcs (when exp-dur-mcs (* delay exp-dur-mcs))
             dur-mcs (when exp-dur-mcs (* exp-dur-mcs (- 1.0 delay)))
             {:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value (from-mcs dur-mcs))
             dur-mcs (when (and delay-mcs duration) (+ delay-mcs (in-mcs duration)))
             curve (curves/interval delay nil :linear)]
         {:interpolate (fn [value t] (interpolate value (.transform curve (double t))))
          :relative-duration (when relative-duration (+ delay relative-duration))
          :duration (from-mcs dur-mcs)
          :side-effects (when side-effects
                          (fn [interval]
                            (side-effects (map #(.transform curve (double %)) interval))))}))
     (fn [] (str "(relative-delay " delay " " ((:to-string motion)) ")")))))

(defn delay
  "Set the start time of the motion.\\
   `delay` takes a duration and an motion and returns a new motion with the provided delay.\\
   The delay is applied to the motion.
   ```clojure
   (delay 100 (to 10.0))
   ```"
  [delay motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value exp-dur]
       (let [exp-dur-mcs (in-mcs exp-dur)
             delay-mcs (in-mcs delay)
             delay-ratio (when (and exp-dur-mcs (< 0 exp-dur-mcs)) (/ delay-mcs exp-dur-mcs))
             dur-mcs (when exp-dur-mcs (- exp-dur-mcs delay-mcs))
             {:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value (from-mcs dur-mcs))
             dur-mcs (in-mcs duration)
             relative-duration (when (and delay-ratio relative-duration) (+ delay-ratio relative-duration))
             full-dur-mcs (when dur-mcs (+ delay-mcs dur-mcs))
             start (when full-dur-mcs (/ delay-mcs full-dur-mcs))
             end (if (and start dur-mcs full-dur-mcs (< 0 full-dur-mcs))
                   (+ start (/ dur-mcs full-dur-mcs))
                   1.0)
             curve (when start (curves/interval start end :linear))]
         {:interpolate (if curve
                         (fn [value t] (interpolate value (.transform curve (double t))))
                         interpolate)
          :relative-duration relative-duration
          :duration (from-mcs full-dur-mcs)
          :side-effects (when side-effects
                          (if curve
                            (fn [interval]
                              (side-effects (map #(.transform curve (double %)) interval)))
                            side-effects))}))
     (fn [] (str "(delay " delay " " ((:to-string motion)) ")")))))

(defn with
  "Add options to an animation.\\
   `with` takes a map or key value pairs of options and an motion and returns a new motion with the provided options.\\
   The options are merged with the existing options of the animation.\\
   Options:
    - `:duration` or `:dur` - Duration of the motion in milliseconds, or Duration object or map.
    - `:delay` - Start time of the motion in milliseconds or Duration object or map.
    - `:relative-duration` or `:rel-dur` - Duration of the motion relative to the parent animation.
    - `:relative-delay` or `:rel-delay` - Start time ratio of the motion relative to the duration.
    - `:curve` - Curve of the animation.
   
   ```clojure
   (with {:duration 100} w/Colors.blue)
   (with :dur 100 :curve :ease-in-out w/Colors.blue)
   (with :duration 100 (to 10.0))
   ```"
  ([k v & kvs-motion]
   (let [{:keys [options] [motion] :items} (separate-options (concat [k v] kvs-motion))]
     (with options motion)))
  ([options motion]
   (let [{:keys [relative-delay delay relative-duration duration curve]} (motion-options options)]
     (cond->> motion
       curve (flutter-cljd.animations/curve curve)
       duration (flutter-cljd.animations/duration duration)
       relative-duration (flutter-cljd.animations/relative-duration relative-duration)
       delay (flutter-cljd.animations/delay delay)
       relative-delay (flutter-cljd.animations/relative-delay relative-delay)))))

(defn const
  "Creates a motion that steps through constant values.\\
   Takes one or more values and returns a motion that changes discretely between them.\\
   If only one value is provided, creates a constant motion with that value.\\
   Can accept animation options map or key-value pairs after values.\\
   The duration is divided evenly between the values.
   ```clojure
   (const 10.0)  ;; Stays at 10.0
   (const 0 50 100)  ;; Steps from 0 to 50 to 100
   (const 0 100 :dur 2000)  ;; Steps over 1 second
   ```"
  [value & values]
  (let [{:keys [options items]} (separate-last-options (cons value values))
        items (if (fn? (first items)) (map (first items) (rest items)) items)
        prepare (fn [value exp-dur]
                  (let [cnt (count items)
                        last-i (- cnt 1)]
                    (case cnt
                      0 (const-anim value exp-dur)
                      1 (const-anim (last items) exp-dur)
                      {:duration exp-dur
                       :interpolate (fn [_ T]
                                      (let [i (min last-i (int (* T cnt)))]
                                        (nth items i)))})))
        result  (motion
                 prepare
                 (fn [] (str "(const " (str/join " " items) ")")))]
    (if (empty? options) result (with options result))))

(defn to
  "Animate to a value.\\
   `to` takes a value and returns an motion that animates from the current value to the provided values eventually.\\
   If the current value is nil, the first value is used as the initial value.

   ```clojure
   (to 5.0 10.0)
   (to 5.0 10.0 5.0 1.0 10.0)
   (to 10.0 :dur 100)
   (to Colors.blue Colors.red Colors.green {:delay 10})
   ```

   `to` can accept a transform function as the first argument to map the values.
   ```clojure
   (to t/color :red :blue :green) ;; equivalent to (apply to (map t/color [:red :blue :green]))
   ```

   Also, `to` can take key-value pairs or a map of options after the values:
    - `:duration` or `:dur` - Duration of the motion in milliseconds, or Duration object or map.
    - `:delay` - Start time of the motion in milliseconds or Duration object or map.
    - `:relative-duration` or `:rel-dur` - Duration of the motion relative to the parent animation.
    - `:relative-delay` or `:rel-delay` - Start time ratio of the motion relative to the duration.
    - `:curve` - Curve of the animation.
    - `:lerp` - Interpolation function that takes two values and returns a new value."
  [value & values]
  (let [{:keys [options items]} (separate-last-options (cons value values))
        values (if (fn? (first items)) (map (first items) (rest items)) items)
        lerp (:lerp options #(ut/lerp %1 %2))
        options (assoc options :lerp nil)
        prepare (fn [from exp-dur]
                  {:interpolate
                   (fn [initial T]
                     (let [values (if (some? initial) (cons initial values) values)
                           int-cnt (dec (count values))]
                       (condp = T
                         0.0 (first values)
                         1.0 (last values)
                         (let [k (* T int-cnt)
                               i (int k)
                               t (- k i)]
                           (if (< i int-cnt)
                             ((lerp (nth values i) (nth values (inc i))) t)
                             (last values))))))
                   :duration (if (< (+ (if (nil? from) 0 1) (count values)) 2)
                               (t/duration 0)
                               exp-dur)})
        result (motion
                prepare
                (fn [] (str "(to " (str/join " " (if (fn? (first items)) (rest items) items)) ")")))]
    (if (empty? options)
      result
      (with options result))))

(defn from
  "Set the initial value of the motion.\\
   `from` takes a value and an motion and returns a new motion with the provided initial value.\\
   The initial value is applied to the motion.
   ```clojure
   (from 10.0 (to 20.0))
   ```"
  [from motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [_ exp-dur]
       (let [{:keys [duration interpolate side-effects]} ((:prepare-motion motion) from exp-dur)]
         {:duration duration
          :interpolate (fn [_ T] (interpolate from T))
          :side-effects side-effects}))
     (fn [] (str "(from " from " " ((:to-string motion)) ")")))))

(defn from-to
  "Animate from an initial value to final values. It's a shorthand for `(from value (to values))`.\\
   `from-to` takes an initial value and final values and returns a new motion that animates between them.\\
   Can accept animation options map or key-value pairs after the values.
   ```clojure
   (from-to 0 100)
   (from-to 0 100 :dur 1000)
   ```"
  [value0 value1 & values]
  (if (fn? value0)
    (from value1 (apply to (cons value0 values)))
    (from value0 (apply to (cons value1 values)))))

(defn wait
  "Do nothing for a given duration. Duration is optional.
   ```clojure
   (wait 100)
   ```
   To wait relative to the parent motion wrap the `wait` in `with`:
   ```clojure
   (wait :relative-duration 0.2)
   ```
   Can be used to fill the time between motions:
   ```clojure
   (seq {:duration 600}
     (with {:duration 100} w/Colors.blue)
     (wait) ;; Wait for 400ms
     (with {:duration 100} w/Colors.red))
   ```"
  ([& {:keys [duration dur relative-duration rel-dur delay relative-delay rel-del] :as options}]
   (let [result
         (motion
          (fn [_ exp-dur] {:duration exp-dur
                           :interpolate (fn [value _] value)})
          (constantly "(wait)"))]
     (if (empty? options) result (with options result))))
  ([duration & {:keys [relative-duration rel-dur delay relative-delay rel-del] :as options}]
   (let [result
         (motion
          (fn [_ _] {:duration (t/duration duration)
                     :interpolate (fn [value _] value)})
          (fn [] (str "(wait " duration ")")))]
     (if (empty? options) result (with options result)))))

(defn seq
  "Sequential motions of the value.\\
   `seq` takes a list of motions and applies them one after the other.
   
   If `seq` has a duration, the duration is partitioned between the motions according to their options or evenly if not provided.\\
   If `seq` has a curve, the curve is partitioned between the motions and merged with the motion's curve if provided.\\
   `seq` can accept key-value pairs or a map of options before the motions.
   ```clojure
   (seq
     (with {:duration 50} w/Colors.blue)
     (with {:duration 100} w/Colors.red))
  
   (seq {:duration 200 :curve :ease-in-out}
     (par :color (with {:duration 50} w/Colors.blue)
          :offset (with {:duration 100} 10.0))
     (par :color (with {:duration 50} w/Colors.red)))
   
    (seq :duration 200 :delay 10
      (to w/Colors.blue :relative-duration 0.7)
      w/Colors.red)
   ```
   
   If you need to animate evenly spaced values, you can use `to` instead."
  [& motions]
  (let [{:keys [options items]} (separate-options motions)]
    (if-not (empty? options)
      (with options (-sequential items))
      (-sequential items))))

(defn par
  "Parallel motions of multiple properties of the value.\\
   `par` takes a list of key-value pairs, where the key is the property to animate and the value is the animation.\\
   It's useful when you want to animate multiple properties with different motions at the same time.\\
   If `par` has a duration, the duration is applied to all animations.\\
   If `par` has a curve, the curve is applied to all animations.
   ```clojure
   (par
      :color (to w/Colors.blue :duration 50)
      :offset (to 10.0 :duration 100))
   ```
   It's possible to nest `par` calls to animate nested properties:
   ```clojure
   (par :offset (par :dx (with {:duration 100} 10.0)))
   ```
   
   `par` can accept a map of options as the first argument:
   ```clojure
   (par {:duration 200 :curve :ease-in-out}
     :color (to w/Colors.blue)
     :offset (to 10.0 :duration 100))
   ```"
  [& kvs]
  (if (odd? (count kvs))
    (if (is-options? (first kvs))
      (with (first kvs) (-parallel (partition 2 (drop 1 kvs))))
      (throw (ex-info "Invalid arguments in par" {:args kvs})))
    (-parallel (partition 2 kvs))))

(defn repeat
  "Repeats a motion a specified number of times.\\
   Takes a count and a motion, returns a new motion that repeats the input animation.\\
   The total duration will be the motion's duration multiplied by the count.\\
   If count is 0 or negative, returns an instant animation.\\
   If count is 1, returns the original motion unchanged.
   ```clojure
   (repeat 3 (to 0 100))  ;; Goes 0 -> 100 three times
   ```"
  ([cnt motion]
   (let [motion (motion-to-map motion)]
     (flutter-cljd.animations/motion
      (cond
        (<= cnt 0) (.-prepare (instant))
        (= cnt 1) (:prepare-motion motion)
        :else
        (fn [value exp-dur]
          (let [relative-duration (/ cnt)
                loop-dur (when exp-dur {:microseconds (* (in-mcs exp-dur) relative-duration)})
                {:keys [duration interpolate side-effects]} ((:prepare-motion motion) value loop-dur)
                transform #(if (= % 1.0) 1.0 (mod (* % cnt) 1.0))]
            {:interpolate #(interpolate %1 (transform %2))
             :duration (some-> (or (when duration {:microseconds (* (in-mcs duration) cnt)}) exp-dur) t/duration)
             :side-effects (when side-effects
                             (fn [[start end]]
                               (let [dur (- end start)]
                                 (if (<= relative-duration dur)
                                   (side-effects [0.0 1.0])
                                   (let [[x y] (map #(int (/ % cnt)) [start end])
                                         s (transform start)
                                         e (transform end)
                                         ranges (if (= x y) [[s e]] [[s 1.0] [0.0 e]])]
                                     (apply concat (map side-effects ranges)))))))})))
      (fn [] (str "(repeat " cnt " " ((:to-string motion)) ")"))))))

(defn autoreverse
  "Creates a motion that plays forward then reverses.\\
   Takes a motion and returns a new motion that plays the input animation\\
   forward then plays it in reverse.\\
   The total duration will be double the original motion's duration.
   ```clojure
   (autoreverse (to 0 100))  ;; Goes 0 -> 100 -> 0
   ```"
  ([motion]
   (let [motion (motion-to-map motion)]
     (flutter-cljd.animations/motion
      (fn [value exp-dur]
        (let [loop-dur (when exp-dur {:microseconds (/ (in-mcs exp-dur) 2)})
              {:keys [duration interpolate side-effects]} ((:prepare-motion motion) value loop-dur)
              transform #(* (if (<= % 0.5) % (- 1.0 %)) 2)]
          {:interpolate
           (fn [value T]
             (let [t (transform T)]
               (interpolate value t)))
           :duration (some-> (or (when duration {:microseconds (* (in-mcs duration) 2)}) exp-dur) t/duration)
           :side-effects (when side-effects
                           (fn [[start end]]
                             (let [s (transform start)
                                   e (transform end)
                                   ranges
                                   (if (or (<= end 0.5) (<= 0.5 start))
                                     [[(min s e) (max s e)]]
                                     [[s 1.0] [e 1.0]])]
                               (apply concat (map #(side-effects %) ranges)))))}))
      (fn [] (str "(autoreverse " ((:to-string motion)) ")"))))))

(defn synced
  "Creates a motion that syncs with the current time.\\
  Takes a motion and returns a new motion that syncs the input animation with the current time.\\
  The total duration will be the original motion's duration.
  ```clojure
  ;; Loader widget that is synced with the current time, so all loaders will be in sync.
  (widget
   :vsync vsync
   :managed [rotation-cntr (motion-controller
                              vsync
                              (synced (to 0.0 (* 2 π) :dur 1000)))]
   (->> (image \"loader.png\")
        (animated rotation-cntr rotated)
        (center)
        (on-appear #(.repeat rotation-cntr))))
  ```"
  [motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value exp-dur]
       (let [{:keys [duration interpolate side-effects]} ((:prepare-motion motion) value exp-dur)
             dur-ms (when duration (.-inMilliseconds (t/duration duration)))
             transform (fn [_] (/ (mod (.-millisecondsSinceEpoch (dc/DateTime.now)) dur-ms) dur-ms))]
         {:interpolate (if (and dur-ms (< 0 dur-ms))
                         (fn [value t] (interpolate value (transform t)))
                         interpolate)
          :duration duration
          :side-effects (when side-effects
                          (if dur-ms
                            (fn [range] (side-effects (map transform range)))
                            side-effects))}))
     (fn [] (str "(synced " ((:to-string motion)) ")")))))

(defn tile
  "Creates a motion that tiles/repeats within the parent duration.
   
   Takes a motion and returns a new motion that repeats the input animation to fill
   the parent duration. Unlike `repeat`, which multiplies the duration, `tile` fits
   the original motion into the parent duration as many times as possible.
   
   The total duration will match the parent duration, with the original motion repeating
   within that timeframe.
   
   ```clojure
   ;; Create a 2-second animation containing a repeating 500ms motion
   (seq {:duration 2000}
     (tile (to 0 100 :duration 500)))  ;; Repeats 0->100 four times
   
   ;; Useful for continuous animations like rotation or color cycling
   (widget
     :managed [controller (motion-controller 
                           vsync 
                           (seq {:duration 5000}
                             (tile (to 0 360 :duration 1000))))]
     (->> (image \"spinner.png\")
          (animated controller rotate)
          (on-appear #(.repeat controller))))
   ```
   
   See also:
   - `repeat` - Repeats a motion a specific number of times
   - `synced` - Syncs a motion with the current time"
  [motion]
  (let [motion (motion-to-map motion)]
    (flutter-cljd.animations/motion
     (fn [value exp-dur]
       (let [{:keys [duration interpolate side-effects]} ((:prepare-motion motion) value exp-dur)
             dur-mcs (in-mcs duration)
             exp-dur-mcs (in-mcs exp-dur)
             ratio (when (and exp-dur-mcs (< 0 exp-dur-mcs)) (/ dur-mcs exp-dur-mcs))
             transform (if ratio #(time-mod % ratio) identity)]
         {:interpolate (if ratio
                         (fn [value t] (interpolate value (transform t)))
                         interpolate)
          :duration (or exp-dur duration)
          :side-effects (when side-effects
                          (fn [range]
                            (side-effects (map transform range))))}))
     (fn [] (str "(tile " ((:to-string motion)) ")")))))
