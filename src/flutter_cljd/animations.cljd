(ns flutter-cljd.animations
  (:require
   [cljd.core :as c]
   [cljd.set :refer [superset?]]
   [flutter-cljd.types :as t]
   [flutter-cljd.curves :as curves]
   ["package:flutter/widgets.dart" :as w]
   ["package:flutter/animation.dart" :as a]
   ["package:flutter/scheduler.dart" :as sc]
   ["dart:core" :as dc]
   [flutter-cljd.utils :as ut]
   [cljd.string :as str]))

(extend-protocol c/IFn
  a/Curve
  (-invoke [this t]
    (.transform this t))

  a/Animatable
  (-invoke [this t]
    (.transform this t)))

(deftype TransformedAnimation
         [^a/Animation parent transform]
  :extends a/Animation
  (value [this] ((.-transform this) (-> this .-parent .-value)))
  ^:mixin a/AnimationWithParentMixin)

(extend-protocol c/ILookup
  a/Animation
  (-lookup [this key] (c/-lookup this key nil))
  (-lookup [this key not-found]
    (TransformedAnimation this (fn [value] (c/-lookup value key not-found))))
  (-contains-key? [this key]
    (c/-contains-key? (.-value this) key)))

(defn- set-value [this new-value]
  (let [old-value (-> this .-tween .-end)
        tween (.-tween this)
        controller (.-controller this)]
    (when-not (= new-value old-value)
      (.-begin! tween (.evaluate tween this))
      (.-end! tween new-value)
      (if-not (.-isAnimating controller)
        (.forward controller .from 0.0)
        (let [progress (.-value controller)]
          (.forward controller .from 0.0)
          (.-value! controller progress)))
      nil)))

(defn- get-state [this]
  (-> this .-tween .-end))

(deftype AnimatedValue
         [tween
          ^a/AnimationController controller
          ^a/Animation parent]
  :extends (a/Animation)
  (value [this]
    (-> this .-tween (.lerp (-> this .-controller .-value))))
  c/IEquiv
  (-equiv [o other] (identical? o other))
  c/IDeref
  (-deref [this] (get-state this))
  c/ISwap
  (-swap! [this f] (set-value this (f (get-state this))))
  (-swap! [this f a] (set-value this (f (get-state this) a)))
  (-swap! [this f a b] (set-value this (f (get-state this) a b)))
  (-swap! [this f a b xs] (set-value this (apply f (get-state this) a b xs)))
  c/IReset
  (-reset! [this new-value] (set-value this new-value))
  ^:mixin a/AnimationWithParentMixin)

(defn ^AnimatedValue animated-value
  ([initial-value vsync] (animated-value initial-value vsync {}))
  ([initial-value vsync options]
   (let [options (t/animation-options options)
         controller (a/AnimationController
                     .vsync vsync
                     .duration (:duration options))]
     (AnimatedValue
      (t/tween (:lerp options) initial-value initial-value)
      controller
      (a/CurvedAnimation
       .parent controller
       .curve (:curve options a/Curves.linear)
       .reverseCurve (some-> options :reverse-curve t/curve))))))

;; (defprotocol Controller
;;   (dispose [this])
;;   (^sc/TickerFuture animateBack [this target {:keys [duration curve] :or {curve :linear}}])
;;   (^sc/TickerFuture animateTo [this target {:keys [duration curve] :or {curve :linear}}])
;;   (^sc/TickerFuture forward [this {:keys [from] :or {from nil}}])
;;   (^sc/TickerFuture repeat [this {:keys [min max reverse period count] :or {reverse false}}])
;;   (reset [this])
;;   (resync [this vsync])
;;   (^sc/TickerFuture reverse [this {:keys [from] :or {from nil}}])
;;   (stop [this {:keys [canceled] :or {canceled true}}])
;;   (^sc/TickerFuture toggle [this {:keys [from] :or {from nil}}]))

;; (extend-protocol Controller
;;   a/AnimationController)

(defn- set-cached-value [this]
  (.-cached-value! this ((.-interpolate this) (-> this .-controller .-value) (-> this .-cache))))

(defn- reset-cached-value [this]
  (.-cached-value! this nil))

(deftype MotionController
         [^:mutable motion
          ^:mutable interpolate
          ^:mutable cache
          ^:mutable cached-value
          ^a/AnimationController parent]
  :extends (a/Animation)
  (value [^MotionController this]
    (if (or (.-isAnimating this) (nil? (.-cached-value this)))
      ((.-interpolate this) (-> this .-controller .-value) (-> this .-cache))
      (.-cached-value this)))
  dc/Object
  (toString [^MotionController this]
    ((-> this .-motion :to-string)))
  c/IEquiv
  (-equiv [o other] (identical? o other))
  (progress [^MotionController this]
    (-> this .-controller .-value))
  (^:setter progress [^MotionController this new-value]
    (.-value! (-> this .-controller) (double new-value))
    nil)
  (dispose [^MotionController this]
    (.dispose (.-parent this))
    (reset-cached-value this))
  (^sc/TickerFuture animateBack [^MotionController this target & {:keys [duration curve] :or {curve a/Curves.linear}}]
    (reset-cached-value this)
    (.animateBack (.-parent this) (double target) .duration (some-> duration t/duration) .curve (t/curve curve)))
  (^sc/TickerFuture animateTo [^MotionController this target & {:keys [duration curve] :or {curve a/Curves.linear}}]
    (reset-cached-value this)
    (.animateTo (.-parent this) (double target) .duration (some-> duration t/duration) .curve (t/curve curve)))
  (^sc/TickerFuture forward [^MotionController this & {:keys [from] :or {from nil}}]
    (reset-cached-value this)
    (.forward (.-parent this) .from (some-> from double)))
  (^sc/TickerFuture repeat [^MotionController this & {:keys [min max reverse period count] :or {reverse false}}]
    (reset-cached-value this)
    (.repeat (.-parent this)
             .min (some-> min double)
             .max (some-> max double)
             .reverse (boolean reverse)
             .period (some-> period t/duration)
             .count (some-> count int)))
  (reset [^MotionController this]
    (.reset (.-parent this))
    (set-cached-value this))
  (resync [^MotionController this vsync]
    (.resync (.-parent this) vsync)
    (set-cached-value this))
  (^sc/TickerFuture reverse [^MotionController this & {:keys [from] :or {from nil}}]
    (reset-cached-value this)
    (.reverse (.-parent this) .from (some-> from double)))
  (stop [^MotionController this & {:keys [canceled] :or {canceled true}}]
    (.stop (.-parent this) .canceled (boolean canceled))
    (set-cached-value this))
  (^sc/TickerFuture toggle [^MotionController this & {:keys [from] :or {from nil}}]
    (reset-cached-value this)
    (.toggle (.-parent this) .from (some-> from double)))
  ^:mixin a/AnimationWithParentMixin)

(defn- in-mcs [duration]
  (some-> duration t/duration .-inMicroseconds double))

(defn- from-mcs [mcs]
  (when mcs (t/duration {:microseconds mcs})))

(def ^:private options-keys #{:duration :dur :rel-dur :rel-delay :curve :lerp :relative-duration :delay :relative-delay})

(defn- is-options? [x]
  (and
   (map? x)
   (superset? options-keys (set (keys x)))))

(defn- motion-options [value]
  {:duration (:duration value (:dur value))
   :delay (:delay value)
   :relative-delay (:relative-delay value (:rel-delay value))
   :relative-duration (:relative-duration value (:rel-dur value))
   :curve (:curve value)
   :lerp (:lerp value)})

(defn- const-anim
  ([value]
   (fn [_ cache] {:value value :cache cache}))
  ([value duration]
   {:interpolate (const-anim value)
    :duration duration}))

(defn- no-cache-anim
  ([transform] (fn [t cache] {:value (transform t) :cache cache}))
  ([transform duration]
   {:interpolate (no-cache-anim transform)
    :duration duration}))

(defn- flat-motions [motions]
  (->> motions
       (mapcat
        #(if (sequential? %) (flat-motions %) [%]))))

(defn- is-forward? [t prev-t]
  (or (nil? prev-t) (when prev-t (< prev-t t)) (= prev-t t 0.0)))

(defn- separate-options [args]
  (if (is-options? (first args))
    {:options (first args) :items (drop 1 args)}
    (reduce
     (fn [res arg]
       (let [{:keys [key options items finished]} res]
         (if (not finished)
           (if (nil? key)
             (if (and (keyword? arg) (options-keys arg))
               (assoc res :key arg)
               (assoc res :items (conj items arg) :finished true))
             (assoc res :key nil :options (assoc options key arg)))
           (assoc res :items (conj items arg)))))
     {:options {} :items []}
     args)))

(defn- separate-last-options [args]
  (if (is-options? (last args))
    {:options (last args) :items (drop-last 1 args)}
    (reduce
     (fn [res arg]
       (let [{:keys [options items]} res]
         (if (and (= (count items) 1) (keyword? arg) (options-keys arg))
           {:items [] :options (assoc options arg (first items))}
           {:items (cons arg items) :options options})))
     {:options {} :items []}
     (reverse args))))

(defn values
  "Animate values. Same as (to) but doesn't accept animation options.\\
   Use it when you want to be sure that provided values will not be interpreted as animation options.\\
   `values` takes values and returns a motion that animates from the current value to the provided values.\\
   If the current value is nil, the first value is used as the initial value.
   ```clojure
   (values 5.0 10.0)
   ```"
  [& values]
  {:prepare-motion
   (fn [from exp-dur]
     (let [values (if (some? from) (concat [from] values) values)
           int-cnt (dec (count values))
           lerp #(ut/lerp %1 %2)]
       {:interpolate (case int-cnt
                       0 (const-anim (first values))
                       1 (no-cache-anim (lerp (first values) (second values)))
                       (no-cache-anim
                        (fn [T]
                          (condp = T
                            0.0 (first values)
                            1.0 (last values)
                            (let [k (* T int-cnt)
                                  i (int k)
                                  t (- k i)]
                              (if (< i int-cnt)
                                ((lerp (nth values i) (nth values (inc i))) t)
                                (last values)))))))
        :duration (if (zero? int-cnt) (t/duration 0) exp-dur)}))
   :to-string
   (fn [] (str "(values " (str/join " " values) ")"))})

(defn into-motion
  "Converts a value to a motion.\\
   A motion is a map with the following keys:
    - `:prepare-motion` - A function that takes the current value and the duration and returns a map with the following keys:
        - `:interpolate` - A function that takes the progress and the cache and returns the value and the cache.
        - `:duration` - Duration of the motion.
    - `:to-string` - A function that returns a string representation of the motion.
   
   `into-motion` takes a value and returns an motion that animates to the provided value.\\
   If the value is a function, it's used as the prepare-motion function.\\
   If the value is an instance of `Animatable`, it's used as the animation.\\
   If the value is nil, returns nil.
   If the value is a map with the keys `:prepare-motion` and `:to-string`, returns the value as is.
   Otherwise, returns the value wrapped in a `to` motion.
   ```clojure
   (into-motion 10.0)
   (into-motion (fn [t] (* 10 t)))
   (into-motion Colors.blue)
   (into-motion nil)
   ```"
  ([motion to-string]
   (when motion
     (assoc (into-motion motion) :to-string to-string)))
  ([motion]
   (cond
     (and (map? motion) (superset? #{:prepare-motion :to-string} (set (keys motion))))
     motion

     (fn? motion)
     {:prepare-motion motion :to-string (constantly "motion")}

     (instance? w/Animatable motion)
     {:prepare-motion (fn [_ duration]
                        (no-cache-anim #(.transform motion %) duration))
      :to-string #(.toString motion)}

     (nil? motion)
     nil

     :else
     (values motion))))

(defn motion-controller
  ([motion]
   (let [{:keys [prepare-motion] :as motion} (into-motion motion)
         {:keys [duration interpolate]} (prepare-motion nil nil)
         {:keys [duration]} (t/animation-options {:duration duration})]
     (MotionController
      motion
      interpolate
      {}
      (interpolate 0 {})
      (a/AnimationController
       .duration duration)))))


(defn instant
  "Instant motion with zero duration.
   ```clojure
   (instant 10.0)
   (instant)
   ```"
  ([]
   (into-motion
    (fn [value _] (const-anim value 0))
    (constantly "(instant)")))
  ([value]
   (into-motion
    (fn [_ _] (const-anim value 0))
    (fn [] (str "(instant " value ")")))))

(defn- -sequential [motions]
  (let [motions (->> motions flat-motions (filter some?) (map into-motion))
        clamp #(min 1.0 (max 0.0 %))]
    (into-motion
     (fn [value exp-dur]
       (let [{:keys [sum-abs sum-rel cnt-any items intr-dur]}
             (reduce
              (fn [res motion]
                (if (some? motion)
                  (let [{:keys [value sum-abs sum-rel]} res
                        {:keys [duration relative-duration interpolate]} ((:prepare-motion motion) value nil)
                        next-value (:value (interpolate 1.0 {}))
                        duration (in-mcs duration)
                        relative (when (and (nil? duration) relative-duration) (clamp relative-duration))]
                    {:value next-value
                     :sum-abs (if duration (+ duration (or sum-abs 0.0)) sum-abs)
                     :sum-rel (+ sum-rel (or relative 0.0))
                     :cnt-any (+ (:cnt-any res) (if (or duration relative) 0 1))
                     :cnt-abs (+ (:cnt-abs res) (if duration 1 0))
                     :intr-dur (when (and duration relative-duration (< 0 relative-duration)) (/ duration relative-duration))
                     :items (conj (:items res) {:duration duration :relative-duration relative :interpolate interpolate})})
                  res))
              {:value value :sum-abs nil :sum-rel 0.0 :cnt-any 0 :cnt-abs 0 :items []}
              motions)
             rel-k (if (< 1 sum-rel) (/ sum-rel) 1.0)
             sum-rel (clamp sum-rel)
             min-dur (if (and sum-abs sum-rel (< sum-rel 1.0)) (/ sum-abs (- 1.0 sum-rel)) sum-abs)
             exp-dur (in-mcs exp-dur)
             res-dur (let [durs (->>
                                 [exp-dur intr-dur]
                                 (concat (if (< 0 cnt-any) [] [min-dur]))
                                 (filter some?))]
                       (when-not (empty? durs) (apply max durs)))
             any-dur (if (> cnt-any 0)
                       (if (and res-dur min-dur (> res-dur 0))
                         (/ (- (/ (- res-dur min-dur) res-dur) sum-rel) cnt-any)
                         (/ (- 1.0 sum-rel) cnt-any))
                       0.0)
             final-items (reduce
                          (fn [res item]
                            (let [{:keys [duration relative-duration]} item
                                  relative-duration (when relative-duration (* rel-k relative-duration))
                                  t (if (empty? res) 0.0 (:end (last res)))
                                  rel-dur (or relative-duration
                                              (when res-dur
                                                (if (< 0 res-dur)
                                                  (if duration (/ duration res-dur) any-dur)
                                                  1.0))
                                              any-dur)
                                  end (+ t rel-dur)]
                              (conj res (assoc item :start t :end end :rel-dur rel-dur))))
                          []
                          items)
             cnt (count final-items)]
         {:duration (from-mcs res-dur)
          :interpolate (case cnt
                         0 (const-anim value)
                         1 (:interpolate (first final-items))
                         (fn [t cache]
                           (let [items-cache (:items cache {})
                                 prev-t (:prev-t cache)
                                 is-forward? (is-forward? t prev-t)
                                 start-key (if is-forward? :start :end)
                                 end-key (if is-forward? :end :start)
                                 start-point (if is-forward? 0.0 1.0)
                                 end-point (if is-forward? 1.0 0.0)
                                 strict-compare (if is-forward? < >)
                                 soft-compare (if is-forward? <= >=)
                                 last-i (- cnt 1)
                                 clamp-start #(if is-forward? (max 0.0 %) (min 1.0 %))
                                 clamp-end #(if is-forward? (min 1.0 %) (max 0.0 %))
                                 is-last? #(if is-forward? (= last-i %) (= 0 %))
                                 is-first? #(if is-forward? (= 0 %) (= last-i %))
                                 filtered (->> final-items
                                               (map-indexed (fn [i item] [i item]))
                                               (filter #(let [[i item] %
                                                              rel-dur (:rel-dur item)
                                                              start (start-key item)
                                                              end (end-key item)]
                                                          (and (not (and prev-t (strict-compare end prev-t)))
                                                               (or (and (soft-compare start t) (strict-compare t end))
                                                                   (and (zero? rel-dur) prev-t (soft-compare prev-t start end t))
                                                                   (and (is-first? i) (soft-compare t start))
                                                                   (and (is-last? i) (soft-compare end t)))))))
                                 items (map (fn [[i {:keys [rel-dur interpolate] :as item}]]
                                              (let [start (start-key item)
                                                    end (end-key item)
                                                    transform-t #(if (zero? rel-dur) end-point (/ (- % (:start item)) rel-dur))
                                                    clamped-t #(cond
                                                                 (is-first? i) (clamp-end (transform-t %))
                                                                 (is-last? i) (clamp-start (transform-t %))
                                                                 :else (clamp (transform-t %)))
                                                    anim-t (clamped-t t)
                                                    prev-anim-t (when prev-t (clamped-t prev-t))
                                                    item-cache-fn #(merge
                                                                    (assoc cache :items nil)
                                                                    (get items-cache i {})
                                                                    {:prev-t %})
                                                    value-fn #(interpolate %1 %2)
                                                    prev-t (or prev-t start)
                                                    value (cond
                                                            (and (soft-compare prev-t start end) (strict-compare end t))
                                                            (value-fn end-point (item-cache-fn start-point))

                                                            (soft-compare start prev-t end t)
                                                            (value-fn end-point (item-cache-fn prev-anim-t))

                                                            :else
                                                            (value-fn anim-t (item-cache-fn prev-anim-t)))]
                                                [i value]))
                                            (if is-forward? filtered (reverse filtered)))
                                 new-value (some-> items last last :value)
                                 new-items-cache (into items-cache (map (fn [[i {:keys [cache]}]] [i cache]) items))]
                             {:value (if (empty? items) value new-value)
                              :cache (assoc cache :items new-items-cache)})))}))
     (fn [] (str "(seq " (str/join " " (map #((:to-string %)) motions)) ")")))))

(defn- -parallel [motions]
  (let [motions (map (fn [[k v]] [k (into-motion v)]) motions)]
    (into-motion
     (fn [value exp-dur]
       (let [value (or value {})
             exp-dur-in-mcs (in-mcs exp-dur)

             {:keys [max-dur items]}
             (reduce
              (fn [res [k v]]
                (let [{:keys [duration relative-duration interpolate]} ((:prepare-motion v) (get value k) exp-dur)
                      {:keys [max-dur items]} res
                      dur-abs (or
                               (in-mcs duration)
                               (when (and relative-duration exp-dur-in-mcs) (* exp-dur-in-mcs relative-duration)))
                      max-dur (if dur-abs (max dur-abs (or max-dur 0.0)) max-dur)
                      rel-dur (or
                               relative-duration
                               (when (and dur-abs exp-dur-in-mcs (< 0 exp-dur-in-mcs)) (/ dur-abs exp-dur-in-mcs))
                               1.0)]
                  {:max-dur max-dur
                   :items (assoc items k {:duration dur-abs :interpolate interpolate :rel-dur rel-dur})}))
              {:max-dur nil :items {}}
              motions)
             full-dur (if (and exp-dur-in-mcs max-dur)
                        (max exp-dur-in-mcs max-dur)
                        (or exp-dur-in-mcs max-dur))
             items (if (and full-dur (not= full-dur exp-dur-in-mcs) (< 0 full-dur))
                     (update-vals
                      items
                      (fn [{:keys [duration interpolate]}]
                        {:interpolate interpolate
                         :rel-dur (if duration (/ duration full-dur) 1.0)}))
                     items)]
         {:duration (some-> (or (from-mcs full-dur) exp-dur) t/duration)
          :interpolate (fn [T cache]
                         (let [prev-T (:prev-t cache)
                               items-cache (:items cache {})
                               results (map
                                        (fn [[k {:keys [interpolate rel-dur]}]]
                                          (let [transform-t #(cond
                                                               (zero? rel-dur) (if (= % 0.0) 0.0 1.0)
                                                               (= 1.0 rel-dur) %
                                                               :else (min 1.0 (/ % rel-dur)))
                                                t (transform-t T)
                                                prev-t (transform-t prev-T)]
                                            [k (interpolate
                                                t
                                                (merge
                                                 (assoc cache :items nil)
                                                 (get items-cache k {})
                                                 {:prev-t prev-t}))]))
                                        items)
                               new-value (into value (map (fn [[k {:keys [value]}]] [k value]) results))
                               new-items-cache (into items-cache (map (fn [[k {:keys [cache]}]] [k cache]) results))]
                           {:value new-value
                            :cache (assoc cache :items new-items-cache)}))}))
     (fn [] (str "(par " (str/join " " (map (fn [[k v]] (str k " " ((:to-string v)))) motions)) ")")))))

(defn action-with!
  "Action motion that calls a function with the value.
   ```clojure
   (seq
     (to 10.0)
     (action-with! println)) ;; Prints 10.0
   ```
   
   If you need to call a function without the value, you can use `action!`"
  [action]
  (into-motion
   (fn [value _]
     {:duration 0
      :interpolate (fn [t {:keys [prev-t] :as cache}]
                     (when (and prev-t (or (and (< prev-t 1.0) (<= 1.0 t)) (and (> prev-t 1.0) (>= 0.0 t))))
                       (action value))
                     {:value value :cache cache})})
   (constantly "(action-with! fn)")))

(defn action!
  "Action motion that calls a function.
   ```clojure
   (seq
     (to 10.0)
     (action! HapticFeedback.selectionClick)
     (to 20.0))
   ```
   
   If you need to call a function with the value, you can use `action-with!`"
  [action]
  (into-motion
   (:prepare-motion (action-with! (fn [_] (action))))
   (constantly "(action! fn)")))

(defn duration
  "Set the duration of the motion.\\
   `duration` takes a duration and an motion and returns a new motion with the provided duration.\\
   The duration is applied to the motion.
   ```clojure
   (duration 100 (to 10.0))
   ```"
  [duration motion]
  (let [motion (into-motion motion)]
    (into-motion
     (fn [value _]
       (let [{:keys [interpolate duration relative-duration]} ((:prepare-motion motion) value duration)
             duration-mcs (in-mcs duration)
             dur-mcs (in-mcs duration)
             max-duration (if (and duration-mcs dur-mcs) (max duration-mcs dur-mcs) (or duration-mcs dur-mcs))
             end (when (and dur-mcs (not= dur-mcs max-duration) (< 0 max-duration)) (/ dur-mcs max-duration))
             curve (when end (curves/interval 0.0 end :linear))]
         {:interpolate (if curve
                         #(interpolate (.transform curve (double %1)) %2)
                         interpolate)
          :relative-duration relative-duration
          :duration (from-mcs max-duration)}))
     (fn [] (str "(duration " duration " " ((:to-string motion)) ")")))))

(defn curve
  "Set the curve of the motion.\\
   `curve` takes a curve and an motion and returns a new motion with the provided curve.\\
   The curve is applied to the motion.
   ```clojure
   (curve :ease-in-out (to 10.0))
   ```"
  [curve motion]
  (let [motion (into-motion motion)
        curve (t/curve curve)]
    (into-motion
     (fn [value exp-dur]
       (let [{:keys [interpolate duration relative-duration]} ((:prepare-motion motion) value exp-dur)]
         {:interpolate #(interpolate (.transform curve (double %1)) %2)
          :relative-duration relative-duration
          :duration duration}))
     (fn [] (str "(curve " (.toString curve) " " ((:to-string motion)) ")")))))

(defn relative-duration
  "Set the duration of the motion relative to the parent animation.\\
   `relative-duration` takes a ratio and an motion and returns a new motion with the provided relative duration.\\
   The duration is applied to the motion.
   ```clojure
   (relative-duration 0.5 (to 10.0))
   ```"
  [ratio motion]
  (let [motion (into-motion motion)]
    (into-motion
     (fn [value exp-dur]
       (let [{:keys [interpolate duration relative-duration]} ((:prepare-motion motion) value exp-dur)]
         {:interpolate interpolate
          :duration duration
          :relative-duration (if relative-duration (* ratio relative-duration) ratio)}))
     (fn [] (str "(relative-duration " ratio " " ((:to-string motion)) ")")))))

(defn relative-delay
  "Set the start time of the motion relative to the duration.\\
   `relative-delay` takes a ratio and an motion and returns a new motion with the provided relative delay.\\
   The delay is applied to the motion.
   ```clojure
   (relative-delay 0.5 (to 10.0))
   ```"
  [delay motion]
  (let [motion (into-motion motion)]
    (into-motion
     (fn [value exp-dur]
       (let [exp-dur-mcs (in-mcs exp-dur)
             delay-mcs (when exp-dur-mcs (* delay exp-dur-mcs))
             dur-mcs (when exp-dur-mcs (* exp-dur-mcs (- 1.0 delay)))
             {:keys [interpolate duration relative-duration]} ((:prepare-motion motion) value (from-mcs dur-mcs))
             dur-mcs (when (and delay-mcs duration) (+ delay-mcs (in-mcs duration)))
             curve (curves/interval delay 1.0 :linear)]
         {:interpolate #(interpolate (.transform curve (double %1)) %2)
          :relative-duration (when relative-duration (+ delay relative-duration))
          :duration (from-mcs dur-mcs)}))
     (fn [] (str "(relative-delay " delay " " ((:to-string motion)) ")")))))

(defn delay
  "Set the start time of the motion.\\
   `delay` takes a duration and an motion and returns a new motion with the provided delay.\\
   The delay is applied to the motion.
   ```clojure
   (delay 100 (to 10.0))
   ```"
  [delay motion]
  (let [motion (into-motion motion)]
    (into-motion
     (fn [value exp-dur]
       (let [exp-dur-mcs (in-mcs exp-dur)
             delay-mcs (in-mcs delay)
             delay-ratio (when (and exp-dur-mcs (< 0 exp-dur-mcs)) (/ delay-mcs exp-dur-mcs))
             dur-mcs (when exp-dur-mcs (- exp-dur-mcs delay-mcs))
             {:keys [interpolate duration relative-duration]} ((:prepare-motion motion) value (from-mcs dur-mcs))
             dur-mcs (in-mcs duration)
             relative-duration (when (and delay-ratio relative-duration) (+ delay-ratio relative-duration))
             full-dur-mcs (when dur-mcs (+ delay-mcs dur-mcs))
             start (when full-dur-mcs (/ delay-mcs full-dur-mcs))
             end (if (and start dur-mcs full-dur-mcs (< 0 full-dur-mcs))
                   (+ start (/ dur-mcs full-dur-mcs))
                   1.0)
             curve (when start (curves/interval start end :linear))]
         {:interpolate (if curve
                         #(interpolate (.transform curve (double %1)) %2)
                         interpolate)
          :relative-duration relative-duration
          :duration (from-mcs full-dur-mcs)}))
     (fn [] (str "(delay " delay " " ((:to-string motion)) ")")))))

(defn with
  "Add options to an animation.\\
   `with` takes a map or key value pairs of options and an motion and returns a new motion with the provided options.\\
   The options are merged with the existing options of the animation.\\
   Options:
    - `:duration` or `:dur` - Duration of the motion in milliseconds, or Duration object or map.
    - `:delay` - Start time of the motion in milliseconds or Duration object or map.
    - `:relative-duration` or `:rel-dur` - Duration of the motion relative to the parent animation.
    - `:relative-delay` or `:rel-delay` - Start time ratio of the motion relative to the duration.
    - `:curve` - Curve of the animation.
   
   ```clojure
   (with {:duration 100} w/Colors.blue)
   (with :dur 100 :curve :ease-in-out w/Colors.blue)
   (with :duration 100 (to 10.0))
   ```"
  ([k v & kvs-motion]
   (let [{:keys [options] [motion] :items} (separate-options (concat [k v] kvs-motion))]
     (with options motion)))
  ([options motion]
   (let [{:keys [relative-delay delay relative-duration duration curve]} (motion-options options)]
     (cond->> (into-motion motion)
       curve (flutter-cljd.animations/curve curve)
       duration (flutter-cljd.animations/duration duration)
       relative-duration (flutter-cljd.animations/relative-duration relative-duration)
       delay (flutter-cljd.animations/delay delay)
       relative-delay (flutter-cljd.animations/relative-delay relative-delay)))))

(defn to
  "Animate to a value.\\
   `to` takes a value and returns an motion that animates from the current value to the provided values eventually.\\
   If the current value is nil, the first value is used as the initial value.\\
   Also, `to` can take key-value pairs or a map of options after the values.\\
   ```clojure
   (to 10.0 :dur 100)
   (to 5.0 10.0)
   (to Colors.blue Colors.red Colors.green {:delay 10})
   ```
   If you want to be sure that provided values will not be interpreted as animation options, you can use `values` instead."
  [value & values]
  (let [values (cons value values)
        {:keys [options items]} (separate-last-options values)]
    (assoc
     (if (empty? options)
       (apply flutter-cljd.animations/values items)
       (with options (apply flutter-cljd.animations/values items)))
     :to-string
     (fn [] (str "(to " (str/join " " values) ")")))))

(defn wait
  "Do nothing for a given duration. Duration is optional.
   ```clojure
   (wait 100)
   ```
   To wait relative to the parent motion wrap the `wait` in `with`:
   ```clojure
   (with {:relative-duration 0.2} (wait))
   ```
   Can be used to fill the time between motions:
   ```clojure
   (seq {:duration 600}
     (with {:duration 100} w/Colors.blue)
     (wait) ;; Wait for 400ms
     (with {:duration 100} w/Colors.red))
   ```"
  ([]
   (into-motion
    (fn [value, exp-dur] (const-anim value exp-dur))
    "(wait)"))
  ([duration]
   (into-motion
    (fn [value, _] (const-anim value duration))
    (fn [] (str "(wait " duration ")")))))

(defn seq
  "Sequential motions of the value.\\
   `seq` takes a list of motions and applies them one after the other.
   
   If `seq` has a duration, the duration is partitioned between the motions according to their options or evenly if not provided.\\
   If `seq` has a curve, the curve is partitioned between the motions and merged with the motion's curve if provided.\\
   `seq` can accept key-value pairs or a map of options before the motions.
   ```clojure
   (seq
     (with {:duration 50} w/Colors.blue)
     (with {:duration 100} w/Colors.red))
  
   (seq {:duration 200 :curve :ease-in-out}
     (par :color (with {:duration 50} w/Colors.blue)
          :offset (with {:duration 100} 10.0))
     (par :color (with {:duration 50} w/Colors.red)))
   
    (seq :duration 200 :delay 10
      (to w/Colors.blue :relative-duration 0.7)
      w/Colors.red)
   ```
   
   `seq` can be used to define initial value of the motion:
   ```clojure
   (seq
     {:color w/Colors.blue
      :dx 0.0}
     (par
       :color (with {:duration 50} w/Colors.blue)
       :dx (with {:duration 100} 10.0)))
   ```
   If you need to animate evenly spaced values, you can use `to` instead."
  [& motions]
  (let [{:keys [options items]} (separate-options motions)]
    (if-not (empty? options)
      (with options (-sequential items))
      (-sequential items))))

(defn par
  "Parallel motions of multiple properties of the value.\\
   `par` takes a list of key-value pairs, where the key is the property to animate and the value is the animation.\\
   It's useful when you want to animate multiple properties with different motions at the same time.\\
   If `par` has a duration, the duration is applied to all animations.\\
   If `par` has a curve, the curve is applied to all animations.
   ```clojure
   (par
      :color (to w/Colors.blue :duration 50)
      :offset (to 10.0 :duration 100))
   ```
   It's possible to nest `par` calls to animate nested properties:
   ```clojure
   (par :offset (par :dx (with {:duration 100} 10.0)))
   ```
   
   `par` can accept a map of options as the first argument:
   ```clojure
   (par {:duration 200 :curve :ease-in-out}
     :color (to w/Colors.blue)
     :offset (to 10.0 :duration 100))
   ```"
  [& kvs]
  (if (odd? (count kvs))
    (if (is-options? (first kvs))
      (with (first kvs) (-parallel (partition 2 (drop 1 kvs))))
      (throw (ex-info "Invalid arguments in par" {:args kvs})))
    (-parallel (partition 2 kvs))))

(defn repeat
  "Repeats a motion a specified number of times.\\
   Takes a count and a motion, returns a new motion that repeats the input animation.\\
   The total duration will be the motion's duration multiplied by the count.\\
   If count is 0 or negative, returns an instant animation.\\
   If count is 1, returns the original motion unchanged.
   ```clojure
   (repeat 3 (to 0 100))  ;; Goes 0->100 three times
   ```"
  ([cnt motion]
   (let [motion (into-motion motion)]
     (into-motion
      (cond
        (<= cnt 0) (instant)
        (= cnt 1) motion
        :else
        (fn [value exp-dur]
          (let [relative-duration (/ cnt)
                loop-dur (when exp-dur {:microseconds (* (in-mcs exp-dur) relative-duration)})
                prepare-motion (:prepare-motion motion)
                {:keys [duration interpolate]} (prepare-motion value loop-dur)]
            {:interpolate
             (fn [T cache]
               (let [transform-t #(if (= % 1.0) 1.0 (mod (* % cnt) 1.0))
                     t (transform-t T)
                     prev-t (:prev-t cache)
                     prev-t (when prev-t (transform-t prev-t))]
                 (interpolate t (assoc cache :prev-t prev-t))))
             :duration (some-> (or (when duration {:microseconds (* (in-mcs duration) cnt)}) exp-dur) t/duration)})))
      (fn [] (str "(repeat " cnt " " ((:to-string motion)) ")"))))))

(defn autoreverse
  "Creates a motion that plays forward then reverses.\\
   Takes a motion and returns a new motion that plays the input animation\\
   forward then plays it in reverse.\\
   The total duration will be double the original motion's duration.
   ```clojure
   (autoreverse (to 0 100))  ;; Goes 0 -> 100 -> 0
   ```"
  ([motion]
   (let [motion (into-motion motion)]
     (into-motion
      (fn [value exp-dur]
        (let [loop-dur (when exp-dur {:microseconds (/ (in-mcs exp-dur) 2)})
              {:keys [duration interpolate]} ((:prepare-motion motion) value loop-dur)]
          {:interpolate
           (fn [T cache]
             (let [transform-t #(* (if (<= % 0.5) % (- 1.0 %)) 2)
                   t (transform-t T)
                   prev-t (:prev-t cache)
                   prev-t (when prev-t (transform-t prev-t))]
               (interpolate t (assoc cache :prev-t prev-t))))
           :duration (some-> (or (when duration {:microseconds (* (in-mcs duration) 2)}) exp-dur) t/duration)}))
      (fn [] (str "(autoreverse " ((:to-string motion)) ")"))))))
