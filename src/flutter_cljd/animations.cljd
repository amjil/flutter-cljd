(ns flutter-cljd.animations
  (:require
   [cljd.core :as c]
   [cljd.set :refer [superset?]]
   [flutter-cljd.types :as t]
   [flutter-cljd.curves :as curves]
   ["package:flutter/widgets.dart" :as w]
   ["package:flutter/animation.dart" :as a]
   ["package:flutter/scheduler.dart" :as sc]
   ["dart:core" :as dc]
   [flutter-cljd.utils :as ut]
   [cljd.string :as str]))

(extend-protocol c/IFn
  a/Curve
  (-invoke [this t]
    (.transform this t))

  a/Animatable
  (-invoke [this t]
    (.transform this t)))

(deftype TransformedAnimation
         [^a/Animation parent transform]
  :extends a/Animation
  (value [this] ((.-transform this) (-> this .-parent .-value)))
  c/IEquiv
  (-equiv [o other] (identical? o other))
  ^:mixin a/AnimationWithParentMixin)

(defn map-anim
  "Transforms an animation using a transform function.\\
     `map-anim` takes an animation and a transform function and returns a new animation.\\
     The transform function takes the value of the parent animation and returns the transformed value.
     ```clojure
     (map-anim #(* % 2) parent)
     ```
     `Animation` implements `ILookup` to create a transformed animation that transforms the value of the parent animation.
     ```clojure
     (let [animation (always-stopped-animation {:x 10.0 :y 20})
           x-animation (:x animation) ;; an animation that always returns 10.0
           y-animation (get animation :y)] ;; an animation that always returns 20.0
     ```"
  [transform parent]
  (TransformedAnimation parent transform))

(extend-protocol c/ILookup
  a/Animation
  (-lookup [this key] (c/-lookup this key nil))
  (-lookup [this key not-found]
    (map-anim (fn [value] (c/-lookup value key not-found)) this))
  (-contains-key? [this key]
    (c/-contains-key? (.-value this) key)))

(defn- set-value [this new-value]
  (let [old-value (-> this .-tween .-end)
        tween (.-tween this)
        controller (.-controller this)]
    (when-not (= new-value old-value)
      (.-begin! tween (.evaluate tween this))
      (.-end! tween new-value)
      (if-not (.-isAnimating controller)
        (.forward controller .from 0.0)
        (let [progress (.-value controller)]
          (.forward controller .from 0.0)
          (.-value! controller progress)))
      nil)))

(defn- get-state [this]
  (-> this .-tween .-end))

(deftype AnimatedValue
         [tween
          ^a/AnimationController controller
          ^a/Animation parent]
  :extends (a/Animation)
  (value [^AnimatedValue this]
    (-> this .-tween (.lerp (-> this .-controller .-value))))
  c/IEquiv
  (-equiv [o other] (identical? o other))
  c/IDeref
  (-deref [^AnimatedValue this] (get-state this))
  c/ISwap
  (-swap! [^AnimatedValue this f] (set-value this (f (get-state this))))
  (-swap! [^AnimatedValue this f a] (set-value this (f (get-state this) a)))
  (-swap! [^AnimatedValue this f a b] (set-value this (f (get-state this) a b)))
  (-swap! [^AnimatedValue this f a b xs] (set-value this (apply f (get-state this) a b xs)))
  c/IReset
  (-reset! [^AnimatedValue this new-value] (set-value this new-value))
  (dispose [^AnimatedValue this]
    (.dispose (.-controller this)))
  ^:mixin a/AnimationWithParentMixin)

(defn ^AnimatedValue animated-value
  "Animation that can be used to animate value changes.\\
   `animated-value` takes an initial value and returns an animated value.\\
   The `vsync` argument is required and specifies the `TickerProvider` for the animation.\\
   The `options` argument is optional and specifies the animation options.\\
   The `options` argument can be a map with the following keys:
    - `:duration` - Duration of the animation.
    - `:curve` - Curve of the animation.
    - `:reverse-curve` - Reverse curve of the animation.
    - `:lerp` - Lerp function of the animation.
   
   ```clojure
   (animated-value 10.0 vsync)
   (animated-value 10.0 vsync {:duration 1000})
   ```
   To start the animation, change the value using `reset!` or `swap!`.
   ```clojure
   (reset! animated-value 20.0)
   ```"
  ([initial-value vsync] (animated-value initial-value vsync {}))
  ([initial-value vsync options]
   (let [options (t/animation-options options)
         controller (a/AnimationController
                     .vsync vsync
                     .duration (:duration options))]
     (AnimatedValue
      (t/tween (:lerp options) initial-value initial-value)
      controller
      (a/CurvedAnimation
       .parent controller
       .curve (:curve options a/Curves.linear)
       .reverseCurve (some-> options :reverse-curve t/curve))))))

(declare MotionController)

(defn- reset-cached-value [^MotionController controller]
  (.-cachedValue! controller nil)
  (.-cachedValueProgress! controller nil))

(defn- set-cached-value [^MotionController controller value]
  (.-cachedValue! controller value)
  (.-cachedValueProgress! controller (-> controller .-parent .-value)))

(defn- compute-motion [^MotionController controller]
  (when (or (.-needCompute controller) (nil? (.-interpolate controller)))
    (.-needCompute! controller false)
    (reset-cached-value controller)
    (let [{:keys [prepare-motion]} (.-motion controller)
          {:keys [duration interpolate side-effects]} (prepare-motion nil nil)
          {:keys [duration]} (t/animation-options {:duration duration})]
      (.-interpolate! controller interpolate)
      (.-duration! (.-parent controller) duration)
      (if side-effects
        (when (nil? (.-effectsListener controller))
          (let [listener
                (fn []
                  (let [progress (-> controller .-parent .-value)
                        prevProgress (.-prevProgress controller)
                        start (min progress (or prevProgress 0.0))
                        end (max progress (or prevProgress 0.0))]
                    (when (not= progress prevProgress)
                      (.-prevProgress! controller progress)
                      (doseq [effect (side-effects [start end])]
                        (effect)))))]
            (.-prevProgress! controller (-> controller .-parent .-value))
            (.-effectsListener! controller listener)
            (.addListener (.-parent controller) listener)))
        (if (.-effectsListener controller)
          (.removeListener (.-parent controller) (.-effectsListener controller))
          (.-effectsListener! controller nil))))))

(deftype ^:private MotionAnimationController
         [^:mutable ^MotionController? motionController
          ^:mutable ^double val
          ^:mutable ^a/Duration? dur
          ^String? dl
          ^a/TickerProvider vs
          ^a/AnimationBehavior ab]
  :extends (a/AnimationController
             .value val
             .duration dur
             .debugLabel dl
             .vsync vs
             .animationBehavior ab)

  (^sc/TickerFuture forward [^MotionAnimationController this ^double? .from]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.forward ^super this .from (some-> from double)))

  (^sc/TickerFuture reverse [^MotionAnimationController this ^double? .from]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.reverse ^super this .from (some-> from double)))

  (^sc/TickerFuture animateTo [^MotionAnimationController this
                               ^double target
                               ^a/Duration? .duration
                               ^a/Curve? .curve]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.animateTo ^super this (double target) .duration (some-> duration t/duration) .curve (t/curve (or curve :linear))))

  (^sc/TickerFuture animateBack [^MotionAnimationController this
                                 ^double target
                                 ^a/Duration? .duration
                                 ^a/Curve? .curve]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.animateBack ^super this (double target) .duration (some-> duration t/duration) .curve (t/curve (or curve :linear))))

  (^sc/TickerFuture repeat [^MotionAnimationController this
                            ^double? .min
                            ^double? .max
                            ^bool? .reverse
                            ^a/Duration? .period
                            ^int? .count]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.repeat ^super this
             .min (some-> min double)
             .max (some-> max double)
             .reverse (boolean reverse)
             .period (some-> period t/duration)
             .count (some-> count int)))
  (^sc/TickerFuture toggle [^MotionAnimationController this ^double? .from]
    (reset-cached-value (.-motionController this))
    (compute-motion (.-motionController this))
    (.toggle ^super this .from (some-> from double))))

(deftype MotionController
         [^:mutable motion
          ^:mutable interpolate
          ^:mutable effectsListener
          ^:mutable prevProgress
          ^:mutable needCompute
          ^:mutable cachedValue
          ^:mutable cachedValueProgress
          ^:mutable motionHash
          ^a/AnimationController parent]
  :extends (a/Animation)
  (value [^MotionController this]
    (if (and (not (.-isAnimating this)) (= (.-cachedValueProgress this) (-> this .-parent .-value)))
      (.-cachedValue this)
      (do
        (compute-motion this)
        (let [result ((.-interpolate this) (-> this .-parent .-value))]
          (when-not (.-isAnimating this)
            (set-cached-value this result))
          result))))
  dc/Object
  (toString [^MotionController this]
    ((-> this .-motion :to-string)))
  c/IEquiv
  (-equiv [o other] (identical? o other))
  (dispose [^MotionController this]
    (when (.-effectsListener this)
      (.removeListener this (.-effectsListener this)))
    (.dispose (.-parent this)))
  (^sc/TickerFuture animateBack [^MotionAnimationController this target .duration .curve]
    (.animateBack (.-parent this) (double target) .duration (some-> duration t/duration) .curve (t/curve (or curve :linear))))
  (^sc/TickerFuture animateTo [^MotionAnimationController this target .duration .curve]
    (.animateTo (.-parent this) (double target) .duration (some-> duration t/duration) .curve (t/curve (or curve :linear))))
  (^sc/TickerFuture forward [^MotionController this ^double? .from]
    (.forward (.-parent this) .from (some-> from double)))
  (^sc/TickerFuture repeat [^MotionController this .min .max .reverse .period .count]
    (.repeat (.-parent this)
             .min (some-> min double)
             .max (some-> max double)
             .reverse (boolean reverse)
             .period (some-> period t/duration)
             .count (some-> count int)))
  (reset [^MotionController this]
    (.reset (.-parent this)))
  (resync [^MotionController this vsync]
    (.resync (.-parent this) vsync))
  (^sc/TickerFuture reverse [^MotionController this .from]
    (.reverse (.-parent this) .from (some-> from double)))
  (stop [^MotionController this .canceled]
    (.stop (.-parent this) .canceled (boolean (or (nil? canceled) canceled))))
  (^sc/TickerFuture toggle [^MotionController this .from]
    (.toggle (.-parent this) .from (some-> from double)))
  ^:mixin a/AnimationWithParentMixin)

(defn ^double progress
  "Returns the current progress of the motion controller."
  [^MotionController controller]
  (-> controller .-parent .-value))

(defn progress!
  "Sets the current progress of the motion controller."
  [^MotionController controller ^double new-value]
  (.-value! (.-parent controller) new-value))

(defn- in-mcs [duration]
  (some-> duration t/duration .-inMicroseconds double))

(defn- from-mcs [mcs]
  (when mcs (t/duration {:microseconds mcs})))

(def ^:private options-keys #{:duration :dur :rel-dur :rel-delay :curve :lerp :relative-duration :delay :relative-delay})

(defn- is-options? [x]
  (and
   (map? x)
   (superset? options-keys (set (keys x)))))

(defn- motion-options [value]
  {:duration (:duration value (:dur value))
   :delay (:delay value)
   :relative-delay (:relative-delay value (:rel-delay value))
   :relative-duration (:relative-duration value (:rel-dur value))
   :curve (:curve value)
   :lerp (:lerp value)})

(defn- const-anim
  ([value]
   (constantly value))
  ([value duration]
   {:interpolate (const-anim value)
    :duration duration}))

(defn- flat-motions [motions]
  (->> motions
       (mapcat
        #(if (sequential? %) (flat-motions %) [%]))))

(defn- separate-options [args]
  (if (is-options? (first args))
    {:options (first args) :items (drop 1 args)}
    (reduce
     (fn [res arg]
       (let [{:keys [key options items finished]} res]
         (if (not finished)
           (if (nil? key)
             (if (and (keyword? arg) (options-keys arg))
               (assoc res :key arg)
               (assoc res :items (conj items arg) :finished true))
             (assoc res :key nil :options (assoc options key arg)))
           (assoc res :items (conj items arg)))))
     {:options {} :items []}
     args)))

(defn- separate-last-options [args]
  (if (is-options? (last args))
    {:options (last args) :items (drop-last 1 args)}
    (reduce
     (fn [res arg]
       (let [{:keys [options items]} res]
         (if (and (= (count items) 1) (keyword? arg) (options-keys arg))
           {:items [] :options (assoc options arg (first items))}
           {:items (cons arg items) :options options})))
     {:options {} :items []}
     (reverse args))))

(defn values
  "Animate values. Same as (to) but doesn't accept animation options.\\
   Use it when you want to be sure that provided values will not be interpreted as animation options.\\
   `values` takes values and returns a motion that animates from the current value to the provided values.\\
   If the current value is nil, the first value is used as the initial value.
   ```clojure
   (values ut/int-lerp 5 10)
   ```"
  [lerp & values]
  {:prepare-motion
   (fn [from exp-dur]
     (let [values (if (some? from) (concat [from] values) values)
           int-cnt (dec (count values))]
       {:interpolate (case int-cnt
                       0 (const-anim (first values))
                       1 (lerp (first values) (second values))
                       (fn [T]
                         (condp = T
                           0.0 (first values)
                           1.0 (last values)
                           (let [k (* T int-cnt)
                                 i (int k)
                                 t (- k i)]
                             (if (< i int-cnt)
                               ((lerp (nth values i) (nth values (inc i))) t)
                               (last values))))))
        :duration (if (zero? int-cnt) (t/duration 0) exp-dur)}))
   :to-string
   (fn [] (str "(values lerp " (str/join " " values) ")"))
   :to-hash
   (fn [] (hash (cons :values values)))})

(defn into-motion
  "Converts a value to a motion.\\
   A motion is a map with the following keys:
    - `:prepare-motion` - A function that takes the current value and the duration and returns a map with the following keys:
        - `:interpolate` - A function that takes the progress and the cache and returns the value and the cache.
        - `:duration` - Duration of the motion.
        - `:side-effects` - A function that takes a range and returns a list of side effects.
    - `:to-string` - A function that returns a string representation of the motion.
    - `:to-hash` - A function that returns a hash of the motion.
   
   `into-motion` takes a value and returns an motion that animates to the provided value.\\
   If the value is an instance of `Animatable`, it's used as the animation.\\
   If the value is nil, returns nil.
   If the value is a map with the keys `:prepare-motion`, `:to-hash` and `:to-string`, returns the value as is.
   Otherwise, returns the value wrapped in a `to` motion."
  ([motion]
   (cond
     (and (map? motion) (superset? #{:prepare-motion :to-string :to-hash} (set (keys motion))))
     motion

     (instance? w/Animatable motion)
     {:prepare-motion (fn [_ duration]
                        {:interpolate #(.transform motion %)
                         :duration duration})
      :to-string #(.toString motion)
      :to-hash #(hash (.toString motion))}

     (nil? motion)
     nil

     :else
     (values ut/lerp motion)))
  ([motion to-string to-hash]
   (if (fn? motion)
     {:prepare-motion motion
      :to-string to-string
      :to-hash to-hash}
     (when motion
       (assoc (into-motion motion)
              :to-string to-string
              :to-hash to-hash)))))

(defn set-motion!
  "Sets the motion of the motion controller.\\
   `set-motion!` takes a motion controller and a motion and sets the new motion to the controller."
  [^MotionController controller motion]
  (let [motion (into-motion motion)
        hash ((:to-hash motion))]
    (.-motion! controller motion)
    (.-needCompute! controller (not= hash (.-motionHash controller)))
    (.-motionHash! controller hash)
    (when (.-isAnimating controller)
      (compute-motion controller))
    controller))

(defn motion-controller
  "Creates a motion controller that manages animations.

  Arguments:
   - vsync: A `TickerProvider` that drives the animation (usually obtained from a widget's state)
   - motion: The motion to animate (created with `to`, `par`, `seq`, etc.)
   - options (optional):
     - :progress - Initial progress value (default: 0.0)
     - :debug-label - Label for debugging (optional)
     - :animation-behavior - Animation behavior on hot reload (default: :preserve)

  Returns a `MotionController` instance that:
   - Implements Animation protocol
   - Has .-value that returns the current motion value
   - Provides methods for controlling animation:
     - .forward - Start forward animation
     - .stop - Stop animation
     - .toggle - Toggle animation direction
     - .animateBack - Animate to previous value
     - .animateTo - Animate to specific value
     - .repeat - Repeat animation
     - .reset - Reset to initial state
     - .resync - Resync with vsync
     - .reverse - Reverse animation
     - .dispose - Clean up resources
   
  - Note: `MotionController` is not an `AnimationController` subclass, but it's a wrapper around it, you can access the underlying `AnimationController` with the `.-parent` field.

  Examples:
  ```clojure
  ;; Basic usage
  (motion-controller vsync (to 0.0 10.0))

  ;; With initial progress
  (motion-controller vsync (to 0.0 100.0) :progress 0.5)

  ;; Parallel animations with child animations
  (let [controller (motion-controller 
                    vsync
                    (par {:dur 500}
                         :opacity (to 0.0 1.0 :delay 100)
                         :offset (to 0.0 100)))]
    ;; Use child animations in widgets
    (widget
      :managed [animation controller]
      (->> (text \"Hello\")
           (animated (:opacity animation) opacity) ;; (:opacity animation) returns the child animation 
           (animated (:offset animation) #(offset %1 0)))))

  ;; Complex animation sequence with curves and relative durations
  (widget
    :managed [animation (motion-controller 
                         vsync
                         (seq
                           ;; Initial state
                           {:opacity 0.0
                            :scale 0.8
                            :offset 0.0}
                           ;; Fade in and scale up with ease-out
                           (par {:dur 400 :curve :ease-out}
                                :opacity (to 1.0 :relative-duration 0.5)
                                :scale 1.0)
                           ;; Wait a bit
                           (wait 200)
                           ;; Slide and bounce
                           (par
                             :offset (-> (to 0.0 20.0 0.0)
                                       (with {:dur 600 :curve :ease-in-out}))
                             ;; Scale effect happens during middle of slide
                             :scale (-> (to 1.0 1.1 1.0)
                                      (with {:dur 300
                                            :rel-delay 0.25
                                            :curve :ease-in-out}))
                           ;; Trigger taptic feedback
                           (action! HapticFeedback.selectionClick)))]                 
    (->> (text \"Animated Title\")
         (animated (:opacity animation) opacity)
         (animated (:scale animation) scale)
         (animated (:offset animation) #(offset 0 %))))

  ;; Sequential animations with relative timing
  (widget
    :managed [animation (motion-controller
                         vsync
                         (seq {:dur 2000}
                           {:step :first
                            :opacity 0.0
                            :scale 0.5
                            :color Colors.blue
                            :rotation 0}
                           ;; Take 40% of total time
                           (par {:rel-dur 0.4 :curve :ease-out}
                                :opacity (to 1.0 :curve :ease-in-out)
                                :scale 1.0)
                           ;; Brief pause (10% of time)
                           (wait :rel-dur 0.1)
                           ;; Rest of animation (50% of time)
                           (par
                             :step (const :last)
                             :color Colors.red
                             :rotation (to 0.0 360.0 :curve :ease-in-out)))]
    (->> (container)
         (animated (:opacity animation) opacity)
         (animated (:scale animation) scale)
         (animated (:color animation) background-color)
         (animated (:rotation animation) rotate)))
  ```"
  ([vsync motion & {:keys [progress debug-label animation-behavior]
                    :or {progress 0.0 animation-behavior a/AnimationBehavior.preserve}}]
   (let [^MotionAnimationController animation-controller (MotionAnimationController
                                                          nil
                                                          (double progress)
                                                          nil
                                                          debug-label
                                                          vsync
                                                          (t/animation-behavior animation-behavior))
         ^MotionController motion-controller (MotionController
                                              motion
                                              (constantly nil)
                                              nil
                                              0.0
                                              true
                                              nil
                                              nil
                                              nil
                                              animation-controller)]
     (.-motionController! animation-controller motion-controller)
     (set-motion! motion-controller motion)
     motion-controller)))

(defn instant
  "Instant motion with zero duration.
   ```clojure
   (instant 10.0)
   (instant)
   ```"
  ([]
   (into-motion
    (fn [value _] (const-anim value 0))
    (constantly "(instant)")
    (constantly (hash :instant))))
  ([value]
   (into-motion
    (fn [_ _] (const-anim value 0))
    (fn [] (str "(instant " value ")"))
    #(hash [:instant value]))))

(defn- transform-effect-t [t start end rel-dur]
  (if (zero? rel-dur)
    (cond
      (and (= t 0.0) (= start 0.0)) 0.0
      (= t end) 1.0
      (< end t) dc/double.infinity
      :else (- dc/double.infinity))
    (/ (- t start) rel-dur)))

(defn- -sequential [motions]
  (let [motions (->> motions flat-motions (filter some?) (map into-motion))
        clamp #(min 1.0 (max 0.0 %))]
    (into-motion
     (fn [value exp-dur]
       (let [{:keys [sum-abs sum-rel cnt-any items intr-dur effects-cnt last-value]}
             (reduce
              (fn [res motion]
                (if (some? motion)
                  (let [{:keys [last-value sum-abs sum-rel effects-cnt]} res
                        {:keys [duration relative-duration interpolate side-effects]} ((:prepare-motion motion) last-value nil)
                        next-value (interpolate 1.0)
                        duration (in-mcs duration)
                        relative (when (and (nil? duration) relative-duration) (clamp relative-duration))]
                    {:last-value next-value
                     :sum-abs (if duration (+ duration (or sum-abs 0.0)) sum-abs)
                     :sum-rel (+ sum-rel (or relative 0.0))
                     :cnt-any (+ (:cnt-any res) (if (or duration relative) 0 1))
                     :cnt-abs (+ (:cnt-abs res) (if duration 1 0))
                     :intr-dur (when (and duration relative-duration (< 0 relative-duration)) (/ duration relative-duration))
                     :items (conj (:items res) {:duration duration :relative-duration relative :interpolate interpolate :side-effects side-effects})
                     :effects-cnt (+ effects-cnt (if side-effects 1 0))})
                  res))
              {:last-value value :sum-abs nil :sum-rel 0.0 :cnt-any 0 :cnt-abs 0 :items [] :effects-cnt 0}
              motions)
             rel-k (if (< 1 sum-rel) (/ sum-rel) 1.0)
             sum-rel (clamp sum-rel)
             min-dur (if (and sum-abs sum-rel (< sum-rel 1.0)) (/ sum-abs (- 1.0 sum-rel)) sum-abs)
             exp-dur (in-mcs exp-dur)
             res-dur (let [durs (->>
                                 [exp-dur intr-dur]
                                 (concat (if (< 0 cnt-any) [] [min-dur]))
                                 (filter some?))]
                       (when-not (empty? durs) (apply max durs)))
             any-dur (if (> cnt-any 0)
                       (if (and res-dur min-dur (> res-dur 0))
                         (/ (- (/ (- res-dur min-dur) res-dur) sum-rel) cnt-any)
                         (/ (- 1.0 sum-rel) cnt-any))
                       0.0)
             all-cnt (count items)
             all-items (reduce
                          (fn [res item]
                            (let [{:keys [duration relative-duration]} item
                                  relative-duration (when relative-duration (* rel-k relative-duration))
                                  t (if (empty? res) 0.0 (:end (last res)))
                                  rel-dur (or relative-duration
                                              (when res-dur
                                                (if (< 0 res-dur)
                                                  (if duration (/ duration res-dur) any-dur)
                                                  (/ all-cnt)))
                                              any-dur)
                                  end (+ t rel-dur)]
                              (conj res (assoc item :start t :end end :rel-dur rel-dur))))
                          []
                          items)
             final-items (filter #(< 0 (:rel-dur %)) all-items)
             cnt (count final-items)
             last-all-i (dec all-cnt)]
         {:duration (from-mcs res-dur)
          :interpolate (case cnt
                         0 (if (< 0 all-cnt) 
                             (fn [T] (let [i (min last-all-i (int (* T all-cnt)))]
                                       (->> i (nth all-items) :last-value)))
                             (const-anim last-value))
                         1 (:interpolate (first final-items))
                         (fn [T]
                           (let [{:keys [rel-dur start end interpolate]}
                                 (cond
                                   (<= T 0) (first final-items)
                                   (>= T 1) (last final-items)
                                   :else
                                   (->> final-items
                                        (map-indexed (fn [i item] [i item]))
                                        (reverse)
                                        (some #(let [[i {:keys [start end] :as item}] %]
                                                 (when (or (<= start T end) (zero? i)) item)))))
                                 t (if (zero? rel-dur) 1.0 (/ (- T start) rel-dur))
                                 anim-t (cond->> t
                                          (< end 1) (min 1.0)
                                          (< 0 start) (max 0.0))]
                             (interpolate anim-t))))
          :side-effects (when (< 0 effects-cnt)
                          (let [effects
                                (filter
                                 some?
                                 (map
                                  (fn [{:keys [start end rel-dur side-effects]}]
                                    (when side-effects
                                      (let [transform #(transform-effect-t % start end rel-dur)]
                                        #(side-effects (map transform %)))))
                                  all-items))]
                            (fn [range]
                              (apply concat (map #(% range) effects)))))}))
     (fn [] (str "(seq " (str/join " " (map #((:to-string %)) motions)) ")"))
     (fn [] (hash (cons :sequential (map #((:to-hash %)) motions)))))))

(defn- -parallel [motions]
  (let [motions (map (fn [[k v]] [k (into-motion v)]) motions)]
    (into-motion
     (fn [value exp-dur]
       (let [value (or value {})
             exp-dur-in-mcs (in-mcs exp-dur)

             {:keys [max-dur items side-effects-cnt]}
             (reduce
              (fn [res [k v]]
                (let [{:keys [duration relative-duration interpolate side-effects]} ((:prepare-motion v) (get value k) exp-dur)
                      {:keys [max-dur items side-effects-cnt]} res
                      dur-abs (or
                               (in-mcs duration)
                               (when (and relative-duration exp-dur-in-mcs) (* exp-dur-in-mcs relative-duration)))
                      max-dur (if dur-abs (max dur-abs (or max-dur 0.0)) max-dur)
                      rel-dur (or
                               relative-duration
                               (when (and dur-abs exp-dur-in-mcs (< 0 exp-dur-in-mcs)) (/ dur-abs exp-dur-in-mcs))
                               1.0)]
                  {:max-dur max-dur
                   :side-effects-cnt (+ side-effects-cnt (if side-effects 1 0))
                   :items (assoc items k {:duration dur-abs :interpolate interpolate :rel-dur rel-dur :side-effects side-effects})}))
              {:max-dur nil :items {} :side-effects-cnt 0}
              motions)
             full-dur (if (and exp-dur-in-mcs max-dur)
                        (max exp-dur-in-mcs max-dur)
                        (or exp-dur-in-mcs max-dur))
             items (if (and full-dur (not= full-dur exp-dur-in-mcs) (< 0 full-dur))
                     (update-vals
                      items
                      (fn [{:keys [duration interpolate side-effects]}]
                        {:interpolate interpolate
                         :rel-dur (if duration (/ duration full-dur) 1.0)
                         :side-effects side-effects}))
                     items)]
         {:duration (some-> (or (from-mcs full-dur) exp-dur) t/duration)
          :interpolate (fn [T]
                         (let [results (map
                                        (fn [[k {:keys [interpolate rel-dur]}]]
                                          (let [transform-t #(cond
                                                               (zero? rel-dur) (if (= % 0.0) 0.0 1.0)
                                                               (= 1.0 rel-dur) %
                                                               :else (min 1.0 (/ % rel-dur)))
                                                t (transform-t T)]
                                            [k (interpolate t)]))
                                        items)]
                           (into value results)))
          :side-effects (when (< 0 side-effects-cnt)
                          (let [effects
                                (filter
                                 some?
                                 (map
                                  (fn [[_ {:keys [rel-dur side-effects]}]]
                                    (when side-effects
                                      (let [transform #(transform-effect-t % 0.0 rel-dur rel-dur)]
                                        #(side-effects (map transform %)))))
                                  items))]
                            (fn [range]
                              (apply concat (map #(% range) effects)))))}))
     (fn [] (str "(par " (str/join " " (map (fn [[k v]] (str k " " ((:to-string v)))) motions)) ")"))
     (fn [] (hash (cons :parallel (map (fn [[k v]] (hash [k ((:to-hash v))])) motions)))))))

(defn action-with!
  "Action motion that calls a function with the value.
   ```clojure
   (seq
     (to 10.0)
     (action-with! :prn println)) ;; Prints 10.0
   ```
   
   If you need to call a function without the value, you can use `action!`"
  [id action]
  (into-motion
   (fn [value _]
     {:duration 0
      :interpolate (constantly value)
      :side-effects (fn [[start end]]
                      (if (and (< start 1.0) (<= 1.0 end)) [#(action value)] []))})
   (constantly (str "(action-with! " id ")"))
   (constantly (hash [:action-with! id]))))

(defn action!
  "Action motion that calls a function.
   ```clojure
   (seq
     (to 10.0)
     (action! :tap HapticFeedback.selectionClick)
     (to 20.0))
   ```
   
   If you need to call a function with the value, you can use `action-with!`"
  [id action]
  (into-motion
   (:prepare-motion (action-with! id (fn [_] (action))))
   (constantly (str "(action! " id ")"))
   (constantly (hash [:action! id]))))

(defn duration
  "Set the duration of the motion.\\
   `duration` takes a duration and an motion and returns a new motion with the provided duration.\\
   The duration is applied to the motion.
   ```clojure
   (duration 100 (to 10.0))
   ```"
  [duration motion]
  (let [motion (into-motion motion)]
    (into-motion
     (fn [value _]
       (let [{:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value duration)
             duration-mcs (in-mcs duration)
             dur-mcs (in-mcs duration)
             max-duration (if (and duration-mcs dur-mcs) (max duration-mcs dur-mcs) (or duration-mcs dur-mcs))
             end (when (and dur-mcs (not= dur-mcs max-duration) (< 0 max-duration)) (/ dur-mcs max-duration))
             curve (when end (curves/interval nil end :linear))]
         {:interpolate (if curve
                         #(interpolate (.transform curve (double %)))
                         interpolate)
          :relative-duration relative-duration
          :duration (from-mcs max-duration)
          :side-effects (when side-effects
                          (if curve
                            (fn [interval]
                              (side-effects (map #(.transform curve (double %)) interval)))
                            side-effects))}))
     (fn [] (str "(duration " duration " " ((:to-string motion)) ")"))
     (fn [] (hash [:duration duration ((:to-hash motion))])))))

(defn curve
  "Set the curve of the motion.\\
   `curve` takes a curve and an motion and returns a new motion with the provided curve.\\
   The curve is applied to the motion.
   ```clojure
   (curve :ease-in-out (to 10.0))
   ```"
  [curve motion]
  (let [motion (into-motion motion)
        curve (t/curve curve)]
    (into-motion
     (fn [value exp-dur]
       (let [{:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value exp-dur)]
         {:interpolate #(interpolate (.transform curve (double %)))
          :relative-duration relative-duration
          :duration duration
          :side-effects (when side-effects
                          (fn [range]
                            (side-effects (map #(.transform curve (double %)) range))))}))
     (fn [] (str "(curve " (.toString curve) " " ((:to-string motion)) ")"))
     (fn [] (hash [:curve curve ((:to-hash motion))])))))

(defn relative-duration
  "Set the duration of the motion relative to the parent animation.\\
   `relative-duration` takes a ratio and an motion and returns a new motion with the provided relative duration.\\
   The duration is applied to the motion.
   ```clojure
   (relative-duration 0.5 (to 10.0))
   ```"
  [ratio motion]
  (let [motion (into-motion motion)]
    (into-motion
     (fn [value exp-dur]
       (let [{:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value exp-dur)]
         {:interpolate interpolate
          :duration duration
          :relative-duration (if relative-duration (* ratio relative-duration) ratio)
          :side-effects side-effects}))
     (fn [] (str "(relative-duration " ratio " " ((:to-string motion)) ")"))
     (fn [] (hash [:relative-duration ratio ((:to-hash motion))])))))

(defn relative-delay
  "Set the start time of the motion relative to the duration.\\
   `relative-delay` takes a ratio and an motion and returns a new motion with the provided relative delay.\\
   The delay is applied to the motion.
   ```clojure
   (relative-delay 0.5 (to 10.0))
   ```"
  [delay motion]
  (let [motion (into-motion motion)]
    (into-motion
     (fn [value exp-dur]
       (let [exp-dur-mcs (in-mcs exp-dur)
             delay-mcs (when exp-dur-mcs (* delay exp-dur-mcs))
             dur-mcs (when exp-dur-mcs (* exp-dur-mcs (- 1.0 delay)))
             {:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value (from-mcs dur-mcs))
             dur-mcs (when (and delay-mcs duration) (+ delay-mcs (in-mcs duration)))
             curve (curves/interval delay nil :linear)]
         {:interpolate #(interpolate (.transform curve (double %)))
          :relative-duration (when relative-duration (+ delay relative-duration))
          :duration (from-mcs dur-mcs)
          :side-effects (when side-effects
                          (fn [interval]
                            (side-effects (map #(.transform curve (double %)) interval))))}))
     (fn [] (str "(relative-delay " delay " " ((:to-string motion)) ")"))
     (fn [] (hash [:relative-delay delay ((:to-hash motion))])))))

(defn delay
  "Set the start time of the motion.\\
   `delay` takes a duration and an motion and returns a new motion with the provided delay.\\
   The delay is applied to the motion.
   ```clojure
   (delay 100 (to 10.0))
   ```"
  [delay motion]
  (let [motion (into-motion motion)]
    (into-motion
     (fn [value exp-dur]
       (let [exp-dur-mcs (in-mcs exp-dur)
             delay-mcs (in-mcs delay)
             delay-ratio (when (and exp-dur-mcs (< 0 exp-dur-mcs)) (/ delay-mcs exp-dur-mcs))
             dur-mcs (when exp-dur-mcs (- exp-dur-mcs delay-mcs))
             {:keys [interpolate duration relative-duration side-effects]} ((:prepare-motion motion) value (from-mcs dur-mcs))
             dur-mcs (in-mcs duration)
             relative-duration (when (and delay-ratio relative-duration) (+ delay-ratio relative-duration))
             full-dur-mcs (when dur-mcs (+ delay-mcs dur-mcs))
             start (when full-dur-mcs (/ delay-mcs full-dur-mcs))
             end (if (and start dur-mcs full-dur-mcs (< 0 full-dur-mcs))
                   (+ start (/ dur-mcs full-dur-mcs))
                   1.0)
             curve (when start (curves/interval start end :linear))]
         {:interpolate (if curve
                         #(interpolate (.transform curve (double %)))
                         interpolate)
          :relative-duration relative-duration
          :duration (from-mcs full-dur-mcs)
          :side-effects (when side-effects
                          (if curve
                            (fn [interval]
                              (side-effects (map #(.transform curve (double %)) interval)))
                            side-effects))}))
     (fn [] (str "(delay " delay " " ((:to-string motion)) ")"))
     (fn [] (hash [:delay delay ((:to-hash motion))])))))

(defn with
  "Add options to an animation.\\
   `with` takes a map or key value pairs of options and an motion and returns a new motion with the provided options.\\
   The options are merged with the existing options of the animation.\\
   Options:
    - `:duration` or `:dur` - Duration of the motion in milliseconds, or Duration object or map.
    - `:delay` - Start time of the motion in milliseconds or Duration object or map.
    - `:relative-duration` or `:rel-dur` - Duration of the motion relative to the parent animation.
    - `:relative-delay` or `:rel-delay` - Start time ratio of the motion relative to the duration.
    - `:curve` - Curve of the animation.
   
   ```clojure
   (with {:duration 100} w/Colors.blue)
   (with :dur 100 :curve :ease-in-out w/Colors.blue)
   (with :duration 100 (to 10.0))
   ```"
  ([k v & kvs-motion]
   (let [{:keys [options] [motion] :items} (separate-options (concat [k v] kvs-motion))]
     (with options motion)))
  ([options motion]
   (let [{:keys [relative-delay delay relative-duration duration curve]} (motion-options options)]
     (assoc
      (cond->> (into-motion motion)
        curve (flutter-cljd.animations/curve curve)
        duration (flutter-cljd.animations/duration duration)
        relative-duration (flutter-cljd.animations/relative-duration relative-duration)
        delay (flutter-cljd.animations/delay delay)
        relative-delay (flutter-cljd.animations/relative-delay relative-delay))
      :to-string
      (fn [] (str "(with " options " " ((:to-string motion)) ")"))))))

(defn const
  "Creates a motion that steps through constant values.\\
   Takes one or more values and returns a motion that changes discretely between them.\\
   If only one value is provided, creates a constant motion with that value.\\
   Can accept animation options map or key-value pairs after values.\\
   The duration is divided evenly between the values.
   ```clojure
   (const 10.0)  ;; Stays at 10.0
   (const 0 50 100)  ;; Steps from 0 to 50 to 100
   (const 0 100 :dur 2000)  ;; Steps over 1 second
   ```"
  [value & values]
  (let [values (cons value values)
        {:keys [options items]} (separate-last-options values)
        motion {:prepare-motion
                (fn [value exp-dur]
                  (let [cnt (count items)
                        last-i (- cnt 1)]
                    (case cnt
                      0 (const-anim value exp-dur)
                      1 (const-anim (last items) exp-dur)
                      {:duration exp-dur
                       :interpolate (fn [T]
                                      (let [i (min last-i (int (* T cnt)))]
                                        (nth items i)))})))}]
    (assoc
     (if (empty? options)
       motion
       (with options motion))
     :to-string
     (fn [] (str "(const " (str/join " " values) ")"))
     :to-hash
     (fn [] (hash (cons :const values))))))

(defn to
  "Animate to a value.\\
   `to` takes a value and returns an motion that animates from the current value to the provided values eventually.\\
   If the current value is nil, the first value is used as the initial value.\\
   Also, `to` can take key-value pairs or a map of options after the values.
   ```clojure
   (to 10.0 :dur 100)
   (to 5.0 10.0)
   (to Colors.blue Colors.red Colors.green {:delay 10})
   ```
   If you want to be sure that provided values will not be interpreted as animation options, you can use `values` instead."
  [value & values]
  (let [values (cons value values)
        {:keys [options items]} (separate-last-options values)
        lerp (:lerp options #(ut/lerp %1 %2))
        items (cons lerp items)]
    (assoc
     (if (empty? options)
       (apply flutter-cljd.animations/values items)
       (with options (apply flutter-cljd.animations/values items)))
     :to-string
     (fn [] (str "(to " (str/join " " values) ")"))
     :to-hash
     (fn [] (hash (cons :to values))))))

(defn from
  "Set the initial value of the motion.\\
   `from` takes a value and an motion and returns a new motion with the provided initial value.\\
   The initial value is applied to the motion.
   ```clojure
   (from 10.0 (to 20.0))
   ```"
  [from motion]
  (let [motion (into-motion motion)]
    (into-motion
     (fn [_ exp-dur]
       ((:prepare-motion motion) from exp-dur))
     (fn [] (str "(from " from " " ((:to-string motion)) ")"))
     (fn [] (hash [:from from ((:to-hash motion))])))))

(defn from-to
  "Animate from an initial value to final values. It's a shorthand for `(from (to values))`.\\
   `from-to` takes an initial value and final values and returns a new motion that animates between them.\\
   Can accept animation options map or key-value pairs after the values.
   ```clojure
   (from-to 0 100)
   (from-to 0 100 :dur 1000)
   ```"
  [initial & values]
  (assoc
   (from initial (apply to values))
   :to-string (fn [] (str "(from-to " initial " " (str/join " " values) ")"))
   :to-hash (fn [] (hash [:from-to initial values]))))

(defn wait
  "Do nothing for a given duration. Duration is optional.
   ```clojure
   (wait 100)
   ```
   To wait relative to the parent motion wrap the `wait` in `with`:
   ```clojure
   (wait :relative-duration 0.2)
   ```
   Can be used to fill the time between motions:
   ```clojure
   (seq {:duration 600}
     (with {:duration 100} w/Colors.blue)
     (wait) ;; Wait for 400ms
     (with {:duration 100} w/Colors.red))
   ```"
  ([& {:keys [duration dur relative-duration rel-dur delay relative-delay rel-del] :as options}]
   (let [result
         (into-motion
          (fn [value, exp-dur] (const-anim value exp-dur))
          (constantly "(wait)")
          (constantly (hash :wait)))]
     (if (empty? options) result (with options result))))
  ([duration & {:keys [relative-duration rel-dur delay relative-delay rel-del] :as options}]
   (let [result
         (into-motion
          (fn [value, _] (const-anim value duration))
          (fn [] (str "(wait " duration ")"))
          (fn [] (hash [:wait duration])))]
     (if (empty? options) result (with options result)))))

(defn seq
  "Sequential motions of the value.\\
   `seq` takes a list of motions and applies them one after the other.
   
   If `seq` has a duration, the duration is partitioned between the motions according to their options or evenly if not provided.\\
   If `seq` has a curve, the curve is partitioned between the motions and merged with the motion's curve if provided.\\
   `seq` can accept key-value pairs or a map of options before the motions.
   ```clojure
   (seq
     (with {:duration 50} w/Colors.blue)
     (with {:duration 100} w/Colors.red))
  
   (seq {:duration 200 :curve :ease-in-out}
     (par :color (with {:duration 50} w/Colors.blue)
          :offset (with {:duration 100} 10.0))
     (par :color (with {:duration 50} w/Colors.red)))
   
    (seq :duration 200 :delay 10
      (to w/Colors.blue :relative-duration 0.7)
      w/Colors.red)
   ```
   
   `seq` can be used to define initial value of the motion:
   ```clojure
   (seq
     {:color w/Colors.blue
      :dx 0.0}
     (par
       :color (with {:duration 50} w/Colors.blue)
       :dx (with {:duration 100} 10.0)))
   ```
   If you need to animate evenly spaced values, you can use `to` instead."
  [& motions]
  (let [{:keys [options items]} (separate-options motions)]
    (if-not (empty? options)
      (with options (-sequential items))
      (-sequential items))))

(defn par
  "Parallel motions of multiple properties of the value.\\
   `par` takes a list of key-value pairs, where the key is the property to animate and the value is the animation.\\
   It's useful when you want to animate multiple properties with different motions at the same time.\\
   If `par` has a duration, the duration is applied to all animations.\\
   If `par` has a curve, the curve is applied to all animations.
   ```clojure
   (par
      :color (to w/Colors.blue :duration 50)
      :offset (to 10.0 :duration 100))
   ```
   It's possible to nest `par` calls to animate nested properties:
   ```clojure
   (par :offset (par :dx (with {:duration 100} 10.0)))
   ```
   
   `par` can accept a map of options as the first argument:
   ```clojure
   (par {:duration 200 :curve :ease-in-out}
     :color (to w/Colors.blue)
     :offset (to 10.0 :duration 100))
   ```"
  [& kvs]
  (if (odd? (count kvs))
    (if (is-options? (first kvs))
      (with (first kvs) (-parallel (partition 2 (drop 1 kvs))))
      (throw (ex-info "Invalid arguments in par" {:args kvs})))
    (-parallel (partition 2 kvs))))

(defn repeat
  "Repeats a motion a specified number of times.\\
   Takes a count and a motion, returns a new motion that repeats the input animation.\\
   The total duration will be the motion's duration multiplied by the count.\\
   If count is 0 or negative, returns an instant animation.\\
   If count is 1, returns the original motion unchanged.
   ```clojure
   (repeat 3 (to 0 100))  ;; Goes 0 -> 100 three times
   ```"
  ([cnt motion]
   (let [motion (into-motion motion)]
     (into-motion
      (cond
        (<= cnt 0) (instant)
        (= cnt 1) motion
        :else
        (fn [value exp-dur]
          (let [relative-duration (/ cnt)
                loop-dur (when exp-dur {:microseconds (* (in-mcs exp-dur) relative-duration)})
                prepare-motion (:prepare-motion motion)
                {:keys [duration interpolate side-effects]} (prepare-motion value loop-dur)
                transform #(if (= % 1.0) 1.0 (mod (* % cnt) 1.0))]
            {:interpolate
             (fn [T]
               (let [t (transform T)]
                 (interpolate t)))
             :duration (some-> (or (when duration {:microseconds (* (in-mcs duration) cnt)}) exp-dur) t/duration)
             :side-effects (when side-effects
                             (fn [[start end]]
                               (let [dur (- end start)]
                                 (if (<= relative-duration dur)
                                   (side-effects [0.0 1.0])
                                   (let [[x y] (map #(int (/ % cnt)) [start end])
                                         s (transform start)
                                         e (transform end)
                                         ranges (if (= x y) [[s e]] [[s 1.0] [0.0 e]])]
                                     (apply concat (map side-effects ranges)))))))})))
      (fn [] (str "(repeat " cnt " " ((:to-string motion)) ")"))
      (fn [] (hash [:repeat cnt ((:to-hash motion))]))))))

(defn autoreverse
  "Creates a motion that plays forward then reverses.\\
   Takes a motion and returns a new motion that plays the input animation\\
   forward then plays it in reverse.\\
   The total duration will be double the original motion's duration.
   ```clojure
   (autoreverse (to 0 100))  ;; Goes 0 -> 100 -> 0
   ```"
  ([motion]
   (let [motion (into-motion motion)]
     (into-motion
      (fn [value exp-dur]
        (let [loop-dur (when exp-dur {:microseconds (/ (in-mcs exp-dur) 2)})
              {:keys [duration interpolate side-effects]} ((:prepare-motion motion) value loop-dur)
              transform #(* (if (<= % 0.5) % (- 1.0 %)) 2)]
          {:interpolate
           (fn [T]
             (let [t (transform T)]
               (interpolate t)))
           :duration (some-> (or (when duration {:microseconds (* (in-mcs duration) 2)}) exp-dur) t/duration)
           :side-effects (when side-effects
                           (fn [[start end]]
                             (let [s (transform start)
                                   e (transform end)
                                   ranges
                                   (if (or (<= end 0.5) (<= 0.5 start))
                                     [[(min s e) (max s e)]]
                                     [[s 1.0] [e 1.0]])]
                               (apply concat (map #(side-effects %) ranges)))))}))
      (fn [] (str "(autoreverse " ((:to-string motion)) ")"))
      (fn [] (hash [:autoreverse ((:to-hash motion))]))))))

(defn synced 
  "Creates a motion that syncs with the current time.\\
  Takes a motion and returns a new motion that syncs the input animation with the current time.\\
  The total duration will be the original motion's duration.
  ```clojure
  ;; Loader widget that is synced with the current time, so all loaders will be in sync.
  (widget
   :vsync vsync
   :managed [rotation-cntr (motion-controller
                              vsync
                              (synced (to 0.0 (* 2 π) :dur 1000)))]
   (->> (image \"loader.png\")
        (animated rotation-cntr rotated)
        (center)
        (on-appear #(.repeat rotation-cntr))))
  ```"
  [motion]
  (let [motion (into-motion motion)]
    (into-motion
     (fn [value exp-dur]
       (let [{:keys [duration interpolate side-effects]} ((:prepare-motion motion) value exp-dur)
             dur-ms (.-inMilliseconds (t/duration duration))
             transform (fn [_] (/ (mod (.-millisecondsSinceEpoch dc/DateTime.now) dur-ms) dur-ms))]
         {:interpolate (if (< 0 dur-ms)
                         (fn [t] (interpolate (transform t)))
                         interpolate)
          :duration duration
          :side-effects (when side-effects
                          (fn [range]
                            (side-effects (map transform range))))}))
     (fn [] (str "(synced " ((:to-string motion)) ")"))
     (fn [] (hash [:synced ((:to-hash motion))])))))
