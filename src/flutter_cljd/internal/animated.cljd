(ns flutter-cljd.internal.animated
  (:require
   [cljd.core :as c]
   ["dart:ui" :as ui]
   [cljd.flutter :as f]
   [flutter-cljd.types :as t]
   [flutter-cljd.ListenableAtom :as la]
   ["package:flutter/foundation.dart" :as fd]
   ["package:flutter/widgets.dart" :as w]
   ["package:flutter/animation.dart" :as a]
   [flutter-cljd.utils :as ut]))

;; MARK: Animated

(defn- ^f/CustomTween build-tween
  ([lerp-fn from to]
   (doto (f/CustomTween (or lerp-fn #(ut/lerp %1 %2)) nil)
     (.-begin! from)
     (.-end! to)))
  ([lerp-fn value]
   (build-tween lerp-fn value value)))

(defn animated*
  [builder values]
   (let [has-child? (instance? w/Widget (last values))
         [animation builder args]
         (cond
           (fn? builder) [{} builder values]
           (fn? (first values)) [builder (first values) (drop 1 values)]
           (and (fn? (second values))
                (or (and has-child? (= (count values) 3))
                    (= (count values) 2)))
           [builder (second values) (cons (first values) (drop 2 values))]
           :else (throw (ex-info "Invalid arguments in animated" {:args (cons builder values)})))
         [values child] (if has-child?
                        [(vec (drop-last args)) (last args)]
                        [(vec args) nil])
         getter #(.-value %)
         builder (fn [value child]
                   (apply builder (if has-child? (conj value child) value)))]
     (cond
       (map? animation) 
       (let [options (t/animation-options animation)
             lerp (:lerp animation)
             condition (if (some? (animation :when)) (animation :when) true)]
         (w/TweenAnimationBuilder
          .key (t/widget-key (animation :key))
          .tween (build-tween lerp values)
          .duration (if condition (options :duration) (t/duration 0))
          .curve (options :curve)
          .builder (fn [_ value child] (builder value child))
          .onEnd (options :on-end)
          .child child))

       (or
        (instance? a/Animation animation)
        (instance? fd/ValueListenable animation))
       (w/AnimatedBuilder
        .animation animation
        .child child
        .builder (fn [_ child] (builder (getter animation) child))) 
       
       (instance? c/Atom animation) 
       (w/AnimatedBuilder
        .animation (la/AtomListenable animation)
        .child child
        .builder (fn [_ child]
                   (builder (getter animation) child)))

       :else
       (throw (ex-info "Invalid animation" {:animation animation})))))
  
 
(deftype TransformedAnimation
         [^a/Animation parent transform]
  :extends a/Animation
  (isAnimating [this] (-> this .-parent .-isAnimating))
  (isCompleted [this] (-> this .-parent .-isCompleted))
  (isDismissed [this] (-> this .-parent .-isDismissed))
  (isForwardOrCompleted [this] (-> this .-parent .-isForwardOrCompleted))
  (status [this] (-> this .-parent .-status))
  (value [this] ((.-transform this) (-> this .-parent .-value)))
  (addListener [this listener] (.addListener (.-parent this) listener))
  (removeListener [this listener] (.removeListener (.-parent this) listener))
  (addStatusListener [this listener] (.addStatusListener (.-parent this) listener))
  (removeStatusListener [this listener] (.removeStatusListener (.-parent this) listener)))

(defn animation-of
  ([^a/Animation value transform]
   (TransformedAnimation value transform)))

 (defn- set-value [this new-value]
    (let [old-value (-> this .-tween .-end)
          tween (.-tween this)]
      (when-not (= new-value old-value)
        (.-begin! tween (.evaluate tween this))
        (.-end! tween new-value)
        (if-not (.-isAnimating this)
          (.forward this .from 0.0)
          (let [progress (.-value this)]
            (.forward this .from 0.0)
            (.-value! this progress)))
        nil)))
 
 (defn- get-state [this]
    (-> this .-tween .-end))
  
(deftype AnimatedValue 
         [tween
          ^a/TickerProvider vsync
          duration
          curve]
  :extends (a/AnimationController
             .vsync vsync
             .duration duration) 
  c/IEquiv
  (-equiv [o other] (identical? o other))
  c/IDeref
  (-deref [this] (get-state this))
  c/ISwap
  (-swap! [this f] (set-value this (f (get-state this))))
  (-swap! [this f a] (set-value this (f (get-state this) a)))
  (-swap! [this f a b] (set-value this (f (get-state this) a b)))
  (-swap! [this f a b xs] (set-value this (apply f (get-state this) a b xs)))
  c/IReset
  (-reset! [this new-value] (set-value this new-value)) 
  c/IFn
  (-invoke [this transform]
           (animation-of this transform)))

 (defn animated-value
   ([initial-value vsync] (animated-value initial-value vsync {}))
   ([initial-value vsync options]
    (let [options (t/animation-options options)]
      (AnimatedValue 
       (build-tween (:lerp options) initial-value) 
       vsync
       (:duration options)
       (:curve options)))))
 

(defn anim-cntr [& args])
 

 (defn is-absolute-time? [time]
   (or (map? time) (and (int? time) (< 1 time)) (instance? w/Duration time)))
 
 (defn relative-time [time full]
   (if (vector? time)
     (map #(relative-time % full) time)
     (if (is-absolute-time? time)
       (cond
         (nil? full) nil
         (is-absolute-time? full) (apply / (map #(-> % t/duration .-inMicroseconds double) [time full]))
         :else (* (t/duration time) full))
       time)))
 
 (defn absolute-time [time full]
   (if (vector? time)
     (map #(absolute-time % full) time)
     (if (is-absolute-time? time)
       time
       (when (and (some? time) (is-absolute-time? full))
         (* (t/duration full) time)))))

(def instant
  (fn [value, _]
    {:anim (fn [_] value)
     :dur {:ms 0}}))
 
 (defn- in-mcs [duration]
   (-> duration t/duration .-inMicroseconds double))

(defn- -sequential [animations]
  (case (count animations)
    0 instant
    1 (first animations)
    
    :else 
    (fn [value exp-dur]
      (let [{:keys [sum-abs sum-rel cnt-any cnt-abs items]}
            (reduce
             (fn [animation res]
               (let [{:keys [i value sum-abs sum-rel]} res
                     {:keys [dur anim]} (animation value nil)
                     next-value (anim 1.0)
                     is-absolute-dur? (is-absolute-time? dur)
                     dur (if is-absolute-dur? (in-mcs dur) dur)]
                 {:i (+ i 1)
                  :value next-value
                  :sum-abs (if is-absolute-dur? (+ dur sum-abs) sum-abs)
                  :sum-rel (if (or is-absolute-dur? (nil? dur)) sum-rel (+ dur sum-rel))
                  :cnt-any (+ (:cnt-any res) (if (some? dur) 0 1))
                  :cnt-abs (+ (:cnt-abs res) (if is-absolute-dur? 1 0))
                  :items (conj (:items res) {:dur dur :is-absolute-dur? is-absolute-dur? :anim anim :from value})}))
             {:i 0 :value value :sum-abs 0.0 :sum-rel 0.0 :cnt-any 0 :cnt-abs 0 :items []}
             animations)
            sum-rel (min 1.0 (max 0.0 sum-rel))
            min-dur (* sum-abs (- 1.0 sum-rel))
            is-absolute-dur? (is-absolute-time? exp-dur)
            exp-dur (when is-absolute-dur? (in-mcs exp-dur))
            res-dur (if is-absolute-dur? 
                      (max min-dur exp-dur)
                      (when (and (zero? cnt-any) (> cnt-abs 0)) min-dur))
            any-dur (if (and res-dur (> cnt-any 0)) (/ (- res-dur min-dur) cnt-any res-dur) 0.0)
            final-items (reduce 
                         (fn [item res]
                           (let [{:keys [dur is-absolute-dur?]} item
                                 t (if (empty? res) 0.0 (:end (last res)))
                                 real-dur (cond 
                                            is-absolute-dur? (/ dur res-dur)
                                            (nil? dur) any-dur
                                            :else dur)
                                 end (+ t real-dur)]
                             (conj res (assoc item :start t :end end))))
                         []
                         items)]
        {:dur res-dur
         :anim (fn [t]
                 (let [t (min 1.0 (max 0.0 t))
                       item (or (some #(when (<= (:start %) t (:end %)) %) final-items) (last final-items))
                       {:keys [start end anim]} item
                       dur (- end start)
                       anim-t (if (zero? dur) 1.0 (/ (- t start) dur))]
                   (anim anim-t)))}))))
 
(defn- -parallel [animations])

 (defn anim [anim-val]
   (cond 
     (fn? anim-val)
     anim-val
     
     (seq? anim-val)
     (-sequential (map anim (flatten anim-val)))

     (map? anim-val)
     (-parallel anim-val)))

(defn anim-duration [exp-duration]
  )
 
;; (defn with-dur [dur animation]
;;   (let [animation (anim animation)]
;;     (fn [value exp-duration]
;;       (let [{:keys [anim base-dur]} (animation value exp-duration)]
;;         {:anim anim :dur (or dur base-dur)}))))

;; (defn with-curve [curve animation]
;;   (let [animation (anim animation)
;;         curve (t/curve curve)]
;;     (fn [value exp-duration]
;;       (let [{:keys [anim dur]} (animation value exp-duration)]
;;         {:anim #(anim (curve %)) :dur dur}))))

;; (defn with-at [at animation]
;;   (let [curve (cond
;;                 (number? at) (t/interval at 1.0)
;;                 (vector? at) (t/interval at))]
;;     (with-curve curve animation)))

(defn with [animation & {:keys [dur curve at]}] 
  (let [animation (anim animation)]
    (fn [value exp-dur]
      (let [duration (if (and (is-absolute-time? exp-dur) (not (is-absolute-time? dur)))
                       exp-dur (or dur exp-dur))
            {:keys [anim dur]} (animation value duration)
            time (relative-time at dur)
            curve (or (some-> time (t/interval curve))
                      (t/curve (or curve :linear)))]
       {:anim #(anim (curve %))
        :dur dur}))))

 (defn from-to [from to & {:as options}] 
   (fn [_ exp-duration] 
     [(build-tween nil from to) ]))

(defn to [value & {:as options}] 
  (fn [from exp-duration] 
    []))

(defn ttt [] 

  (anim-cntr
   {:dur 500 :curve :ease-in-out}
   [{:color (from-to w/Colors.red w/Colors.blue :at 0.5)
     :dx (from-to 0.0 24.0 :curve :ease-in-out)}
    {:color (to w/Colors.red)}])
  
  ;; (animation-of cntr :color
  ;;               {:tween [w/Colors.red w/Colors.blue]
  ;;                :curve (t/interval 0.4 1 :ease-in-out)})

  ;; (animate-intervals cntr {[0 1] #(assoc % :color w/Colors.blue)
  ;;                          [0.5 1] #(assoc-in % [:color :alpha] 0.5)})

  )