(ns flutter-cljd.internal.animated
  (:require
   [cljd.core :as c]
   ["dart:ui" :as ui]
   [cljd.flutter :as f]
   [flutter-cljd.types :as t]
   [flutter-cljd.ListenableAtom :as la]
   ["package:flutter/foundation.dart" :as fd]
   ["package:flutter/widgets.dart" :as w]
   ["package:flutter/animation.dart" :as a]
   [flutter-cljd.utils :as ut]))

;; MARK: Animated

(defn- ^f/CustomTween build-tween
  ([lerp-fn from to]
   (doto (f/CustomTween (or lerp-fn #(ut/lerp %1 %2)) nil)
     (.-begin! from)
     (.-end! to)))
  ([lerp-fn value]
   (build-tween lerp-fn value value)))

(defn animated*
  [builder values]
   (let [has-child? (instance? w/Widget (last values))
         [animation builder args]
         (cond
           (fn? builder) [{} builder values]
           (fn? (first values)) [builder (first values) (drop 1 values)]
           (and (fn? (second values))
                (or (and has-child? (= (count values) 3))
                    (= (count values) 2)))
           [builder (second values) (cons (first values) (drop 2 values))]
           :else (throw (ex-info "Invalid arguments in animated" {:args (cons builder values)})))
         [values child] (if has-child?
                        [(vec (drop-last args)) (last args)]
                        [(vec args) nil])
         getter #(.-value %)
         builder (fn [value child]
                   (apply builder (if has-child? (conj value child) value)))]
     (cond
       (map? animation) 
       (let [options (t/animation-options animation)
             lerp (:lerp animation)
             condition (if (some? (animation :when)) (animation :when) true)]
         (w/TweenAnimationBuilder
          .key (t/widget-key (animation :key))
          .tween (build-tween lerp values)
          .duration (if condition (options :duration) (t/duration 0))
          .curve (options :curve)
          .builder (fn [_ value child] (builder value child))
          .onEnd (options :on-end)
          .child child))

       (or
        (instance? a/Animation animation)
        (instance? fd/ValueListenable animation))
       (w/AnimatedBuilder
        .animation animation
        .child child
        .builder (fn [_ child] (builder (getter animation) child))) 
       
       (instance? c/Atom animation) 
       (w/AnimatedBuilder
        .animation (la/AtomListenable animation)
        .child child
        .builder (fn [_ child]
                   (builder (getter animation) child)))

       :else
       (throw (ex-info "Invalid animation" {:animation animation})))))
  
 
(deftype TransformedAnimation
         [^a/Animation parent transform]
  :extends a/Animation
  (isAnimating [this] (-> this .-parent .-isAnimating))
  (isCompleted [this] (-> this .-parent .-isCompleted))
  (isDismissed [this] (-> this .-parent .-isDismissed))
  (isForwardOrCompleted [this] (-> this .-parent .-isForwardOrCompleted))
  (status [this] (-> this .-parent .-status))
  (value [this] ((.-transform this) (-> this .-parent .-value)))
  (addListener [this listener] (.addListener (.-parent this) listener))
  (removeListener [this listener] (.removeListener (.-parent this) listener))
  (addStatusListener [this listener] (.addStatusListener (.-parent this) listener))
  (removeStatusListener [this listener] (.removeStatusListener (.-parent this) listener)))

(defn animation-of
  ([^a/Animation value transform]
   (TransformedAnimation value transform)))

 (defn- set-value [this new-value]
    (let [old-value (-> this .-tween .-end)
          tween (.-tween this)]
      (when-not (= new-value old-value)
        (.-begin! tween (.evaluate tween this))
        (.-end! tween new-value)
        (if-not (.-isAnimating this)
          (.forward this .from 0.0)
          (let [progress (.-value this)]
            (.forward this .from 0.0)
            (.-value! this progress)))
        nil)))
 
 (defn- get-state [this]
    (-> this .-tween .-end))
  
(deftype AnimatedValue 
         [tween
          ^a/TickerProvider vsync
          duration
          curve]
  :extends (a/AnimationController
             .vsync vsync
             .duration duration) 
  c/IEquiv
  (-equiv [o other] (identical? o other))
  c/IDeref
  (-deref [this] (get-state this))
  c/ISwap
  (-swap! [this f] (set-value this (f (get-state this))))
  (-swap! [this f a] (set-value this (f (get-state this) a)))
  (-swap! [this f a b] (set-value this (f (get-state this) a b)))
  (-swap! [this f a b xs] (set-value this (apply f (get-state this) a b xs)))
  c/IReset
  (-reset! [this new-value] (set-value this new-value)) 
  c/IFn
  (-invoke [this transform]
           (animation-of this transform)))

 (defn animated-value
   ([initial-value vsync] (animated-value initial-value vsync {}))
   ([initial-value vsync options]
    (let [options (t/animation-options options)]
      (AnimatedValue 
       (build-tween (:lerp options) initial-value) 
       vsync
       (:duration options)
       (:curve options)))))
 

(defn anim-cntr 
  ([options initial-value animations])

  ([initial-value animations])
  ([options animations])

  ([animations]))

 (defn is-absolute-time? [time]
   (or (map? time) (and (int? time) (< 1 time)) (instance? w/Duration time)))
 
 (defn- in-mcs [duration]
   (-> duration t/duration .-inMicroseconds double))

 (defn relative-time [time full]
   (if (vector? time)
     (map #(relative-time % full) time)
     (if (is-absolute-time? time)
       (cond
         (is-absolute-time? full) (apply / (map in-mcs [time full]))
         :else nil)
       time)))

(def instant
  (fn [value, _]
    {:anim (fn [_] value)
     :dur {:ms 0}}))
 
(defn- -sequential [animations]
  (case (count animations)
    0 instant
    1 (first animations)
    
    (fn [value exp-dur]
      (let [{:keys [sum-abs sum-rel cnt-any cnt-abs items]}
            (reduce
             (fn [animation res]
               (let [{:keys [i value sum-abs sum-rel]} res
                     {:keys [dur anim]} (animation value nil)
                     next-value (anim 1.0)
                     is-absolute-dur? (is-absolute-time? dur)
                     dur (if is-absolute-dur? (in-mcs dur) dur)]
                 {:i (+ i 1)
                  :value next-value
                  :sum-abs (if is-absolute-dur? (+ dur sum-abs) sum-abs)
                  :sum-rel (if (or is-absolute-dur? (nil? dur)) sum-rel (+ dur sum-rel))
                  :cnt-any (+ (:cnt-any res) (if (some? dur) 0 1))
                  :cnt-abs (+ (:cnt-abs res) (if is-absolute-dur? 1 0))
                  :items (conj (:items res) {:dur dur :is-absolute-dur? is-absolute-dur? :anim anim :from value})}))
             {:i 0 :value value :sum-abs 0.0 :sum-rel 0.0 :cnt-any 0 :cnt-abs 0 :items []}
             animations)
            sum-rel (min 1.0 (max 0.0 sum-rel))
            min-dur (* sum-abs (- 1.0 sum-rel))
            is-absolute-dur? (is-absolute-time? exp-dur)
            exp-dur (when is-absolute-dur? (in-mcs exp-dur))
            res-dur (if is-absolute-dur? 
                      (max min-dur exp-dur)
                      (when (and (zero? cnt-any) (> cnt-abs 0)) min-dur))
            any-dur (if (and res-dur (> cnt-any 0)) (/ (- res-dur min-dur) cnt-any res-dur) 0.0)
            final-items (reduce 
                         (fn [item res]
                           (let [{:keys [dur is-absolute-dur?]} item
                                 t (if (empty? res) 0.0 (:end (last res)))
                                 real-dur (cond 
                                            is-absolute-dur? (/ dur res-dur)
                                            (nil? dur) any-dur
                                            :else dur)
                                 end (+ t real-dur)]
                             (conj res (assoc item :start t :end end))))
                         []
                         items)]
        {:dur (when res-dur {:microseconds res-dur})
         :anim (fn [t]
                 (let [t (min 1.0 (max 0.0 t))
                       item (or (some #(when (<= (:start %) t (:end %)) %) final-items) (last final-items))
                       {:keys [start end anim]} item
                       dur (- end start)
                       anim-t (if (zero? dur) 1.0 (/ (- t start) dur))]
                   (anim anim-t)))}))))
 
(defn- -parallel [animations]
  (fn [value exp-dur]
    (let [exp-dur-in-mcs 
          (when (is-absolute-time? exp-dur) (in-mcs exp-dur))

          {:keys [max-dur items]} 
          (reduce 
           (fn [[k v] res]
             (let [{:keys [dur anim]} (v value exp-dur)
                   {:keys [max-dur items]} res
                   dur (cond 
                         (is-absolute-time? dur) (in-mcs dur)
                         (nil? dur) exp-dur-in-mcs
                         :else (when exp-dur-in-mcs (* exp-dur-in-mcs dur)))
                   max-dur (if dur (max dur (or max-dur 0.0)) max-dur)
                   rel-dur (if (and dur exp-dur-in-mcs (< 0 exp-dur-in-mcs)) (/ dur exp-dur-in-mcs) 1.0)]
               {:max-dur max-dur
                :items (assoc items k {:dur dur :anim anim :rel-dur rel-dur})}))
           {:max-dur nil :items {}}
           animations)
          full-dur (if (and exp-dur-in-mcs max-dur)
                     (max exp-dur-in-mcs max-dur)
                     (or exp-dur-in-mcs max-dur))
          items (if (and full-dur (not= full-dur exp-dur-in-mcs) (< 0 full-dur))
                  (update-vals 
                   items 
                   (fn [{:keys [dur anim]}]
                     {:anim anim
                      :rel-dur (if dur (/ dur full-dur) 1.0)}))
                  items)]
      {:dur (or (when max-dur {:microseconds max-dur}) exp-dur)
       :anim (fn [t]
               (update-vals 
                items
                (fn [{:keys [anim rel-dur]}]
                  (anim (cond 
                          (zero? rel-dur) 1.0  
                          (= 1.0 rel-dur) t
                          :else (min 1.0 (/ t rel-dur)))))))})))

 (defn anim [animation]
   (cond 
     (fn? animation)
     animation
     
     (seq? animation)
     (-sequential (->> animation flatten (filter some?) (map anim)))

     (map? animation)
     (-parallel (update-vals animation anim))

     (instance? w/Animatable animation)
     (fn [_ dur]
       {:anim #(.transform animation %)
        :dur dur})
     
     (nil? animation)
     nil
     
     :else
     (fn [from dur]
       {:anim #(ut/lerp from animation %)
        :dur dur})))

(defn with [animation & {:keys [dur curve at]}] 
  (let [animation (anim animation)]
    (fn [value exp-dur]
      (let [is-absolute? (is-absolute-time? dur)
            min-dur (if (and is-absolute? (is-absolute-time? at)) (+ (t/duration dur) (t/duration at)) dur)
            duration (if (is-absolute-time? exp-dur)
                       exp-dur (or min-dur exp-dur))
            {:keys [anim dur]} (animation value duration)
            start (relative-time at duration)
            end (when (and start dur) (+ start (relative-time dur duration)))
            curve (or (when (and start end) (t/interval start end curve))
                      (t/curve (or curve :linear)))]
       {:anim #(anim (curve %))
        :dur duration}))))

 (defn from-to [from to & {:keys [dur curve at lerp] :as options}]
   (with (fn [_ exp-dur] 
           {:anim (if lerp (lerp from to) (ut/lerp from to))
            :dur exp-dur})
         options))

 (defn to [to & {:keys [dur curve at lerp] :as options}]
   (with (fn [from exp-dur]
           {:anim (if lerp (lerp from to) (ut/lerp from to))
            :dur exp-dur})
         options))
 
(defn ttt [] 
  (anim-cntr
   {:dur 500 :curve :ease-in-out}
   [{:color (from-to w/Color.red w/Colors.blue)
     :dx (from-to 24.0 0.0 :curve :ease-in-out)}
    {:color (to w/Colors.red)}]))
 