(ns flutter-cljd.widgets
  "The Flutter widgets framework. [Docs](https://api.flutter.dev/flutter/widgets/widgets-library.html)"
  (:require
   ["package:flutter/widgets.dart" :as w]
   [flutter-cljd.inherited-keys :as inh]
   [flutter-cljd.internal.builder :as bd]
   [flutter-cljd.internal.layout-builder :as lbd]
   [flutter-cljd.internal.button :as bt]
   [flutter-cljd.internal.padding :as pd]
   [flutter-cljd.internal.absorb-pointer :as ap]
   [flutter-cljd.internal.ignore-pointer :as ip]
   [flutter-cljd.internal.align :as al]
   [flutter-cljd.internal.aspect-ratio :as ar]
   [flutter-cljd.internal.block-semantics :as bs]
   [flutter-cljd.internal.banner :as bn]
   [flutter-cljd.internal.center :as cntr]
   [flutter-cljd.internal.clip-oval :as co]
   [flutter-cljd.internal.clip-rect :as cr]
   [flutter-cljd.internal.container :as cnt]
   [flutter-cljd.internal.colored :as cd]
   [flutter-cljd.internal.color-filtered :as cf]
   [flutter-cljd.internal.composited-transform :as ct]
   [flutter-cljd.internal.constraints-transformed :as ctr]
   [flutter-cljd.internal.flexible :as fx]
   [flutter-cljd.internal.expanded :as ex]
   [flutter-cljd.internal.column-row-flex :as crf]
   [flutter-cljd.internal.action-listener :as aclr]
   [flutter-cljd.internal.text :as txt]
   [flutter-cljd.internal.spacer :as sp]
   [flutter-cljd.internal.opacity :as op]
   [flutter-cljd.internal.stack :as st]
   [flutter-cljd.internal.sized :as sz]
   [flutter-cljd.internal.with-inherited :as wi]
   [flutter-cljd.internal.autocomplete-highlighted-index :as ahi]
   [flutter-cljd.internal.autofill-group :as afg]
   [flutter-cljd.internal.keep-alive :as ka]
   [flutter-cljd.internal.on-back-button :as obb]
   [flutter-cljd.internal.baseline :as bl]
   [flutter-cljd.internal.bottom-navigation-bar-item :as bnbi]
   [flutter-cljd.internal.shortcuts :as sc]
   [flutter-cljd.internal.actions :as act]
   [flutter-cljd.internal.checked-mode-banner :as cmb]
   [flutter-cljd.internal.clip-corners :as cc]
   [flutter-cljd.internal.custom-multi-child-layout :as cml]
   [flutter-cljd.internal.decorated :as dec]
   [flutter-cljd.internal.keyed :as kyd]
   [flutter-cljd.internal.with-text-style :as wts]
   [flutter-cljd.internal.on-change :as oc]
   [flutter-cljd.internal.animated :as an]
   [flutter-cljd.internal.on-state-actions :as osa]
   [flutter-cljd.internal.with-managed :as wm]
   [flutter-cljd.utils :as ut]
   [flutter-cljd.animations :as a]
   [flutter-cljd.internal.transformed :as tr]
   [flutter-cljd.internal.lifecycle-observer :as lco]
   [flutter-cljd.internal.on-visibility-change :as ovc]))

(defn absorb-pointer
  "A widget that absorbs pointers during hit testing. 
   It makes the widget and any underlying widgets impossible to interact with.
   If you want to disable the widget but keep the underlying widgets interactive, use `ignore-pointer`.

   When absorbing is true, this widget prevents its subtree from receiving pointer events by terminating hit testing at itself.
   It still consumes space during layout and paints its child as usual.
   It just prevents its children from being the target of located events, because it returns true from RenderBox.hitTest.

   Args:
    - absorbing: Whether the widget absorbs pointers. Default is `true`.
    - child: The child widget to be absorbed.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/AbsorbPointer-class.html)"
  ([absorbing child]
   (ap/absorb-pointer* absorbing child))
  ([child] (absorb-pointer true child)))

(defn ignore-pointer
  "A widget that is invisible during hit testing.

   When ignoring is true, this widget (and its subtree) is invisible to hit testing.
   It still consumes space during layout and paints its child as usual.
   It just cannot be the target of located events, because it returns false from RenderBox.hitTest.

    Args:
      - ignoring: Whether the widget ignores pointers. Default is `true`.
      - child: The child widget to be ignored.
  
   [Flutter docs](https://api.flutter.dev/flutter/widgets/IgnorePointer-class.html)"
  ([ignoring child]
   (ip/ignore-pointer* ignoring child))
  ([child] (ignore-pointer true child)))

(defn align
  "A widget that aligns its child within itself and optionally sizes itself based on the child's size.

   For example, to align a box at the bottom right, you would pass this box a tight constraint that is bigger than the child's natural size, with an alignment of `Alignment.bottomRight`.
   
   Args:
   - args: A map of arguments or an alignment or `Animation<AlignmentGeometry>`.
     - `:key` An identifier for the align widget.
     - `:alignment` (keyword or `Alignment` or `Animation<AlignmentGeometry>`, default: `Alignment.center`): The alignment of the child within the container.
        Possible keywords: `:top`, `:center`, `:bottom`, `:left`, `:right`, `:start`, `:end` and their combinations like `:top-left`.
     - `:width-factor` (number, default: nil): The width factor of the child.
     - `:height-factor` (number, default: nil): The height factor of the child.
     - `:animation` (map or number of seconds, default: nil): The animation options for the align widget.
       - `:duration` (number of seconds or map or Duration, default: 250): The duration of the animation.
       - `:curve` (keyword or Curve, default: :linear): The curve of the animation.
       - `:on-end` (function, default: nil): The callback function to be called when the animation ends.
   - child: The child widget to be aligned.

   ```clojure
   (align {:alignment :top-right :width-factor 0.4} (text \"Hello, World!\"))
   (align :top-right (text \"Hello, World!\"))
   ```

   [Flutter docs](https://api.flutter.dev/flutter/widgets/Align-class.html)

   [Animated flutter docs](https://api.flutter.dev/flutter/widgets/AnimatedAlign-class.html)
   
   [Transition flutter docs](https://api.flutter.dev/flutter/widgets/AlignTransition-class.html)"
  ([k0 v0 & args]
   (let [[args children] (ut/key-values-args-and-children (concat [k0 v0] args))]
     (al/align* args (first children))))
  ([args child]
   (al/align* args child)))

(defn aspect-ratio
  "A widget that attempts to size the child to a specific aspect ratio.

   The aspect ratio is expressed as a ratio of width to height.
   For example, a 16:9 width:height aspect ratio would have a value of 16.0/9.0.

   Args:
   - ratio: The aspect ratio to apply to the child.
   - child: The child widget to be sized.

   [Flutter docs](https://api.flutter.dev/flutter/widgets/AspectRatio-class.html)"
  [ratio child]
  (ar/aspect-ratio* ratio child))

(defn action-listener
  "A helper widget for making sure that listeners on an action are removed properly.
   
   Listeners on the Action class must have their listener callbacks removed with Action.removeActionListener when the listener is disposed of.
   This widget helps with that, by providing a lifetime for the connection between the listener and the Action, and by handling the adding and removing of the listener at the right points in the widget lifecycle.
   
   If you listen to an Action widget in a widget hierarchy, you should use this widget.
   If you are using an Action outside of a widget context, then you must call removeListener yourself.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/ActionListener-class.html)"
  [listener action child]
  (aclr/action-listener* listener action child))

(defn with-autocomplete-highlighted-index
  "An inherited widget used to indicate which autocomplete option should be highlighted for keyboard navigation.
   
   The RawAutoComplete widget will wrap the options view generated by the optionsViewBuilder with this widget to provide the highlighted option's index to the builder.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/AutocompleteHighlightedOption-class.html)"
  [option child]
  (ahi/with-autocomplete-highlighted-index* option child))

(defn autofill-group
  "An AutofillScope widget that groups AutofillClients together.

   AutofillClients that share the same closest AutofillGroup ancestor must be built together, and they be will be autofilled together.
   
   AutofillClients within the same AutofillScope are isolated from other input fields during autofill. That is, when an autofillable TextInputClient gains focus, only the AutofillClients within the same AutofillScope will be visible to the autofill service, in the same order as they appear in AutofillScope.autofillClients.
   
   AutofillScope also allows TextInput to redirect autofill values from the platform to the AutofillClient with the given identifier, by calling AutofillScope.getAutofillClient.
   
   An AutofillClient that's not tied to any AutofillScope will only participate in autofill if the autofill is directly triggered by its own TextInputClient.
   
   The AutofillGroup widget only knows about AutofillClients registered to it using the AutofillGroupState.register API. Typically, AutofillGroup will not pick up AutofillClients that are not mounted, for example, an AutofillClient within a Scrollable that has never been scrolled into the viewport. To workaround this problem, ensure clients in the same AutofillGroup are built together.
   
   The topmost AutofillGroup widgets (the ones that are closest to the root widget) can be used to clean up the current autofill context when the current autofill context is no longer relevant.
   
   An autofill context is a collection of input fields that live in the platform's text input plugin. The platform is encouraged to save the user input stored in the current autofill context before the context is destroyed, when TextInput.finishAutofillContext is called with shouldSave set to true.
   
   Currently, there can only be at most one autofill context at any given time. When any input field in an AutofillGroup requests for autofill (which is done automatically when an autofillable EditableText gains focus), the current autofill context will merge the content of that AutofillGroup into itself. When there isn't an existing autofill context, one will be created to hold the newly added input fields from the group.
   
   Once added to an autofill context, an input field will stay in the context until the context is destroyed. To prevent leaks, call TextInput.finishAutofillContext to signal the text input plugin that the user has finalized their input in the current autofill context. The platform text input plugin either encourages or discourages the platform from saving the user input based on the value of the shouldSave parameter. The platform usually shows a \"Save for autofill?\" prompt for user confirmation.
   
   By default, onDisposeAction is set to AutofillContextAction.commit, in which case when any of the topmost AutofillGroups is being disposed, the platform will be informed to save the user input from the current autofill context, then the current autofill context will be destroyed, to free resources. You can, for example, wrap a route that contains a Form full of autofillable input fields in an AutofillGroup, so the user input of the Form can be saved for future autofill by the platform.

   [Flutter docs](https://api.flutter.dev/flutter/widgets/AutofillGroup-class.html)"
  ([action child] (afg/autofill-group* action child))
  ([child] (afg/autofill-group* child)))

(defn keep-alive
  "Mark a child as needing to stay alive even when it's in a lazy list that would otherwise remove it.

   This widget is for use in a RenderAbstractViewports, such as Viewport or TwoDimensionalViewport.
   
   This widget is rarely used directly. The SliverChildBuilderDelegate and SliverChildListDelegate delegates, used with SliverList and SliverGrid, as well as the scroll view counterparts ListView and GridView, have an addAutomaticKeepAlives feature, which is enabled by default, and which causes AutomaticKeepAlive widgets to be inserted around each child, causing KeepAlive widgets to be automatically added and configured in response to KeepAliveNotifications.
   
   The same addAutomaticKeepAlives feature is supported by the TwoDimensionalChildBuilderDelegate and TwoDimensionalChildListDelegate.
   
   Therefore, to keep a widget alive, it is more common to use those notifications than to directly deal with KeepAlive widgets.
   
   In practice, the simplest way to deal with these notifications is to mix AutomaticKeepAliveClientMixin into one's State. See the documentation for that mixin class for details.
   
   You can pass `:auto` as the `alive` argument to use `AutomaticKeepAlive` widget.

   [Flutter docs](https://api.flutter.dev/flutter/widgets/KeepAlive-class.html)
   [AutomaticKeepAlive docs](https://api.flutter.dev/flutter/widgets/AutomaticKeepAlive-class.html)"
  ([alive child] (ka/keep-alive* alive child))
  ([child] (ka/keep-alive* child)))

(defn on-back-button
  "A convenience widget that registers a callback for when the back button is pressed.

   In order to use this widget, there must be an ancestor Router widget in the tree that has a RootBackButtonDispatcher. e.g. The Router widget created by the MaterialApp.router has a built-in RootBackButtonDispatcher by default.
   
   It only applies to platforms that accept back button clicks, such as Android.
   
   It can be useful for scenarios, in which you create a different state in your screen but don't want to use a new page for that.

   Args:
    - action: The action to be executed when the back button is pressed.
    - child: The child widget to be displayed.

   [Flutter docs](https://api.flutter.dev/flutter/widgets/BackButtonListener-class.html)"
  [action child]
  (obb/on-back-button* action child))

(defn banner
  "Displays a diagonal message above the corner of another widget.

   Useful for showing the execution mode of an app (e.g., that asserts are enabled.)

   Args:
    - args: A map of arguments for the banner widget.
      - `:key` An identifier for the banner.
      - `:child` The widget to show behind the banner.
      - `:message` The message to show in the banner.
      - `:location` (keyword or BannerLocation, default: :top-start): The location of the banner.
        Possible values: :top-start, :top-end, :bottom-start, :bottom-end.
      - `:layout-direction` (keyword or TextDirection, default: :ltr): The layout direction of the banner.
        Possible values: :ltr, :rtl.
      - `:text-direction` (keyword or TextDirection, default: :ltr): The direction of the text.
        Possible values: :ltr, :rtl.
      - `:color` (Color, default: 0xA0B71C1C): The color of the banner.
      - `:text-style` (TextStyle, default: TextStyle(color: Colors.white, fontSize: 12.0 * 0.85, fontWeight: FontWeight.w900, height: 1.0)): The text style of the banner.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/Banner-class.html)"
  ([k0 v0 & args]
   (let [[args children] (ut/key-values-args-and-children (concat [k0 v0] args))]
     (bn/banner* args (first children))))
  ([args child]
   (bn/banner* args child)))

(defn baseline
  "A widget that positions its child according to the child's baseline.
   
   This widget shifts the child down such that the child's baseline (or the bottom of the child, if the child has no baseline) is baseline logical pixels below the top of this box, then sizes this box to contain the child.
   If baseline is less than the distance from the top of the child to the baseline of the child, then the child is top-aligned instead.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/Baseline-class.html)"
  ([offset type child] (bl/baseline* offset type child))
  ([offset child] (bl/baseline* offset child)))

(defn block-semantics
  "A widget that drops the semantics of all widget that were painted before it in the same semantic container.

   This is useful to hide widgets from accessibility tools that are painted behind a certain widget, e.g. an alert should usually disallow interaction with any widget located \"behind\" the alert (even when they are still partially visible).
   Similarly, an open Drawer blocks interactions with any widget outside the drawer.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/BlockSemantics-class.html)"
  ([blocking child]
   (bs/block-semantics* blocking child))
  ([child] (block-semantics true child)))

(defn bottom-navigation-bar-item
  "An interactive button within either material's BottomNavigationBar or the iOS themed CupertinoTabBar with an icon and title.
   
   This class is rarely used in isolation. It is typically embedded in one of the bottom navigation widgets.
   
   Args:
    - args: A map of arguments for the bottom navigation bar item widget.
      - `:icon` The icon of the bottom navigation bar item. Required.
      - `:label` The label of the bottom navigation bar item.
      - `:active-icon` The active icon of the bottom navigation bar item.
      - `:background-color` The background color of the bottom navigation bar item.
      - `:tooltip` The tooltip of the bottom navigation bar item.
   
   [Flutter docs](https://api.flutter.dev/flutter/material/BottomNavigationBarItem-class.html)"
  ([& args]
   (let [[args _] (ut/key-values-args-and-children args)]
     (bnbi/bottom-navigation-bar-item* args))))

(defn builder
  "A stateless utility widget whose build method uses its builder callback to create the widget's child.
   
   Args:
    - builder: Called with the context and to build the widget.
    - child: The child widget to be wrapped by the builder widget. 
      When provided, the builder callback will be called with the child widget as the first argument and the context as the second argument.
   
   ```clojure
    (builder (fn [ctx] (text (str \"Hello, World!\" (.hasAppBar (Scaffold.of context))))))
   
   (->>
     (text \"Hello, World!\")
     (builder #(padding 10 %)))
   ```
   [Flutter docs](https://api.flutter.dev/flutter/widgets/Builder-class.html)"
  ([builder] (bd/builder* builder))
  ([builder child] (bd/builder* builder child)))

(defn with-transformed-inherited
  "A widget that transforms inherited bindings using the specified `transform` function.
   
   The `transform` function is called with the inherited bindings map as an argument and should return a new map of bindings.
   
   Args:
    - key: The key to be transformed in the inherited bindings. If not provided, the entire bindings map is transformed. Key may be a keyword or a map with the following keys:
      - `:key` (keyword): The key to be transformed.
      - `:default-value` (any): The default value to be transformed.
    - transform: The function to transform the inherited bindings.
    - child: The child widget to be wrapped by the transformed inherited widget.
   
   ```clojure
   (->>
     (text \"Hello, World!\")
     (with-transformed-inherited #(assoc % :theme :dark)))
   ```
   Some default keys are defined in the `flutter-cljd.inherited-keys` namespace.

   To access the inherited bindings, use `c/get-inherited` function."
  ([transform child] (wi/with-transformed-inherited* transform child))
  ([key transform & kts&child] (apply wi/with-transformed-inherited* key transform kts&child)))

(defn with-merged-inherited
  "A widget that merges the specified `bindings` with the inherited bindings.
   
   Args:
    - bindings: The bindings to be merged with the inherited bindings.
    - child: The child widget to be wrapped by the merged inherited widget.
   
   ```clojure
   (->>
     (text \"Hello, World!\")
     (with-merged-inherited {:theme :dark}))
   ```
   To access the inherited bindings, use `c/get-inherited` function."
  [bindings child]
  (wi/with-merged-inherited* bindings child))

(defn with-inherited
  "A widget that provides inherited values to its descendants.
   
   Args:
    - key values pairs to be inherited. Key may be a keyword or a map with the following keys:
      - `:key`: The key to be inherited.
      - `:default-value` (any): The value to be inherited.
      - `:merge` (fn [old new] new): The function to merge the new value with the existing one.
    - child: The child widget to be wrapped by the inherited widget.
   
   ```clojure
   (->>
     (text \"Hello, World!\")
     (with-inherited :theme :dark))
   
   (->>
     (text \"Hello, World!\")
     (button tap-fn)
     (with-inherited inh/enabled false))
   ```
   Some default keys are defined in the `flutter-cljd.inherited-keys` namespace.

   To modify the inherited bindings, use `with-transformed-inherited` widget.
   
   To access the inherited bindings, use `c/get-inherited` function."
  ([key child] (wi/with-inherited* key child))
  ([key value child] (wi/with-inherited* key value child))
  ([key0 value0 key1 value1 & kvs&child] (apply wi/with-inherited* key0 value0 key1 value1 kvs&child)))

(defn enabled
  "A widget that sets the `flutter-cljd.inherited-keys/enabled` inherited value"
  ([child] (enabled true child))
  ([value child]
   (with-inherited inh/enabled value child)))

(defn disabled
  "A widget that sets the `flutter-cljd.inherited-keys/enabled` inherited value to false"
  ([child] (disabled true child))
  ([value child]
   (with-inherited inh/enabled (not value) child)))

(defn shortcuts
  "A widget that creates keyboard shortcuts for its descendants.
   
   Shortcuts are key bindings that become actions when triggered. They are typically used to implement keyboard shortcuts for common operations.
   
   The shortcuts widget can be used in two ways:
   1. With a ShortcutManager instance that manages the shortcuts directly
   2. With a map of key combinations to actions
   
   Args:
    - shortcuts: A ShortcutManager instance or a map of key combinations to actions
    - args: A map of arguments for the shortcuts widget
      - `:debug-label` (string): A label used for debugging purposes
      - `:modal` (boolean): If true, prevents shortcuts from being handled by ancestors
      - `:include-semantics` (boolean, default: true): Whether to include semantics information
    - child: The widget below this widget in the tree
   
   The shortcuts map can contain:
   - Key combinations as vectors: `[:control \\W]`
   - Function keys as keywords: `:f1`
   - Values can be:
     - Intent instances
     - Keywords representing intents
     - Vectors with an intent and arguments: `[:some-intent arg1 arg2]`
     - Functions to be called directly: `#(print \"Key pressed\")`
   
   Example:
   ```clojure
   (shortcuts
     [:control \\W] :some-intent
     [:control \\C] [:some-intent some-arg]
     [:alt \\c] #(print \"ALT-C is pressed\")
     :f1 #(print \"F1 is pressed\")
     (text \"Hello, Shortcuts!\"))
   ```
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/Shortcuts-class.html)"
  ([k0 v0 & args]
   (let [child (last args)
         all (ut/key-values-map (concat [k0 v0] (drop-last args)))
         shortcuts (dissoc all :debug-label :modal :include-semantics)
         args (select-keys all [:debug-label :modal :include-semantics])]
     (sc/shortcuts* shortcuts args child))))

(defn actions
  "A widget that establishes an Actions widget scope in which the given actions are available.

  Actions are mapping of Intent keys to Action objects that defines how keys and other inputs map to actions.
  
  Args:
   - actions: A map of Intent keys to Action objects
   - dispatcher: Optional ActionDispatcher that invokes actions
   - child: The widget below this widget in the tree
  
  The actions map can contain:
   - Intent instances as keys
   - Action instances as values
   - Functions as values that will be wrapped in Actions
   
  Example:
  ```clojure
  (actions
    {some-intent (m/CallbackAction .onInvoke #(print \"Action invoked\"))}
    (text \"Hello, Actions!\"))
  ```

  [Flutter docs](https://api.flutter.dev/flutter/widgets/Actions-class.html)"
  ([actions dispatcher child]
   (act/actions* actions dispatcher child))
  ([actions child]
   (actions actions nil child)))

(defn button
  "A universal button.
 
  A button is a widget that responds to touch events. When the user touches the button, 
  the button is highlighted and then invokes the `on-tap` callback.
  
  Args: a map of arguments or a function called when the button is tapped.

    - `:key` - A widget key.
    - `:on-tap` - Executed when the button is tapped
    - `:on-tap-down` - Executed when the button is pressed down
    - `:on-tap-up` - Executed when the button press is released
    - `:on-tap-cancel` - Executed when the button tap is canceled
    - `:on-double-tap` - Executed on double-tap
    - `:on-long-press` - Executed when button is held down
    - `:on-secondary-tap` - Executed on secondary tap (e.g. right click)
    - `:on-secondary-tap-up` - Executed when secondary tap is released
    - `:on-secondary-tap-down` - Executed when secondary tap begins
    - `:on-secondary-tap-cancel` - Executed when secondary tap is canceled
    - `:on-highlight-changed` - Executed when button highlight state changes
    - `:on-hover` - Executed when pointer hovers over button
    - `:on-focus-change` - Executed when focus state changes
    - `:focus-node` - Custom focus node for the button
    - `:mouse-cursor` - Mouse cursor to display on hover
  
    Inherited properties (can be set via `with-inherited` or passed directly):
    - `:enabled` - Whether the button is interactive
    - `:enable-feedback` - Whether to show visual/haptic feedback
    - `:exclude-from-semantics` - Whether to exclude from accessibility tree
    - `:can-request-focus` - Whether button can receive focus
    - `:autofocus` - Whether button should automatically receive focus
  
    Button Context:
    The `:button-context` provides state information as a map with:
    - `:context` - The BuildContext of the button widget
    - `:state` - Set of current button state values. Possible values in the set are `:disable`, `:pressed`, `:hovered`, `:focused`. For example: `#{:hovered :pressed}`
    - `:prev-state` - Set of previous button state values
    - `:local-offset` - Local coordinates of touch (Offset?)  
    - `:global-offset` - Global coordinates of touch (Offset?)
  
  Styling:
  The Button supports custom styling via the `flutter-cljd.inherited-keys/button-modifier` inherited key, which accepts a function in this format:
  (fn [child button-context] modified-child). 
  You can set the button modifier using the `with-button-modifier` widget.
  
  To avoid unnecessary widget rebuilds, define your modifier functions using `defn` rather than creating anonymous functions inline.
  
  Also button injects `flutter-cljd.inherited-keys/button-context` into its child widget, so you can access the button context in your child widget and use it for custom styling or other purposes.

  Examples:
  
  ```clojure
  (->> (text \"Click me!\")
       (button #(print \"Button clicked!\")))
    
  (->> (text \"Interact with me\")
     (button {:on-tap #(print \"Button clicked!\")
              :on-long-press #(print \"Long pressed\")
              :on-hover #(print \"Hovered\")}))
    
   (defn custom-style [button btn-ctx]
     (let [state (:state btn-ctx)
        disabled? (state :disable)
        pressed? (state :pressed)]
    (opacity
     (if disabled? 0.5 (if pressed? 0.8 1.0))
     button)))
  
  (->> (text \"Custom style\")
      (button #(print \"Button clicked!\"))
      (with-button-modifier custom-style))
  
  (->> (text \"Disabled\")
     (button #(print \"Won't be called\"))
     (disabled))
  
  (defn my-button [title on-tap]
     (->>
       (widget->>
         :get {:button-context btn-ctx}
         :let [state (:state btn-ctx)]
         (text title)
         (opacity (if (state :pressed) 0.8 1)))
       (button on-tap)
       (without-button-modifier)))
  ```"
  ([k0 v0 & args]
   (if (fn? k0)
     (bt/button* k0 (ut/key-values-map (cons v0 (drop-last args))) (last args))
     (let [[args [child]] (ut/key-values-args-and-children (concat [k0 v0] args))]
       (bt/button* args child))))
  ([args child] (bt/button* args child)))

(defn with-button-modifier
  "A widget that provides a custom button modifier to its descendants.
  
   The `modifier` function is called with the child widget and the button context as arguments and should return a modified child widget.
  
   Args:
    - modifier: The function to modify the button widget. The function should have the following signature:
      (fn [child button-context] modified-child)
    - child: The child widget to be wrapped by the modified button widget.

    Button Context:
    The button context provides state information as a map with:
    - `:context` - The BuildContext of the button widget
    - `:state` - Set of current button state values. Possible values in the set are `:disable`, `:pressed`, `:hovered`, `:focused`. For example: `#{:hovered :pressed}`
    - `:prev-state` - Set of previous button state values
    - `:local-offset` - Local coordinates of touch (Offset?)  
    - `:global-offset` - Global coordinates of touch (Offset?)

   ```clojure
   (defn highlighted-button [button btn-ctx]
     (let [state (:state btn-ctx)
           pressed? (state :pressed)]
       (opacity (if pressed? 0.8 1) button)))

   (->>
     (text \"Click me!\")
     (button #(print \"Button clicked!\"))
     (with-button-modifier highlighted-button))
   ```
   To avoid unnecessary widget rebuilds, define your modifier functions using `defn` rather than creating anonymous functions inline."
  [modifier child]
  (bt/with-button-modifier* modifier child))

(defn without-button-modifier
  "A widget that removes the button modifier from its descendants."
  [child]
  (bt/without-button-modifier* child))

(defn center
  "A widget that centers its child within itself.

   This widget will be as big as possible if its dimensions are constrained and :width-factor and :height-factor are nil.
   If a dimension is unconstrained and the corresponding size factor is null then the widget will match its child's size in that dimension.
   If a size factor is non-null then the corresponding dimension of this widget will be the product of the child's dimension and the size factor.
   For example if :width-factor is 2.0 then the width of this widget will always be twice its child's width.
   
   ```clojure
   (center (text \"Hello, World!\"))
   (center :width-factor 2.0 :height-factor 2.0 (text \"Hello, World!\"))
   ```

   [Flutter docs](https://api.flutter.dev/flutter/widgets/Center-class.html)"
  [arg0 & args]
  (let [[args children] (ut/key-values-args-and-children (cons arg0 args))]
    (cntr/center* args (last children))))

(defn checked-mode-banner
  "A banner that shows the current checked mode.

   Displays a Banner saying \"DEBUG\" when running in debug mode. MaterialApp builds one of these by default.
   This is useful for indicating that an app is running in debug mode, which may include additional debugging
   features or behavior that shouldn't appear in release builds.

   Does nothing in release mode, making it safe to leave in place in production code.
   
   Args:
    - child: The widget below this widget in the tree that will have the debug banner displayed over it
   
   Example:
   ```clojure
   (checked-mode-banner
     (scaffold
       (body (text \"Hello World!\"))))
   ```
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/CheckedModeBanner-class.html)"
  [child]
  (cmb/checked-mode-banner* child))

(defn clip-oval
  "A widget that clips its child using an oval.
   
   By default, inscribes an axis-aligned oval into its layout dimensions and prevents its child from painting outside that oval, but the size and location of the clip oval can be customized using a custom clipper.

   Args: 
    - args: A map of arguments for the clip oval widget.
      - `:key` An identifier for the clip oval.
      - `:clip-behavior` (keyword, default: :clip): The behavior of the clip.
        Possible values: :clip, :anti-alias, :anti-alias-with-save-layer, :hard-edge.
      - `:clipper` (CustomClipper): The custom clipper to use for clipping.
    - child: The child widget
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/ClipOval-class.html)"
  ([v0 & args] (let [[args [child]] (ut/key-values-args-and-children (cons v0 args))]
                 (co/clip-oval* args child)))
  ([child] (co/clip-oval* {} child)))

(defn clip-rect
  "A widget that clips its child using a rectangle.

   By default, inscribes an axis-aligned rectangle into its layout dimensions and prevents its child from painting outside that rectangle, but the size and location of the clip rectangle can be customized using a custom clipper.

   Args:
    - args: A map of arguments for the clip rect widget.
      - `:key` An identifier for the clip rect.
      - `:clip-behavior` (keyword, default: :clip): The behavior of the clip.
        Possible values: :clip, :anti-alias, :anti-alias-with-save-layer, :hard-edge.
      - `:clipper` (CustomClipper): The custom clipper to use for clipping.
    - child: The child widget

   [Flutter docs](https://api.flutter.dev/flutter/widgets/ClipRect-class.html)"
  ([v0 & args] (let [[args [child]] (ut/key-values-args-and-children (cons v0 args))]
                 (cr/clip-rect* args child)))
  ([child] (cr/clip-rect* {} child)))

(defn clip-corners
  "A widget that clips its child using rounded corners.

   This widget takes a child and clips it using a rounded rectangle border radius.
   It's useful for creating rounded corners on any widget.

   Args:
    - radius: The border radius specification. Can be provided in several formats:
      - A single number for uniform circular corners
      - A map specifying individual corners
      - A sequence of [x y] values for elliptical corners
    
   The radius map supports these keys:
    - Individual corners: `:top-left`, `:top-right`, `:bottom-left`, `:bottom-right`
    - Shorthand pairs: `:left-top`, `:right-top`, `:left-bottom`, `:right-bottom`  
    - Side groups: `:left`, `:right`, `:top`, `:bottom`
    - Directional: `:start`, `:end`
    - Single letter: `:t`, `:b`, `:l`, `:r`, `:s`, `:e`
    - `:all` for all corners
    - `:x`/`:y` for elliptical corners

   Examples:
   ```clojure
   ;; Uniform circular corners
   (clip-corners 4 
     (colored :blue 
       (sized 100 
         (center (text \"Hello\")))))

   ;; Different corners
   (clip-corners :top-left 4 :top-right 8
     (container {:color :blue}
       (text \"Hello\")))

   ;; Shorthand for sides
   (clip-corners {:l 4 :r 8} 
     (colored :blue
       (text \"Hello\")))

   ;; Elliptical corners
   (clip-corners {:x 4 :y 8}
     (container {:color :blue}
       (text \"Hello\")))

   ;; Using a sequence
   (clip-corners [4 8]
     (colored :blue
       (text \"Hello\")))

   ;; Mixed radii with fallback
   (clip-corners {:top-left 4 :all 8}
     (container {:color :blue}
       (text \"Hello\")))
   ```

   [Flutter docs](https://api.flutter.dev/flutter/widgets/ClipRRect-class.html)"
  ([k0 v0 & args]
   (let [[args [child]] (ut/key-values-args-and-children (concat [k0 v0] args))]
     (cc/clip-corners* args child)))
  ([radius child]
   (cc/clip-corners* radius child)))

(defn colored
  "A widget that paints its child with a specified color.
  
     The color is painted as a solid color, with no transparency.
     The child is painted using the specified color as if it was composited with an opaque version of the child.
     The color is not blended with the child.
  
     ```clojure
     (colored m/Colors.red (text \"Hello, World!\"))
     (colored :red (text \"Hello, World!\"))
     (colored 0xFF0000FF (text \"Hello, World!\"))
     ```
     [Flutter docs](https://api.flutter.dev/flutter/widgets/ColoredBox-class.html)"
  ([value] (cd/colored* value))
  ([clr child] (cd/colored* clr child)))

(defn color-filtered
  "Applies a ColorFilter to its child.
   
   This widget applies a function independently to each pixel of child's content, according to the ColorFilter specified.
   Use the ColorFilter.mode constructor to apply a Color using a BlendMode.
   Use the BackdropFilter widget instead, if the ColorFilter needs to be applied onto the content beneath child."
  ([filter child]
   (cf/color-filtered* filter child)))

(defn column
  "Creates a column widget with the specified arguments and children.

  Args:
  - args: A map of arguments for the column widget.
    - `:key` An identifier for the column. 
    - `:spacing` (number, default: 0): The spacing between each child widget.
    - `:main-axis-alignment` (keyword, default: :start): The alignment of the children along the main axis.
      Possible values: :center, :start, :end, :space-between, :space-around.
    - `:main-axis-size` (keyword, default: :min): The size of the column in the main axis.
      Possible values: :max, :min.
    - `:cross-axis-alignment` (keyword, default: :center): The alignment of the children along the cross axis.
      Possible values: :center, :start, :end, :stretch, :baseline.
    - `:text-direction` (keyword, default: :ltr): The direction of the text.
      Possible values: :ltr, :rtl.
    - `:text-baseline` (keyword, default: :alphabetic): The baseline alignment for the text.
      Possible values: :alphabetic, :ideographic.
    - `:vertical-direction` (keyword, default: :down): The direction in which the children are placed vertically.
      Possible values: :top, :down.

  - children: The child widgets to be placed in the column. Can contain nested lists of children.
   
   ```clojure
   (column :main-axis-alignment :center :spacing 10
    (text \"Hello, World!\"))
   ```

  Returns:
  A column widget with the specified arguments and children."
  ([] (column {}))
  ([args & children]
   (let [[args children] (ut/key-values-args-and-children (cons args children))]
     (crf/column* args children))))

(defn composited-transform-follower
  "A widget that follows a `composited-transform-target`.

   When this widget is composited during the compositing phase (which comes after the paint phase, as described in WidgetsBinding.drawFrame), it applies a transformation that brings targetAnchor of the linked CompositedTransformTarget and followerAnchor of this widget together.
   The two anchor points will have the same global coordinates, unless offset is not Offset.zero, in which case followerAnchor will be offset by offset in the linked CompositedTransformTarget's coordinate space.

   The `LayerLink` object used as the link must be the same object as that provided to the matching `composited-transform-target`
   
   The `composited-transform-target` must come earlier in the paint order than this `composited-transform-follower`

   Hit testing on descendants of this widget will only work if the target position is within the box that this widget's parent considers to be hittable.
   If the parent covers the screen, this is trivially achievable, so this widget is usually used as the root of an OverlayEntry in an app-wide Overlay (e.g. as created by the MaterialApp widget's Navigator).
   
   Args:
   - args: A map of arguments for the composited transform follower widget or a `LayerLink` object.
     - `:key` An identifier for the composited transform follower.
     - `:link` The LayerLink object that the follower will follow.
     - `:show-when-unlinked` (boolean, default: true): Whether to show the child when the link is not linked.
     - `:offset` (Offset, default: Offset.zero): The offset to apply to the link's target anchor.
     - `:target-anchor` (Alignment, default: Alignment.topLeft): The alignment of the target anchor relative to the size of the linked `composited-transform-target`
     - `:follower-anchor` (Alignment, default: Alignment.topLeft): The alignment of this widget's anchor relative to its size.
   
   ```clojure
   (composited-transform-follower link (text \"Hello, World!\"))
   ```

   [Flutter docs](https://api.flutter.dev/flutter/widgets/CompositedTransformFollower-class.html)"
  [args child & more]
  (let [[args children] (ut/key-values-args-and-children (cons args (cons child more)))]
    (ct/composited-transform-follower* args (last children))))

(defn composited-transform-target
  "A widget that can be targeted by a `composited-transform-follower`

   When this widget is composited during the compositing phase (which comes after the paint phase, as described in WidgetsBinding.drawFrame),
   it updates the link object so that any `composited-transform-follower` widgets that are subsequently composited in the same frame and were given the same LayerLink can position themselves at the same screen location.

   A single CompositedTransformTarget can be followed by multiple `composited-transform-follower` widgets.

   The CompositedTransformTarget must come earlier in the paint order than any linked `composited-transform-follower`.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/CompositedTransformTarget-class.html)"
  [link child]
  (ct/composited-transform-target* link child))

;; TODO: Extend support for .constraintsTransform
(defn constraints-transformed
  "A container widget that applies an arbitrary transform to its constraints, and sizes its child using the resulting `BoxConstraints`, optionally clipping, or treating the overflow as an error.

   This container sizes its child using a `BoxConstraints` created by applying `:transform` to its own constraints.
   This container will then attempt to adopt the same size, within the limits of its own constraints.
   If it ends up with a different size, it will align the child based on alignment.
   If the container cannot expand enough to accommodate the entire child, the child will be clipped if `:clip` is not `:none`.

   In debug mode, if `:clip` is `:none` and the child overflows the container, a warning will be printed on the console, and black and yellow striped areas will appear where the overflow occurs.

   When child is nil, this widget becomes as small as possible and never overflows.

   This widget can be used to ensure some of child's natural dimensions are honored, and get an early warning otherwise during development.
   For instance, if child requires a minimum height to fully display its content, `:transform` can be set to `maxHeightUnconstrained`,
   so that if the parent `RenderObject` fails to provide enough vertical space, a warning will be displayed in debug mode, while still allowing child to grow vertically
   
   Args:
    - args: A map of arguments for the constraints transformed box widget or a transform function.
      - `:key` An identifier for the constraints transformed box.
      - `:text-direction` (keyword, default: :ltr): The direction of the text. Possible values: :ltr, :rtl.
      - `:alignment` (Alignment, default: Alignment.center): The alignment of the child within the container.
      - `:transform` (BoxConstraints -> BoxConstraints): The transform to apply to the constraints. 
      - `:clip` (keyword, default: :none): The clip behavior of the child. Possible values: :none, :hard-edge, :anti-alias, :anti-alias-with-save-layer.
      - `:debug-transform-type` (string, default: \"\"): The type of transform to use for debugging.
    - child: The child widget to be displayed.

   [Flutter docs](https://api.flutter.dev/flutter/widgets/ConstraintsTransformBox-class.html)"
  [arg0 & args]
  (let [[args children] (ut/key-values-args-and-children (cons arg0 args))]
    (ctr/constraints-transformed* args (last children))))


(defn container 
  ""
  ([] (cnt/container*))
  ([child] (cnt/container* child))
  ([& args]
   (let [[args children] (ut/key-values-args-and-children args)]
     (cnt/container* args (last children)))))

(defn custom-multi-child-layout
  "A widget that uses a delegate to size and position multiple children.

  The delegate can determine the layout constraints for each child and can
  decide where to position each child. The delegate can also determine the size of
  the parent, but the size of the parent cannot depend on the children's sizes.

  Args:
   - delegate: A MultiChildLayoutDelegate that controls the layout of the children
   - children: The widgets below this widget in the tree

  The delegate argument must not be null.

  Example:
  ```clojure
  (deftype MyDelegate []
    :extends m/MultiChildLayoutDelegate
    
    (performLayout [size]
      (let [child1-size (.layoutChild this \"child1\" size)
            child2-size (.layoutChild this \"child2\" size)]
        (.positionChild this \"child1\" (m/Offset 0 0))
        (.positionChild this \"child2\" (m/Offset 100 100))))
    
    (shouldRelayout [_ old-delegate] true))

  (custom-multi-child-layout
    (MyDelegate.)
    (positioned {:key \"child1\"} (text \"Child 1\"))
    (positioned {:key \"child2\"} (text \"Child 2\")))
  ```

  [Flutter docs](https://api.flutter.dev/flutter/widgets/CustomMultiChildLayout-class.html)"
  [delegate & children]
  (apply cml/custom-multi-child-layout* delegate children))

(defn expanded
  "A widget that expands a child of a Row, Column, or Flex so that the child fills the available space.
   
   Using an Expanded widget makes a child of a Row, Column, or Flex expand to fill the available space along the main axis (e.g., horizontally for a Row or vertically for a Column).
   If multiple children are expanded, the available space is divided among them according to the flex factor.
   
   An Expanded widget must be a descendant of a Row, Column, or Flex, and the path from the Expanded widget to its enclosing Row, Column, or Flex must contain only StatelessWidgets or StatefulWidgets (not other kinds of widgets, like RenderObjectWidgets).
   
   ```clojure
   (row (expanded (text \"Hello, World!\")))
   (column (expanded 2 (text \"Hello, World!\")))
   ```

   [Flutter docs](https://api.flutter.dev/flutter/widgets/Expanded-class.html)"
  ([child] (ex/expanded* child))
  ([flex child] (ex/expanded* flex child)))

(defn flex
  "A widget that displays its children in a one-dimensional array.

   The Flex widget allows you to control the axis along which the children are placed (horizontal or vertical).
   This is referred to as the main axis. If you know the main axis in advance, then consider using a Row (if it's horizontal) or Column (if it's vertical) instead, because that will be less verbose.

   To cause a child to expand to fill the available space in the direction of this widget's main axis, wrap the child in an Expanded widget.

   The Flex widget does not scroll (and in general it is considered an error to have more children in a Flex than will fit in the available room). If you have some widgets and want them to be able to scroll if there is insufficient room, consider using a ListView.

   The Flex widget does not allow its children to wrap across multiple horizontal or vertical runs. For a widget that allows its children to wrap, consider using the Wrap widget instead of Flex.

   If you only have one child, then rather than using Flex, Row, or Column, consider using Align or Center to position the child.
   
   Args:
    - `:key` An identifier for the flex.
    - `:spacing` (number, default: 0): The spacing between each child widget.
    - `:direction` (Axis, default: Axis.horizontal): The axis along which the children are placed.
    - `:main-axis-alignment` (keyword or MainAxisAlignment, default: `:start`): The alignment of the children along the main axis.
      Possible values: `:center`, `:start`, `:end`, `:space-between`, `:space-around`.
    - `:main-axis-size` (keyword or MainAxisSize, default: `:min`): The size of the flex in the main axis.
      Possible values: `:max`, `:min`.
    - `:cross-axis-alignment` (keyword or CrossAxisAlignment, default: `:center`): The alignment of the children along the cross axis.
      Possible values: `:center`, `:start`, `:end`, `:stretch`, `:baseline`.
    - `:text-direction` (keyword or TextDirection, default: `:ltr`): The direction of the text.
      Possible values: `:ltr`, `:rtl`.
    - `:text-baseline` (keyword or TextBaseline, default: `:alphabetic`): The baseline alignment for the text.
      Possible values: `:alphabetic`, `:ideographic`.
    - `:vertical-direction` (keyword or VerticalDirection, default: `:down`): The direction in which the children are placed vertically.
      Possible values: `:top`, `:down`.
    - `:clip-behavior` (keyword or Clip, default: `:none`): The clip
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/Flex-class.html)"
  ([direction] (crf/flex* direction {} []))
  ([direction & args-children]
   (let [[args children] (ut/key-values-args-and-children args-children)]
     (crf/flex* direction args children))))

(defn flexible
  "A widget that controls how a child of a `row`, `column`, or `flex` flexes.
   
   Using a `flexible` widget gives a child of a `row`, `column`, or `flex` 
   the flexibility to expand to fill the available space in the main axis (e.g., horizontally for a `row` or vertically for a `column`), but, 
   unlike `expanded`, `flexible` does not require the child to fill the available space.
   
   Args:
    - `:flex` (number, default: 1): The flex factor to use for this child.
    - `:fit` (FlexFit, default: `:loose`): How the child is inscribed into the available space.
      Possible values: `:tight`, `:loose`.
    - `child`: The child widget to be flexed.

   A `flexible` widget must be a descendant of a `row`, `column`, or `flex`, and the path from the `flexible` widget to its enclosing `row`, `column` or `flex` must contain only `StatelessWidget`s or `StatefulWidget`s (not other kinds of widgets, like `RenderObjectWidget`s)."
  ([k0 v0 & args]
   (let [[args children] (ut/key-values-args-and-children (concat [k0 v0] args))]
     (fx/flexible* args (last children))))
  ([child]
   (flexible {} child)))

(defn layout-builder
  "Builds a widget tree that can depend on the parent widget's size.

   Similar to the `builder` except that the framework calls the builder function at layout time and provides the parent widget's constraints. This is useful when the parent constrains the child's size and doesn't depend on the child's intrinsic size. The LayoutBuilder's final size will match its child's size.

   The builder function is called in the following situations:

   The first time the widget is laid out.
    - When the parent widget passes different layout constraints.
    - When the parent widget updates this widget. 
    - When the dependencies that the builder function subscribes to change. 
   
   The builder function is not called during layout if the parent passes the same constraints repeatedly."
  [builder]
  (lbd/layout-builder* builder))

(defn row
  "A widget that displays its children in a horizontal array.

   To cause a child to expand to fill the available horizontal space, wrap the child in an Expanded widget.

   The Row widget does not scroll (and in general it is considered an error to have more children in a Row than will fit in the available room).
   If you have a line of widgets and want them to be able to scroll if there is insufficient room, consider using a ListView.

   For a vertical variant, see `column`.

   If you only have one child, then consider using Align or Center to position the child.

   By default, `:cross-axis-alignment` is `:center`, which centers the children in the vertical axis. If several of the children contain text, this is likely to make them visually misaligned if they have different font metrics (for example because they differ in TextStyle.fontSize or other TextStyle properties, or because they use different fonts due to being written in different scripts). Consider using `:cross-axis-alignment` `:baseline` instead.
   
   Args:
    - `:key` An identifier for the row.
    - `:spacing` (number, default: 0): The spacing between each child widget.
    - `:main-axis-alignment` (keyword or MainAxisAlignment, default: `:start`): The alignment of the children along the main axis.
      Possible values: `:center`, `:start`, `:end`, `:space-between`, `:space-around`.
    - `:main-axis-size` (keyword or MainAxisSize, default: :min): The size of the row in the main axis.
      Possible values: :max, :min.
    - `:cross-axis-alignment` (keyword or CrossAxisAlignment, default: `:center`): The alignment of the children along the cross axis.
      Possible values: `:center`, `:start`, `:end`, `:stretch`, `:baseline`.
    - `:text-direction` (keyword or TextDirection, default: `:ltr`): The direction of the text.
      Possible values: `:ltr`, `:rtl`.
    - `:text-baseline` (keyword or TextBaseline, default: `:alphabetic`): The baseline alignment for the text.
      Possible values: `:alphabetic`, `:ideographic`.
    - `:vertical-direction` (keyword or VerticalDirection, default: `:down`): The direction in which the children are placed vertically.
        Possible values: `:top`, `:down`.
   
   ```clojure
    (row {:main-axis-alignment :center :spacing 10} 
      (text \"Hello, World!\")
      (text \"This is a row!\"))
    ```
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/Row-class.html)"
  ([] (row {}))
  ([& args-children]
   (let [[args children] (ut/key-values-args-and-children args-children)]
     (crf/row* args children))))

(defn- any-sized [args fun]
  (let [[args child] (if (or (nil? (last args)) (instance? w/Widget (last args)))
                       [(drop-last args) (last args)]
                       [args nil])]
    (case (count args)
      0 (fun {} child)
      1 (fun (first args) child)
      2 (if (keyword? (first args))
          (fun {(first args) (second args)} child)
          (fun {:w (first args) :h (second args)} child))
      (fun (apply hash-map args) child))))

(defn sized
  "Creates a `ConstrainedBox` widget with the specified constraints and child.\\
   The size can be specified as a number, a map, key-values pairs, Size, BoxConstraints or two values.\\
   Examples:
   ```clojure
   (sized 100)
   (sized {:width 100 :height 200})
   (sized 100 200)
   (sized :w 100 :h 200)
   (sized [100 200])
   (sized {:min-width 100 :max-width 200})
   (sized {:min-height 100 :max-height 200})
   (sized :min-width 100 :max-width 200 :min-height 100 :max-height 200)
   (sized :width {:min 100 :max 200})
   ```
   If the size argument is a map, the keys `:width`, `:w`, `:height`, `:min-w`, `:max-height`, `:size`, etc are used to specify the width and height.\\
   If the size argument is a vector of two values, the first number is used for the width and the second number is used for the height.\\
   Width and height may be a numbers or a map of `:min` and `:max` values.
    
   Check `box-constraints` function for more information on how to create constraints.
  
   [Flutter docs](https://api.flutter.dev/flutter/widgets/ConstrainedBox-class.html)"
  ([] (sz/sized* {} nil))
  ([& args] (any-sized args sz/sized*)))

(defn fractionally-sized
  "Creates a `FractionallySizedBox` widget with the specified width and height factors and child.\\
   The width and height factors are numbers between 0.0 and 1.0.\\
   Examples:
   ```clojure
   (fractionally-sized 0.5 0.5)
   (fractionally-sized :width 0.5 :height 0.5)
   ```
   [Flutter docs](https://api.flutter.dev/flutter/widgets/FractionallySizedBox-class.html)"
  ([] (sz/fractionally-sized* {} nil))
  ([& args] (any-sized args sz/fractionally-sized*)))

(defn spacer
  "Spacer creates an adjustable, empty spacer that can be used to tune the spacing between widgets in a Flex container, like Row or Column.

   The Spacer widget will take up any available space, so setting the Flex.mainAxisAlignment on a flex container that contains a Spacer to MainAxisAlignment.spaceAround, MainAxisAlignment.spaceBetween, or MainAxisAlignment.spaceEvenly will not have any visible effect: the Spacer has taken up all of the additional space, therefore there is none left to redistribute."
  ([] (sp/spacer* 1))
  ([flex] (sp/spacer* flex)))

(defn stack
  "A widget that positions its children relative to the edges of its box.
   
   This class is useful if you want to overlap several children in a simple way, for example having some text and an image, overlaid with a gradient and a button attached to the bottom.
   
   [Flutter doc](https://api.flutter.dev/flutter/widgets/Stack-class.html)"
  ([] (st/stack* []))
  ([& children] (st/stack* children)))

(defn opacity
  "A widget that makes its child partially transparent.
   
   This class paints its child into an intermediate buffer and then blends the child back into the scene partially transparent.
   
   For values of opacity other than 0.0 and 1.0, this class is relatively expensive because it requires painting the child into an intermediate buffer. For the value 0.0, the child is not painted at all. 
   
   For the value 1.0, the child is painted immediately without an intermediate buffer.
   
   ```clojure
   (opacity 0.5 (text \"Hello, World!\"))
   (opacity 0.5 :always-include-semantics true (text \"Hello, World!\"))
   ```

   [Flutter docs](https://api.flutter.dev/flutter/widgets/Opacity-class.html)"
  [opacity & args]
  (let [[args [child]] (ut/key-values-args-and-children args)]
    (op/opacity* opacity args child)))

(defn decorated
  "A widget that paints a Decoration either before or after its child paints.

  Args:
   - with-decoration: A map describing the decoration to paint.
     Common decoration properties include:
     - `:position` - The position of the decoration relative to the child. Can be `DecorationPosition.background` (default) or `DecorationPosition.foreground`.
     - `:color` - The color to fill the decoration
     - `:border` - Border properties like width, color, style
     - `:border-radius` - Corner radius values
     - `:box-shadow` - Shadow effects
     - `:gradient` - Linear or radial color gradients
     - `:image` - Background image
   - child: The widget to decorate

  The decoration position determines whether to paint the decoration before the child
  (background) or after the child (foreground).

  Examples:
  ```clojure
  ;; Simple colored background
  (decorated {:color :blue} 
    (text \"Hello\"))

  ;; Rounded corners and border
  (decorated :border-radius 8
             :border {:width 2 :color :black}
    (text \"Hello\"))
    
  ;; Gradient background with shadow
  (decorated {:gradient {:colors [:blue :green]
                        :begin :top-left
                        :end :bottom-right}
              :box-shadow [{:color :black
                           :blur-radius 10}]}
    (text \"Hello\"))

  ;; Foreground decoration
  (decorated :position m/DecorationPosition.foreground 
             :gradient {:colors [:transparent :black]}
    (image \"background.jpg\"))
  ```

  [Flutter docs](https://api.flutter.dev/flutter/widgets/DecoratedBox-class.html)"
  ([] (dec/decorated* {} nil))
  ([& args]
   (let [[args children] (ut/key-values-args-and-children args)
         position (get args :position)]
     (if position
       (dec/decorated* position args (last children))
       (dec/decorated* args (last children))))))

(defn keyed
  "A widget that assigns a key to a child widget.

  The KeyedSubtree widget is useful when you want to give a specific key to a widget
  in the tree. This is often used when you need to maintain the state of a specific
  widget across rebuilds, or when you need to uniquely identify a widget for testing
  or animation purposes.

  Args:
   - key: The key to assign to the child widget. Can be any value that can be
          converted to a Key using widget-key.
   - child: The widget to assign the key to.

  Example:
  ```clojure
  ;; Assign a key to a text widget
  (keyed :my-text
    (text \"Hello World\"))

  ;; Use with a stateful widget to preserve state
  (keyed \"counter-1\"
    (stateful-widget
      (counter-widget)))
  ```

  [Flutter docs](https://api.flutter.dev/flutter/widgets/KeyedSubtree-class.html)"
  [key child]
  (kyd/keyed* key child))

(defn padding
  "Creates a Padding widget with the specified padding and child.
     The padding can be specified as a number, a map or key-value pairs of insets, or four numbers.
     Examples:
     ```clojure
     (padding 8 child) ;; Padding(padding: EdgeInsets.all(8))
     (padding {:all 8} child) ;; Padding(padding: EdgeInsets.all(8))
     (padding {:left 8 :right 16} child) ;; Padding(padding: EdgeInsets.only(left: 8, right: 16))
     (padding [8 16 24 32] child) ;; Padding(padding: EdgeInsets.fromLTRB(8, 16, 24, 32))
     (padding (insets 8) child) ;; Padding(padding: EdgeInsets.all(8))
     ```
     If the padding argument is a map, the keys :all, :left, :right, :start, :end, :vertical, :horizontal, :top, and :bottom are used to specify the padding.
     If the padding argument is a vector of four numbers, the numbers are used for the left, top, right, and bottom padding."
  ([arg0 & args]
   (cond
     (keyword? arg0)
     (let [[args children] (ut/key-values-args-and-children (cons arg0 args))]
       (pd/padding* args (last children)))

     (= 1 (count args))
     (pd/padding* arg0 (first args))

     :else
     (throw (ex-info "Invalid arguments for padding: " (cons arg0 args))))))

(defn text
  "Creates a text widget with the specified text and arguments.
   
   The string might break across multiple lines or might all be displayed on the same line depending on the layout constraints.

   The style argument is optional. When omitted, the text will use the style from the closest enclosing DefaultTextStyle.
   If the given style's TextStyle.inherit property is true (the default), the given style will be merged with the closest enclosing DefaultTextStyle.
   This merging behavior is useful, for example, to make the text bold while using the default font family and size.
   
   The text can be specified as a string or an InlineSpan object.

   The arguments can be specified as a map with the following keys:
    - `:key` (any, default: nil): An identifier for the text.
    - `:style` (map or TextStyle, default: nil): The style to apply to the text.
      Style map also can be passed directly instead of the arguments map.
      Check text-style function for more details.
    - `:strut-style` (StrutStyle, default: nil): The strut style to use for the text.
    - `:align` (keyword or TextAlign, default: nil): The alignment of the text.
      Possible values: :left, :right, :center, :justify, :start, :end.
    - `:text-direction` (keyword or TextDirection, default: nil): The direction of the text.
      Possible values: :ltr, :rtl.
    - `:locale` (Locale, default: nil): The locale to use for the text.
    - `:soft-wrap` (bool, default: true): Whether the text should wrap at the end of the line.
    - `:overflow` (TextOverflow, default: nil): How the text should behave when it overflows.
    - `:text-scaler` (TextScaler, default: nil): The text scaler to use for the text.
    - `:max-lines` (int, default: nil): The maximum number of lines to display.
    - `:semantics-label` (string, default: nil): The semantics label to use for the text.
    - `:text-width-basis` (TextWidthBasis, default: nil): The basis for the text width.
    - `:text-height-behavior` (TextHeightBehavior, default: nil): The behavior of the text height.
    - `:selection-color` (Color, default: nil): The color to use for the text selection.
   
   Examples:
   ```clojure
    (text \"Hello, World!\") ;; Text(\"Hello, World!\")
    (text \"Hello, World!\" {:color :red}) ;; Text(\"Hello, World!\", style: TextStyle(color: Colors.red))
    (text (text-span \"Hello, \" {:color :red} (text-span \"World!\" {:color :blue})))
  ```
   "
  ([string & args]
   (txt/text* string (ut/key-values-map args)))
  ([string] (text string {})))

(defn with-text-style
  "The text style to apply to descendant `text` widgets which don't have an explicit style.

   The arguments can be specified as a map with the following keys:
    - `:key` (any, default: nil): An identifier for the text.
    - `:style` (map or `TextStyle`, default: nil): The style to apply to the text.
      Style map also can be passed directly instead of the arguments map with following keys:
      - `:inherit` (boolean, default: true): Whether the style is inherited from the parent. 
      - `:color` (Color, default: nil): The color of the text.
      - `:background-color` (Color, default: nil): The background color of the text.
      - `:font-size` (number, default: nil): The size of the font.
      - `:font-weight` (number or FontWeight, default: nil): The weight of the font.
      - `:font-style` (keyword or FontStyle, default: nil): The style of the font.
      - `:letter-spacing` (number, default: nil): The spacing between letters.
      - `:word-spacing` (number, default: nil): The spacing between words.
      - `:text-baseline` (keyword or TextBaseline, default: nil): The baseline alignment for the text.
      - `:height` or `:h` (number, default: nil): The height of the text.
      - `:leading-distribution` (keyword or TextLeadingDistribution, default: nil): The leading distribution of the text.
      - `:locale` (Locale, default: nil): The locale to use for the text.
      - `:foreground` (Paint, default: nil): The foreground paint of the text.
      - `:background` (Paint, default: nil): The background paint of the text.
      - `:shadows` (list of Shadow, default: nil): The shadows of the text.
      - `:font-features` (list of FontFeature, default: nil): The font features of the text.
      - `:font-variations` (list of FontVariation, default: nil): The font variations of the text.
      - `:decoration` (TextDecoration, default: nil): The decoration of the text.
      - `:decoration-color` (Color, default: nil): The color of the decoration.
      - `:decoration-style` (TextDecorationStyle, default: nil): The style of the decoration.
      - `:decoration-thickness` (number, default: nil): The thickness of the decoration.
      - `:debug-label` (string, default: nil): The debug label of the text.
      - `:font-family` (string, default: nil): The font family of the text.
      - `:font-family-fallback` (list of string, default: nil): The font family fallback of the text.
      - `:package` (string, default: nil): The package of the font family.
      - `:overflow` (TextOverflow, default: nil): How the text should behave when it overflows.
      Check text-style function for more details.
    - `:align` (keyword or `TextAlign`, default: nil): The alignment of the text.
      Possible values: `:left`, `:right`, `:center`, `:justify`, `:start`, `:end`.
    - `:soft-wrap` (bool, default: true): Whether the text should wrap at the end of the line.
    - `:overflow` (TextOverflow, default: nil): How the text should behave when it overflows.
    - `:max-lines` (int, default: nil): The maximum number of lines to display.
    - `:text-width-basis` (TextWidthBasis, default: nil): The basis for the text width.
    - `:text-height-behavior` (TextHeightBehavior, default: nil): The behavior of the text height.
    - `:animation` (map, default: nil): The animation options for the text style changes.
      - `:duration` (number, default: 0.25): The duration of the animation.
      - `:curve` (Curve, default: Curves.linear): The curve of the animation.
      - `:on-end` (fn, default: nil): The callback function to call when the animation ends.
      
   ```clojure
   (-> (column
         {:spacing 5}
         (text \"Hello, World!\")
         (text \"This is a column!\"))
      (with-text-style :color :red :font-size 20))
   ```"
  [arg0 & args]
  (let [[args children] (ut/key-values-args-and-children (cons arg0 args))]
    (wts/with-text-style* args (last children))))

(defn on-change-of
  "A widget that calls a function when the given value changes.
  
   Args:
    - `value`: The value to listen for changes.
    - `equal?`: The function to compare the old and new values.
    - `on-change`: The function to call when the value changes. (fn [old new context])
    - `child`: The child widget to rebuild when the value changes.
   
   Example:
   ```clojure
   (->> (text string))
     (on-change-of string #(print %2)))
   ```
   
   - Note: The `on-change-of` doesn't listen atoms or ValueListenable objects."
  ([value equal? on-change child]
   (oc/on-change-of* value equal? on-change child))
  ([value on-change child]
   (oc/on-change-of* value nil on-change child)))

(defn animated
  "Creates a widget that animates given values.

   This widget accepts:
     1. An optional map with the following keys:
        - `:duration` - The duration of the animation. Default is 250 milliseconds.
        - `:curve` - The curve of the animation. Default is `Curves.easeInOut`.
        - `:lerp` - The lerp function to interpolate between values. Default is `utils/lerp`.
        - `:on-end` - The callback to be called when the animation ends. Default is nil.
        - `:when` - The condition to trigger the animation. True by default.
     2. A builder function that creates the child widget. (fn [value Widget?])
     3. Values to animate. Animation is triggered when any value changes and `:when` option is true. All values are passed to the builder function. For a single value, it can optionally be passed before the builder function.
     4. An optional child widget that is passed to the builder function as the last argument.
   
   Or:
     1. An `Animation` or `ValueListenable` or `Atom`.
     2. A builder function that creates the child widget. (fn [value Widget?])
     3. An optional child widget that is passed to the builder function.

  ```clojure
  (animated
    {:duration 250}
    {:padding pd :color txt-clr}
    #(padding (:padding %1) 
        (tx/text \"Text\" {:color (:color %1)})))
  ```
     If your builder function contains a subtree that doesn't depend on the animation,
     it's more efficient to build that subtree once instead of rebuilding it on every animation tick.
     
     To achieve this, animated can be inserted before any modifier call:
     
  ```clojure
   (->> (some-widget)
     (animated padding pd)
     (animated sized w h)
     (animated {:duration 200 :curve :linear}
       decorated {:color color, :border-radius radius}))
  ```

  [!NOTE]
  All provided values must be animatable and consistent.
  
  Animatable values include:
  - Numbers
  - Vectors
  - Maps
  - Flutter classes with a static `lerp` method (e.g., Color, Alignment)
  
  For consistent animations, ensure values maintain the same type and structure between updates. For example:
  
  Instead of:
  ```clojure
  ;; Inconsistent - animation won't work correctly
  {:h 8 :v 10}  ; first value
  {:all 16}     ; second value - different structure
  ```
  
  Use:
  ```clojure
  ;; Correct - consistent EdgeInsets instances
  (t/insets {:h 8 :v 10})  ; first value
  (t/insets {:all 16})     ; second value
  ```
  
  Keywords are not animatable. Convert them to appropriate Flutter classes using methods from the `flutter-cljd/types` namespace:
  - `(t/color :blue)`
  - `(t/alignment :center)`"
  ([animation builder & values]
   (an/animated* animation (cons builder values))))

(defn on-reassemble
  "A widget that calls whenever the application is reassembled during debugging, for example during hot reload.

   Args:
    - `on-reassamble`: The function to call. Note that anonymous functions are not updated during hot reload, use a named function instead.
    - `child`: The child widget."
  [on-reassemble child]
  (osa/on-state-actions* {:on-reassemble on-reassemble} child))

(defn on-create 
  "A widget that calls a function when the widget is created and inserted into the tree.

   Args:
    - `on-create`: The function to call.
    - `child`: The child widget."
  [on-create child]
  (osa/on-state-actions* {:on-create on-create} child))

(defn on-dispose
  "A widget that calls a function when the widget is removed from the tree and destroyed.

   Args:
    - `on-dispose`: The function to call.
    - `child`: The child widget."
  [on-dispose child]
  (osa/on-state-actions* {:on-dispose on-dispose} child))

(defn on-update 
  "A widget that calls a function when the widget is updated.

   Args:
    - `on-update`: The function to call.
    - `child`: The child widget."
  [on-update child]
  (osa/on-state-actions* {:on-update on-update} child))

(defn on-did-change-dependencies 
  "A widget that calls a function when the widget's dependencies change.

   Args:
    - `on-did-change-dependencies`: The function to call.
    - `child`: The child widget."
  [on-did-change-dependencies child]
  (osa/on-state-actions* {:on-did-change-dependencies on-did-change-dependencies} child))

(defn on-deactivate
  "A widget that calls a function when the widget is removed from the tree, but can be reinserted.

   Args:
    - `on-deactivate`: The function to call.
    - `child`: The child widget."
  [on-deactivate child]
  (osa/on-state-actions* {:on-deactivate on-deactivate} child))

(defn with-managed
  "A widget that keeps, updates and disposes objects.
   
   Args:
   - List of maps with the following keys:
     - `:state`: Current state of the managed object.
     - `:create`: The function (fn [state]) to create the object with the current state.
     - `:update`: The function (fn [object state]) to update the object with a new state.
   - Builder: The function (fn [context & objects]) to create a child widget with managed objects."
  [first second & more-and-builder]
  (let [[values builder] (if (empty? more-and-builder)
                           [[first] second]
                           [(concat [first second] (drop-last more-and-builder)) (last more-and-builder)])]
    (wm/WithManaged (map
                     (fn [{:keys [state create update]}]
                       [state create update])
                     values)
                    builder)))

(defn with-motion
  "Wraps a widget with motion animations that may change dynamically.
  
   Use this when the initial animation state depends on external values, requiring recomputation.
   If the animation state is static, prefer using the `:managed` key in `widget`
   or the `widget->>` macro for a more concise approach.

   The `builder` function receives context and motion controllers for each motion and returns a widget.

   ### Example:
   ```clojure
   (with-motion 
     vsync
     (to current-opacity 1.0)
     (fn [ctx controller]
       (->> (text \"Example\")
         (animated controller opacity))))
   ```"
  [vsync motion0 motion1 & more-and-builder]
  (let [[motions builder] (if (empty? more-and-builder)
                            [[motion0] motion1]
                            [(concat [motion0 motion1] (drop-last more-and-builder)) (last more-and-builder)])]
    (apply
     with-managed
     (conj
      (map
       (fn [motion]
         {:state motion
          :create #(a/motion-controller vsync %)
          :update a/set-motion!})
       motions)
      builder))))

(defn transform
  "Applies a transformation matrix to its child.

  The transform matrix is a 4x4 transformation matrix that determines how to map the child's coordinate system.
  
  Args:
   - transform: A Matrix4 transformation matrix. Base transforms functions are available in `flutter-cljd.drawing` namespace.
   - args: Optional map of arguments:
     - :key - Widget key
     - :origin - The origin of the coordinate system (Offset)
     - :alignment - The alignment of the origin (Alignment)
     - :transform-hit-tests - Whether to transform hit test bounds (default true)
     - :filter-quality - The filter quality to use when transforming
   - child: The widget to transform

  Example:
  ```clojure
  (transform (mat4-rotation-z 0.5)
    (text \"Rotated text\"))
  
  (transform (mat4-skew-x 0.3)
            {:alignment :center
             :origin (offset 100 100)}
    (container {:width 200 :height 100}
      (text \"Skewed text\")))
  ```

  [Flutter docs](https://api.flutter.dev/flutter/widgets/Transform-class.html)"
  [transform & args]
  (let [[args children] (ut/key-values-args-and-children args)]
    (tr/transform* transform args (last children))))

(defn flip
  "Flips (mirrors) the child widget along the specified axis.

  Args:
   - axis: The axis to flip along. Can be:
     - A single axis keyword (:horizontal or :vertical)
     - A vector of axes to flip on multiple axes
     - Multiple axis arguments
   - args: Optional map of transform arguments (see transform function)
   - child: The widget to flip

  Example:
  ```clojure
  ;; Flip horizontally
  (flip :horizontal
    (text \"Flipped text\"))

  ;; Flip both horizontally and vertically  
  (flip [:horizontal :vertical]
    (text \"Flipped both ways\"))

  ;; Flip with options
  (flip :horizontal {:origin (offset 100 0)}
    (text \"Flipped with origin\"))
  ```"
  [axis & args]
  (let [is-first-axis (and (seq args) (even? (count args)))
        axis (if is-first-axis [axis (first args)] axis)
        args (if is-first-axis (drop 1 args) args)
        [args children] (ut/key-values-args-and-children args)]
    (tr/flip* axis args (last children))))

(defn scale
  "Scales the child widget by the given scale factor.

  Args:
   - scale: The scale factor. Can be:
     - A single number to scale uniformly
     - A map with :x and :y keys for different scaling
     - A sequence of [x y] values
   - args: Optional map of transform arguments (see transform function)
   - child: The widget to scale

  Example:
  ```clojure
  ;; Uniform scaling
  (scale 2.0
    (text \"Scaled text\"))

  ;; Different x/y scaling
  (scale {:x 2.0 :y 1.5}
    (text \"Non-uniform scaling\"))

  ;; Scale with options
  (scale 2.0 {:alignment :center}
    (text \"Centered scaling\"))
  ```"
  [scale & args]
  (tr/transform-macro scale tr/scale* args))

(defn translate
  "Translates (moves) the child widget by the given offset.

  Args:
   - offset: The translation offset. Can be:
     - An Offset object
     - A sequence of [dx dy] values
     - A map with :dx and :dy keys
   - args: Optional map of transform arguments (see transform function)
   - child: The widget to translate

  Example:
  ```clojure
  ;; Using dx/dy values
  (translate [100 50]
    (text \"Moved text\"))

  ;; Using Offset
  (translate (offset 100 50)
    (text \"Moved text\"))

  ;; With transform options
  (translate [100 50] {:transform-hit-tests false}
    (text \"Moved without hit testing\"))
  ```"
  [offset & args]
  (tr/transform-macro offset tr/translate* args))

(defn fractional-translation
  "Translates the child widget by a fraction of its size.

  The translation offset is specified as a fraction of the child's size.
  For example, an offset of [0.5 0.5] moves the child halfway across and down.

  Args:
   - offset: The fractional offset. Can be:
     - An Offset object with values between 0.0 and 1.0
     - A sequence of [dx dy] fractional values
   - args: Optional map with:
     - :key - Widget key
     - :transform-hit-tests - Whether to transform hit test bounds
   - child: The widget to translate

  Example:
  ```clojure
  ;; Move halfway across and down
  (fractional-translation [0.5 0.5]
    (text \"Moved by fraction\"))

  ;; Using Offset
  (fractional-translation (offset 0.25 0.75)
    (text \"Fractionally moved\"))
  ```

  [Flutter docs](https://api.flutter.dev/flutter/widgets/FractionalTranslation-class.html)"
  [offset & args]
  (tr/transform-macro offset tr/fractional-translation* args))

(defn rotate
  "Rotates the child widget by the given angle.

  Args:
   - angle: The rotation angle in radians
   - args: Optional map of arguments:
     - :key - Widget key
     - :origin - The origin of rotation (Offset)
     - :alignment - The alignment of the origin (Alignment)
     - :transform-hit-tests - Whether to transform hit test bounds
     - :filter-quality - The filter quality for the transform
   - child: The widget to rotate

  Example:
  ```clojure
  ;; Basic rotation
  (rotate 0.5
    (text \"Rotated text\"))

  ;; Rotate around top-left corner
  (rotate 1.5708 :alignment :top-left
    (text \"90 degree rotation\"))

  ;; Custom rotation origin
  (rotate 0.7854 {:origin (offset 100 100)}
    (text \"Rotated around point\"))
  ```

  [Flutter docs](https://api.flutter.dev/flutter/widgets/Transform/Transform.rotate.html)"
  [angle & args]
  (let [[args children] (ut/key-values-args-and-children args)]
    (tr/rotate* angle args (last children))))

(defn rotate-layout
  "Rotates the child widget's layout by the given number of quarter turns.

  Unlike rotate which applies a visual transform, this actually affects the layout
  of the child, rotating its layout constraints by increments of 90 degrees.

  Args:
   - quarter-turns: Number of clockwise quarter turns (each 90 degrees)
   - child: The widget to rotate

  Example:
  ```clojure
  ;; Rotate 90 degrees clockwise
  (rotate-layout 1
    (text \"Rotated text\"))

  ;; Rotate 180 degrees
  (rotate-layout 2
    (sized {:width 100 :height 50}
      (text \"Flipped text\")))
  ```

  [Flutter docs](https://api.flutter.dev/flutter/widgets/RotatedBox-class.html)"
  [quarter-turns child]
  (tr/rotate-layout* quarter-turns child))

(defn life-cycle-observer
  "A widget that calls a function when the widget's lifecycle state changes.

   Args:
    - `on-change`: The function to call. (fn [state]). State can be one of `:detached`, `:resumed`, `:inactive`, `:hidden`, `:paused`
    - `child`: The child widget."
  [observer child]
  (lco/LifeCycleObserver observer child))

(defn on-app-became-active 
  "A widget that calls a function when the app becomes active.

   Args:
    - `action`: The function to call.
    - `child`: The child widget."
  [action child]
  (life-cycle-observer
   (fn [state]
     (when (= :resumed state)
       (action)))
   child))

(defn on-app-became-inactive
  "A widget that calls a function when the app becomes inactive.

   Args:
    - `action`: The function to call.
    - `child`: The child widget."
  [action child]
  (life-cycle-observer
   (fn [state]
     (when (not= :resumed state)
       (action)))
   child))

(defn observe-visibility
  "A widget that calls a function when the widget's visibility changes.

   Args:
    - `:on-enter`: The function to call when the widget becomes fully visible.
    - `:on-first-enter`: The function to call when the widget becomes fully visible for the first time.
    - `:on-exit`: The function to call when the widget becomes fully invisible.
    - `:on-change`: The function to call. (fn [VisibilityInfo]).
    - `child`: The child widget."
  [& args]
  (let [[args children] (ut/key-values-args-and-children args)]
    (ovc/observe-visibility* args (last children))))
