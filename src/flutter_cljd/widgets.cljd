(ns flutter-cljd.widgets
  "The Flutter widgets framework. [Docs](https://api.flutter.dev/flutter/widgets/widgets-library.html)"
  (:require
   ["package:flutter/material.dart" :as m]
   ["package:flutter/services.dart" :as s]
   ["package:flutter/widgets.dart" :as w]
   ["dart:async" :as async] 
   [cljd.flutter :as f]
   [flutter-cljd.core :as c]
   [flutter-cljd.types :as t]
   [flutter-cljd.utils :as ut]
   [flutter-cljd.inherited-keys :as inh]
   [flutter-cljd.internal.builder :as bd]
   [flutter-cljd.internal.layout-builder :as lbd]
   [flutter-cljd.internal.button :as bt]
   [flutter-cljd.internal.padding :as pd]
   [flutter-cljd.internal.absorb-pointer :as ap]
   [flutter-cljd.internal.ignore-pointer :as ip]
   [flutter-cljd.internal.align :as al]
   [flutter-cljd.internal.aspect-ratio :as ar]
   [flutter-cljd.internal.block-semantics :as bs]
   [flutter-cljd.internal.banner :as bn]
   [flutter-cljd.internal.center :as cntr]
   [flutter-cljd.internal.clip-oval :as co]
   [flutter-cljd.internal.clip-rect :as cr]
   [flutter-cljd.internal.colored :as cd]
   [flutter-cljd.internal.color-filtered :as cf]
   [flutter-cljd.internal.composited-transform :as ct]
   [flutter-cljd.internal.constraints-transformed :as ctr]
   [flutter-cljd.internal.flexible :as fx]
   [flutter-cljd.internal.expanded :as ex]
   [flutter-cljd.internal.column-row-flex :as crf]
   [flutter-cljd.internal.action-listener :as aclr]
   [flutter-cljd.internal.text :as txt]
   [flutter-cljd.internal.container :as cnt]
   [flutter-cljd.internal.spacer :as sp]
   [flutter-cljd.internal.opacity :as op]
   [flutter-cljd.internal.stack :as st]
   [flutter-cljd.internal.sized :as sz]
   [flutter-cljd.internal.with-inherited :as wi]
   [flutter-cljd.internal.autocomplete-highlighted-index :as ahi]
   [flutter-cljd.internal.autofill-group :as afg]
   [flutter-cljd.internal.keep-alive :as ka]
   [flutter-cljd.internal.on-back-button :as obb]
   [flutter-cljd.internal.baseline :as bl]
   [flutter-cljd.internal.bottom-navigation-bar-item :as bnbi]
   [flutter-cljd.internal.shortcuts :as sc]
   [flutter-cljd.internal.actions :as act]
   [flutter-cljd.internal.checked-mode-banner :as cmb]))

(defn absorb-pointer 
  "A widget that absorbs pointers during hit testing. 
   It makes the widget and any underlying widgets impossible to interact with.
   If you want to disable the widget but keep the underlying widgets interactive, use `ignore-pointer`.

   When absorbing is true, this widget prevents its subtree from receiving pointer events by terminating hit testing at itself.
   It still consumes space during layout and paints its child as usual.
   It just prevents its children from being the target of located events, because it returns true from RenderBox.hitTest.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/AbsorbPointer-class.html)"
  ([absorbing child]
   (ap/absorb-pointer* absorbing child))
  ([child] (absorb-pointer true child)))

(defn ignore-pointer
  "A widget that is invisible during hit testing.

   When ignoring is true, this widget (and its subtree) is invisible to hit testing.
   It still consumes space during layout and paints its child as usual.
   It just cannot be the target of located events, because it returns false from RenderBox.hitTest.
  
   [Flutter docs](https://api.flutter.dev/flutter/widgets/IgnorePointer-class.html)"
  ([ignoring child]
   (ip/ignore-pointer* ignoring child))
  ([child] (ignore-pointer true child)))

(defn align 
  "A widget that aligns its child within itself and optionally sizes itself based on the child's size.

   For example, to align a box at the bottom right, you would pass this box a tight constraint that is bigger than the child's natural size, with an alignment of `Alignment.bottomRight`.
   
   Args:
   - args: A map of arguments or an alignment or `Animation<AlignmentGeometry>`.
     - `:key` An identifier for the align widget.
     - `:alignment` (keyword or `Alignment` or `Animation<AlignmentGeometry>`, default: `Alignment.center`): The alignment of the child within the container.
        Possible keywords: `:top`, `:center`, `:bottom`, `:left`, `:right`, `:start`, `:end` and their combinations like `:top-left`.
     - `:width-factor` (number, default: nil): The width factor of the child.
     - `:height-factor` (number, default: nil): The height factor of the child.
     - `:animation` (map or number of seconds, default: nil): The animation options for the align widget.
       - `:duration` (number of seconds or map or Duration, default: 0.25): The duration of the animation.
       - `:curve` (keyword or Curve, default: :ease-in-out): The curve of the animation.
       - `:on-end` (function, default: nil): The callback function to be called when the animation ends.
   - child: The child widget to be aligned.

   ```clojure
   (align {:alignment :top-right :width-factor 0.4} (text \"Hello, World!\"))
   (align :top-right (text \"Hello, World!\"))
   ```

   [Flutter docs](https://api.flutter.dev/flutter/widgets/Align-class.html)

   [Animated flutter docs](https://api.flutter.dev/flutter/widgets/AnimatedAlign-class.html)
   
   [Transition flutter docs](https://api.flutter.dev/flutter/widgets/AlignTransition-class.html)"
  [args child]
  (al/align* args child))

(defn aspect-ratio
  "A widget that attempts to size the child to a specific aspect ratio.

   The aspect ratio is expressed as a ratio of width to height.
   For example, a 16:9 width:height aspect ratio would have a value of 16.0/9.0.

   Args:
   - ratio: The aspect ratio to apply to the child.
   - child: The child widget to be sized.

   [Flutter docs](https://api.flutter.dev/flutter/widgets/AspectRatio-class.html)"
  [ratio child]
  (ar/aspect-ratio* ratio child))

(defn action-listener 
  "A helper widget for making sure that listeners on an action are removed properly.
   
   Listeners on the Action class must have their listener callbacks removed with Action.removeActionListener when the listener is disposed of.
   This widget helps with that, by providing a lifetime for the connection between the listener and the Action, and by handling the adding and removing of the listener at the right points in the widget lifecycle.
   
   If you listen to an Action widget in a widget hierarchy, you should use this widget.
   If you are using an Action outside of a widget context, then you must call removeListener yourself.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/ActionListener-class.html)"
  [listener action child]
  (aclr/action-listener* listener action child))

(defn with-autocomplete-highlighted-index 
  "An inherited widget used to indicate which autocomplete option should be highlighted for keyboard navigation.
   
   The RawAutoComplete widget will wrap the options view generated by the optionsViewBuilder with this widget to provide the highlighted option's index to the builder.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/AutocompleteHighlightedOption-class.html)"
  [option child]
  (ahi/with-autocomplete-highlighted-index* option child))

(defn autofill-group
  "An AutofillScope widget that groups AutofillClients together.

   AutofillClients that share the same closest AutofillGroup ancestor must be built together, and they be will be autofilled together.
   
   AutofillClients within the same AutofillScope are isolated from other input fields during autofill. That is, when an autofillable TextInputClient gains focus, only the AutofillClients within the same AutofillScope will be visible to the autofill service, in the same order as they appear in AutofillScope.autofillClients.
   
   AutofillScope also allows TextInput to redirect autofill values from the platform to the AutofillClient with the given identifier, by calling AutofillScope.getAutofillClient.
   
   An AutofillClient that's not tied to any AutofillScope will only participate in autofill if the autofill is directly triggered by its own TextInputClient.
   
   The AutofillGroup widget only knows about AutofillClients registered to it using the AutofillGroupState.register API. Typically, AutofillGroup will not pick up AutofillClients that are not mounted, for example, an AutofillClient within a Scrollable that has never been scrolled into the viewport. To workaround this problem, ensure clients in the same AutofillGroup are built together.
   
   The topmost AutofillGroup widgets (the ones that are closest to the root widget) can be used to clean up the current autofill context when the current autofill context is no longer relevant.
   
   An autofill context is a collection of input fields that live in the platform's text input plugin. The platform is encouraged to save the user input stored in the current autofill context before the context is destroyed, when TextInput.finishAutofillContext is called with shouldSave set to true.
   
   Currently, there can only be at most one autofill context at any given time. When any input field in an AutofillGroup requests for autofill (which is done automatically when an autofillable EditableText gains focus), the current autofill context will merge the content of that AutofillGroup into itself. When there isn't an existing autofill context, one will be created to hold the newly added input fields from the group.
   
   Once added to an autofill context, an input field will stay in the context until the context is destroyed. To prevent leaks, call TextInput.finishAutofillContext to signal the text input plugin that the user has finalized their input in the current autofill context. The platform text input plugin either encourages or discourages the platform from saving the user input based on the value of the shouldSave parameter. The platform usually shows a \"Save for autofill?\" prompt for user confirmation.
   
   By default, onDisposeAction is set to AutofillContextAction.commit, in which case when any of the topmost AutofillGroups is being disposed, the platform will be informed to save the user input from the current autofill context, then the current autofill context will be destroyed, to free resources. You can, for example, wrap a route that contains a Form full of autofillable input fields in an AutofillGroup, so the user input of the Form can be saved for future autofill by the platform.

   [Flutter docs](https://api.flutter.dev/flutter/widgets/AutofillGroup-class.html)"
  ([action child] (afg/autofill-group* action child))
  ([child] (afg/autofill-group* child)))

(defn keep-alive
  "Mark a child as needing to stay alive even when it's in a lazy list that would otherwise remove it.

   This widget is for use in a RenderAbstractViewports, such as Viewport or TwoDimensionalViewport.
   
   This widget is rarely used directly. The SliverChildBuilderDelegate and SliverChildListDelegate delegates, used with SliverList and SliverGrid, as well as the scroll view counterparts ListView and GridView, have an addAutomaticKeepAlives feature, which is enabled by default, and which causes AutomaticKeepAlive widgets to be inserted around each child, causing KeepAlive widgets to be automatically added and configured in response to KeepAliveNotifications.
   
   The same addAutomaticKeepAlives feature is supported by the TwoDimensionalChildBuilderDelegate and TwoDimensionalChildListDelegate.
   
   Therefore, to keep a widget alive, it is more common to use those notifications than to directly deal with KeepAlive widgets.
   
   In practice, the simplest way to deal with these notifications is to mix AutomaticKeepAliveClientMixin into one's State. See the documentation for that mixin class for details.
   
   You can pass `:auto` as the `alive` argument to use `AutomaticKeepAlive` widget.

   [Flutter docs](https://api.flutter.dev/flutter/widgets/KeepAlive-class.html)
   [AutomaticKeepAlive docs](https://api.flutter.dev/flutter/widgets/AutomaticKeepAlive-class.html)"
  ([alive child] (ka/keep-alive* alive child))
  ([child] (ka/keep-alive* child)))

(defn on-back-button
  "A convenience widget that registers a callback for when the back button is pressed.

   In order to use this widget, there must be an ancestor Router widget in the tree that has a RootBackButtonDispatcher. e.g. The Router widget created by the MaterialApp.router has a built-in RootBackButtonDispatcher by default.
   
   It only applies to platforms that accept back button clicks, such as Android.
   
   It can be useful for scenarios, in which you create a different state in your screen but don't want to use a new page for that.

   Args:
    - action: The action to be executed when the back button is pressed.
    - child: The child widget to be displayed.

   [Flutter docs](https://api.flutter.dev/flutter/widgets/BackButtonListener-class.html)"
  [action child]
  (obb/on-back-button* action child))

(defn banner 
  "Displays a diagonal message above the corner of another widget.

   Useful for showing the execution mode of an app (e.g., that asserts are enabled.)

   Args:
    - args: A map of arguments for the banner widget.
      - `:key` An identifier for the banner.
      - `:child` The widget to show behind the banner.
      - `:message` The message to show in the banner.
      - `:location` (keyword or BannerLocation, default: :top-start): The location of the banner.
        Possible values: :top-start, :top-end, :bottom-start, :bottom-end.
      - `:layout-direction` (keyword or TextDirection, default: :ltr): The layout direction of the banner.
        Possible values: :ltr, :rtl.
      - `:text-direction` (keyword or TextDirection, default: :ltr): The direction of the text.
        Possible values: :ltr, :rtl.
      - `:color` (Color, default: 0xA0B71C1C): The color of the banner.
      - `:text-style` (TextStyle, default: TextStyle(color: Colors.white, fontSize: 12.0 * 0.85, fontWeight: FontWeight.w900, height: 1.0)): The text style of the banner.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/Banner-class.html)"
  [args child]
  (bn/banner* args child))

(defn baseline
  "A widget that positions its child according to the child's baseline.
   
   This widget shifts the child down such that the child's baseline (or the bottom of the child, if the child has no baseline) is baseline logical pixels below the top of this box, then sizes this box to contain the child.
   If baseline is less than the distance from the top of the child to the baseline of the child, then the child is top-aligned instead.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/Baseline-class.html)"
  ([offset type child] (bl/baseline* offset type child))
  ([offset child] (bl/baseline* offset child)))

(defn block-semantics
  "A widget that drops the semantics of all widget that were painted before it in the same semantic container.

   This is useful to hide widgets from accessibility tools that are painted behind a certain widget, e.g. an alert should usually disallow interaction with any widget located \"behind\" the alert (even when they are still partially visible).
   Similarly, an open Drawer blocks interactions with any widget outside the drawer.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/BlockSemantics-class.html)"
  ([blocking child]
   (bs/block-semantics* blocking child))
  ([child] (block-semantics true child)))

(defn bottom-navigation-bar-item 
  "An interactive button within either material's BottomNavigationBar or the iOS themed CupertinoTabBar with an icon and title.
   
   This class is rarely used in isolation. It is typically embedded in one of the bottom navigation widgets.
   
   Args:
    - args: A map of arguments for the bottom navigation bar item widget.
      - `:icon` The icon of the bottom navigation bar item. Required.
      - `:label` The label of the bottom navigation bar item.
      - `:active-icon` The active icon of the bottom navigation bar item.
      - `:background-color` The background color of the bottom navigation bar item.
      - `:tooltip` The tooltip of the bottom navigation bar item.
   
   [Flutter docs](https://api.flutter.dev/flutter/material/BottomNavigationBarItem-class.html)"
  [args]
  (bnbi/bottom-navigation-bar-item* args))

(defn builder
  "A stateless utility widget whose build method uses its builder callback to create the widget's child.
   
   Args:
    - builder: Called with the context and to build the widget.
    - child: The child widget to be wrapped by the builder widget. 
      When provided, the builder callback will be called with the child widget as the first argument and the context as the second argument.
   
   ```clojure
    (builder (fn [ctx] (text (str \"Hello, World!\" (.hasAppBar (Scaffold.of context))))))
   
   (->>
     (text \"Hello, World!\")
     (builder #(padding 10 %)))
   ```
   [Flutter docs](https://api.flutter.dev/flutter/widgets/Builder-class.html)"
  ([builder] (bd/builder* builder))
  ([builder child] (bd/builder* builder child)))

(defn with-transformed-inherited
  "A widget that transforms inherited bindings using the specified `transform` function.
   
   The `transform` function is called with the inherited bindings map as an argument and should return a new map of bindings.
   
   Args:
    - key: The key to be transformed in the inherited bindings. If not provided, the entire bindings map is transformed. Key may be a keyword or a map with the following keys:
      - `:key` (keyword): The key to be transformed.
      - `:default-value` (any): The default value to be transformed.
    - transform: The function to transform the inherited bindings.
    - child: The child widget to be wrapped by the transformed inherited widget.
   
   ```clojure
   (->>
     (text \"Hello, World!\")
     (with-transformed-inherited #(assoc % :theme :dark)))
   ```
   Some default keys are defined in the `flutter-cljd.inherited-keys` namespace.

   To access the inherited bindings, use `c/get-inherited` function."
  ([transform child] (wi/with-transformed-inherited* transform child))
  ([key transform & kts&child] (apply wi/with-transformed-inherited* key transform kts&child)))

(defn with-merged-inherited
  "A widget that merges the specified `bindings` with the inherited bindings.
   
   Args:
    - bindings: The bindings to be merged with the inherited bindings.
    - child: The child widget to be wrapped by the merged inherited widget.
   
   ```clojure
   (->>
     (text \"Hello, World!\")
     (with-merged-inherited {:theme :dark}))
   ```
   To access the inherited bindings, use `c/get-inherited` function."
   [bindings child]
  (wi/with-merged-inherited* bindings child))

(defn with-inherited
  "A widget that provides inherited values to its descendants.
   
   Args:
    - key values pairs to be inherited. Key may be a keyword or a map with the following keys:
      - `:key`: The key to be inherited.
      - `:default-value` (any): The value to be inherited.
      - `:merge` (fn [old new] new): The function to merge the new value with the existing one.
    - child: The child widget to be wrapped by the inherited widget.
   
   ```clojure
   (->>
     (text \"Hello, World!\")
     (with-inherited :theme :dark))
   
   (->>
     (text \"Hello, World!\")
     (button tap-fn)
     (with-inherited inh/enabled false))
   ```
   Some default keys are defined in the `flutter-cljd.inherited-keys` namespace.

   To modify the inherited bindings, use `with-transformed-inherited` widget.
   
   To access the inherited bindings, use `c/get-inherited` function."
  ([key child] (wi/with-inherited* key child))
  ([key value child] (wi/with-inherited* key value child))
  ([key0 value0 key1 value1 & kvs&child] (apply wi/with-inherited* key0 value0 key1 value1 kvs&child)))

(defn enabled 
  "A widget that sets the `flutter-cljd.inherited-keys/enabled` inherited value"
  ([child] (enabled true child))
  ([value child]
   (with-inherited inh/enabled value child)))

(defn disabled 
  "A widget that sets the `flutter-cljd.inherited-keys/enabled` inherited value to false"
  ([child] (disabled true child))
  ([value child]
   (with-inherited inh/enabled (not value) child)))

(defn shortcuts
  "A widget that creates keyboard shortcuts for its descendants.
   
   Shortcuts are key bindings that become actions when triggered. They are typically used to implement keyboard shortcuts for common operations.
   
   The shortcuts widget can be used in two ways:
   1. With a ShortcutManager instance that manages the shortcuts directly
   2. With a map of key combinations to actions
   
   Args:
    - shortcuts: A ShortcutManager instance or a map of key combinations to actions
    - args: A map of arguments for the shortcuts widget
      - `:debug-label` (string): A label used for debugging purposes
      - `:modal` (boolean): If true, prevents shortcuts from being handled by ancestors
      - `:include-semantics` (boolean, default: true): Whether to include semantics information
    - child: The widget below this widget in the tree
   
   The shortcuts map can contain:
   - Key combinations as vectors: `[:control \\W]`
   - Function keys as keywords: `:f1`
   - Values can be:
     - Intent instances
     - Keywords representing intents
     - Vectors with an intent and arguments: `[:some-intent arg1 arg2]`
     - Functions to be called directly: `#(print \"Key pressed\")`
   
   Example:
   ```clojure
   (shortcuts
     {[:control \\W] :some-intent
      [:control \\C] [:some-intent some-arg]
      [:alt \\c] #(print \"ALT-C is pressed\")
      :f1 #(print \"F1 is pressed\")}
     (text \"Hello, Shortcuts!\"))
   ```
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/Shortcuts-class.html)"
  ([shortcuts args child]
   (sc/shortcuts* shortcuts args child))
  ([shortcuts child] 
   (shortcuts shortcuts {} child)))

(defn actions
  "A widget that establishes an Actions widget scope in which the given actions are available.

  Actions are mapping of Intent keys to Action objects that defines how keys and other inputs map to actions.
  
  Args:
   - actions: A map of Intent keys to Action objects
   - dispatcher: Optional ActionDispatcher that invokes actions
   - child: The widget below this widget in the tree
  
  The actions map can contain:
   - Intent instances as keys
   - Action instances as values
   - Functions as values that will be wrapped in Actions
   
  Example:
  ```clojure
  (actions
    {some-intent (m/CallbackAction .onInvoke #(print \"Action invoked\"))}
    (text \"Hello, Actions!\"))
  ```

  [Flutter docs](https://api.flutter.dev/flutter/widgets/Actions-class.html)"
  ([actions dispatcher child]
   (act/actions* actions dispatcher child))
  ([actions child] 
   (actions actions nil child)))

(defn button
  "A universal button.
 
  A button is a widget that responds to touch events. When the user touches the button, 
  the button is highlighted and then invokes the `on-tap` callback.
  
  Args: a map of arguments or a function called when the button is tapped.

    - `:key` - A widget key.
    - `:on-tap` - Executed when the button is tapped
    - `:on-tap-down` - Executed when the button is pressed down
    - `:on-tap-up` - Executed when the button press is released
    - `:on-tap-cancel` - Executed when the button tap is canceled
    - `:on-double-tap` - Executed on double-tap
    - `:on-long-press` - Executed when button is held down
    - `:on-secondary-tap` - Executed on secondary tap (e.g. right click)
    - `:on-secondary-tap-up` - Executed when secondary tap is released
    - `:on-secondary-tap-down` - Executed when secondary tap begins
    - `:on-secondary-tap-cancel` - Executed when secondary tap is canceled
    - `:on-highlight-changed` - Executed when button highlight state changes
    - `:on-hover` - Executed when pointer hovers over button
    - `:on-focus-change` - Executed when focus state changes
    - `:focus-node` - Custom focus node for the button
    - `:mouse-cursor` - Mouse cursor to display on hover
  
    Inherited properties (can be set via `with-inherited` or passed directly):
    - `:enabled` - Whether the button is interactive
    - `:enable-feedback` - Whether to show visual/haptic feedback
    - `:exclude-from-semantics` - Whether to exclude from accessibility tree
    - `:can-request-focus` - Whether button can receive focus
    - `:autofocus` - Whether button should automatically receive focus
  
    Button Context:
    The `:button-context` provides state information as a map with:
    - `:context` - The BuildContext of the button widget
    - `:state` - Set of current button state values. Possible values in the set are `:disable`, `:pressed`, `:hovered`, `:focused`. For example: `#{:hovered :pressed}`
    - `:prev-state` - Set of previous button state values
    - `:local-offset` - Local coordinates of touch (Offset?)  
    - `:global-offset` - Global coordinates of touch (Offset?)
  
  Styling:
  The Button supports custom styling via the `flutter-cljd.inherited-keys/button-modifier` inherited key, which accepts a function in this format:
  (fn [child button-context] modified-child). 
  You can set the button modifier using the `with-button-modifier` widget.
  
  To avoid unnecessary widget rebuilds, define your modifier functions using `defn` rather than creating anonymous functions inline.
  
  Also button injects `flutter-cljd.inherited-keys/button-context` into its child widget, so you can access the button context in your child widget and use it for custom styling or other purposes.

  Examples:
  
  ```clojure
  (->> (text \"Click me!\")
       (button #(print \"Button clicked!\")))
    
  (->> (text \"Interact with me\")
     (button {:on-tap #(print \"Button clicked!\")
              :on-long-press #(print \"Long pressed\")
              :on-hover #(print \"Hovered\")}))
    
   (defn custom-style [button btn-ctx]
     (let [state (:state btn-ctx)
        disabled? (state :disable)
        pressed? (state :pressed)]
    (opacity
     (if disabled? 0.5 (if pressed? 0.8 1.0))
     button)))
  
  (->> (text \"Custom style\")
      (button #(print \"Button clicked!\"))
      (with-button-modifier custom-style))
  
  (->> (text \"Disabled\")
     (button #(print \"Won't be called\"))
     (disabled))
  
  (defn my-button [title on-tap]
     (->>
       (widget->>
         :get {:button-context btn-ctx}
         :let [state (:state btn-ctx)]
         (text title)
         (opacity (if (state :pressed) 0.8 1)))
       (button on-tap)
       (without-button-modifier)))
  ```"
  ([args child] (bt/button* args child)) 
  ([on-tap args child] (bt/button* on-tap args child)))

(defn with-button-modifier
  "A widget that provides a custom button modifier to its descendants.
  
   The `modifier` function is called with the child widget and the button context as arguments and should return a modified child widget.
  
   Args:
    - modifier: The function to modify the button widget. The function should have the following signature:
      (fn [child button-context] modified-child)
    - child: The child widget to be wrapped by the modified button widget.

    Button Context:
    The button context provides state information as a map with:
    - `:context` - The BuildContext of the button widget
    - `:state` - Set of current button state values. Possible values in the set are `:disable`, `:pressed`, `:hovered`, `:focused`. For example: `#{:hovered :pressed}`
    - `:prev-state` - Set of previous button state values
    - `:local-offset` - Local coordinates of touch (Offset?)  
    - `:global-offset` - Global coordinates of touch (Offset?)

   ```clojure
   (defn highlighted-button [button btn-ctx]
     (let [state (:state btn-ctx)
           pressed? (state :pressed)]
       (opacity (if pressed? 0.8 1) button)))

   (->>
     (text \"Click me!\")
     (button #(print \"Button clicked!\"))
     (with-button-modifier highlighted-button))
   ```
   To avoid unnecessary widget rebuilds, define your modifier functions using `defn` rather than creating anonymous functions inline."
  [modifier child]
  (bt/with-button-modifier* modifier child))

(defn without-button-modifier
  "A widget that removes the button modifier from its descendants."
  [child] 
  (bt/without-button-modifier* child))

(defn center 
  "A widget that centers its child within itself.

   This widget will be as big as possible if its dimensions are constrained and :width-factor and :height-factor are nil.
   If a dimension is unconstrained and the corresponding size factor is null then the widget will match its child's size in that dimension.
   If a size factor is non-null then the corresponding dimension of this widget will be the product of the child's dimension and the size factor.
   For example if :width-factor is 2.0 then the width of this widget will always be twice its child's width.
   
   ```clojure
   (center (text \"Hello, World!\"))
   (center {:width-factor 2.0 :height-factor 2.0} (text \"Hello, World!\"))
   ```

   [Flutter docs](https://api.flutter.dev/flutter/widgets/Center-class.html)"
  ([args child] (cntr/center* args child))
  ([child] (center {} child)))

(defn checked-mode-banner
  "A banner that shows the current checked mode.

   Displays a Banner saying \"DEBUG\" when running in debug mode. MaterialApp builds one of these by default.
   This is useful for indicating that an app is running in debug mode, which may include additional debugging
   features or behavior that shouldn't appear in release builds.

   Does nothing in release mode, making it safe to leave in place in production code.
   
   Args:
    - child: The widget below this widget in the tree that will have the debug banner displayed over it
   
   Example:
   ```clojure
   (checked-mode-banner
     (scaffold
       (body (text \"Hello World!\"))))
   ```
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/CheckedModeBanner-class.html)"
  [child]
  (cmb/checked-mode-banner* child))

(defn clip-oval
  "A widget that clips its child using an oval.
   
   By default, inscribes an axis-aligned oval into its layout dimensions and prevents its child from painting outside that oval, but the size and location of the clip oval can be customized using a custom clipper.

   [Flutter docs](https://api.flutter.dev/flutter/widgets/ClipOval-class.html)"
  ([args child] (co/clip-oval* args child))
  ([child] (clip-oval {} child)))

(defn clip-rect 
  "A widget that clips its child using a rectangle.

   By default, inscribes an axis-aligned rectangle into its layout dimensions and prevents its child from painting outside that rectangle, but the size and location of the clip rectangle can be customized using a custom clipper.

   [Flutter docs](https://api.flutter.dev/flutter/widgets/ClipRect-class.html)"
  ([args child] (cr/clip-rect* args child))
  ([child] (clip-rect {} child)))

(defn clip-corners
  "Clips the child widget with rounded corners.
     The radius can be specified as a radius. or a map of corner names to a radius.
     Each corner can be specified separately using the keys `:top-left`, `:top-right`, `:bottom-left`, `:bottom-right`, `:left-top`, `:right-top`, `:left-bottom`, `:right-bottom`, `:left`, `:right`, `:top`, `:bottom`, `:start`, `:end`, `:t`, `:b`, `:l`, `:r`, `:s`, `:e`, `:all`.
     Each radius can be specified as a number or a map of x and y or a XY sequence.
     Examples:
     ```clojure
     (clip-corners 4) ;; BorderRadius.all(Radius.circular(4))
     (clip-corners {:top-left 4 :top-right 8}) ;; BorderRadius.only(topLeft: Radius.circular(4), topRight: Radius.circular(8))
     (clip-corners {:l 4 :r 8}) ;; BorderRadius.only(topLeft: Radius.circular(4), topRight: Radius.circular(8), bottomLeft: Radius.circular(4), bottomRight: Radius.circular(8))
     (clip-corners {:x 4 :y 8}) ;; BorderRadius.all(Radius.elliptical(4, 8))
     (clip-corners [4 8]) ;; BorderRadius.all(Radius.elliptical(4, 8))
     (clip-corners {:top-left 4 :all 8}) ;; BorderRadius.only(topLeft: Radius.circular(4), topRight: Radius.circular(8), bottomLeft: Radius.circular(8), bottomRight: Radius.circular(8))
     ```"
  [radius child]
  (m/ClipRRect
   .borderRadius (t/border-radius radius)
   .child child))

(defn colored 
  "A widget that paints its child with a specified color.
  
     The color is painted as a solid color, with no transparency.
     The child is painted using the specified color as if it was composited with an opaque version of the child.
     The color is not blended with the child.
  
     ```clojure
     (colored m/Colors.red (text \"Hello, World!\"))
     (colored :red (text \"Hello, World!\"))
     (colored 0xFF0000FF (text \"Hello, World!\"))
     ```
     [Flutter docs](https://api.flutter.dev/flutter/widgets/ColoredBox-class.html)"
  ([value] (cd/colored* value))
  ([clr child] (cd/colored* clr child)))

(defn color-filtered
  "Applies a ColorFilter to its child.
   
   This widget applies a function independently to each pixel of child's content, according to the ColorFilter specified.
   Use the ColorFilter.mode constructor to apply a Color using a BlendMode.
   Use the BackdropFilter widget instead, if the ColorFilter needs to be applied onto the content beneath child."
  ([filter child]
   (cf/color-filtered* filter child)))

(defn column
  "Creates a column widget with the specified arguments and children.

  Args:
  - args: A map of arguments for the column widget.
    - `:key` An identifier for the column. 
    - `:spacing` (number, default: 0): The spacing between each child widget.
    - `:main-axis-alignment` (keyword, default: :start): The alignment of the children along the main axis.
      Possible values: :center, :start, :end, :space-between, :space-around.
    - `:main-axis-size` (keyword, default: :min): The size of the column in the main axis.
      Possible values: :max, :min.
    - `:cross-axis-alignment` (keyword, default: :center): The alignment of the children along the cross axis.
      Possible values: :center, :start, :end, :stretch, :baseline.
    - `:text-direction` (keyword, default: :ltr): The direction of the text.
      Possible values: :ltr, :rtl.
    - `:text-baseline` (keyword, default: :alphabetic): The baseline alignment for the text.
      Possible values: :alphabetic, :ideographic.
    - `:vertical-direction` (keyword, default: :down): The direction in which the children are placed vertically.
      Possible values: :top, :down.

  - children: The child widgets to be placed in the column. Can contain nested lists of children.
   
   ```clojure
   (column {:main-axis-alignment :center :spacing 10} 
    (text \"Hello, World!\"))
   ```

  Returns:
  A column widget with the specified arguments and children."
  ([] (column {}))
  ([args & children]
   (apply crf/column* args children)))

(defn composited-transform-follower
  "A widget that follows a `composited-transform-target`.

   When this widget is composited during the compositing phase (which comes after the paint phase, as described in WidgetsBinding.drawFrame), it applies a transformation that brings targetAnchor of the linked CompositedTransformTarget and followerAnchor of this widget together.
   The two anchor points will have the same global coordinates, unless offset is not Offset.zero, in which case followerAnchor will be offset by offset in the linked CompositedTransformTarget's coordinate space.

   The `LayerLink` object used as the link must be the same object as that provided to the matching `composited-transform-target`
   
   The `composited-transform-target` must come earlier in the paint order than this `composited-transform-follower`

   Hit testing on descendants of this widget will only work if the target position is within the box that this widget's parent considers to be hittable.
   If the parent covers the screen, this is trivially achievable, so this widget is usually used as the root of an OverlayEntry in an app-wide Overlay (e.g. as created by the MaterialApp widget's Navigator).
   
   Args:
   - args: A map of arguments for the composited transform follower widget or a `LayerLink` object.
     - `:key` An identifier for the composited transform follower.
     - `:link` The LayerLink object that the follower will follow.
     - `:show-when-unlinked` (boolean, default: true): Whether to show the child when the link is not linked.
     - `:offset` (Offset, default: Offset.zero): The offset to apply to the link's target anchor.
     - `:target-anchor` (Alignment, default: Alignment.topLeft): The alignment of the target anchor relative to the size of the linked `composited-transform-target`
     - `:follower-anchor` (Alignment, default: Alignment.topLeft): The alignment of this widget's anchor relative to its size.
   
   ```clojure
   (composited-transform-follower link (text \"Hello, World!\"))
   ```

   [Flutter docs](https://api.flutter.dev/flutter/widgets/CompositedTransformFollower-class.html)"
  [args child]
  (ct/composited-transform-follower* args child))

(defn composited-transform-target
  "A widget that can be targeted by a `composited-transform-follower`

   When this widget is composited during the compositing phase (which comes after the paint phase, as described in WidgetsBinding.drawFrame),
   it updates the link object so that any `composited-transform-follower` widgets that are subsequently composited in the same frame and were given the same LayerLink can position themselves at the same screen location.

   A single CompositedTransformTarget can be followed by multiple `composited-transform-follower` widgets.

   The CompositedTransformTarget must come earlier in the paint order than any linked `composited-transform-follower`.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/CompositedTransformTarget-class.html)"
  [link child]
  (ct/composited-transform-target* link child))

;; TODO: Extend support for .constraintsTransform
(defn constraints-transformed
  "A container widget that applies an arbitrary transform to its constraints, and sizes its child using the resulting `BoxConstraints`, optionally clipping, or treating the overflow as an error.

   This container sizes its child using a `BoxConstraints` created by applying `:transform` to its own constraints.
   This container will then attempt to adopt the same size, within the limits of its own constraints.
   If it ends up with a different size, it will align the child based on alignment.
   If the container cannot expand enough to accommodate the entire child, the child will be clipped if `:clip` is not `:none`.

   In debug mode, if `:clip` is `:none` and the child overflows the container, a warning will be printed on the console, and black and yellow striped areas will appear where the overflow occurs.

   When child is nil, this widget becomes as small as possible and never overflows.

   This widget can be used to ensure some of child's natural dimensions are honored, and get an early warning otherwise during development.
   For instance, if child requires a minimum height to fully display its content, `:transform` can be set to `maxHeightUnconstrained`,
   so that if the parent `RenderObject` fails to provide enough vertical space, a warning will be displayed in debug mode, while still allowing child to grow vertically
   
   Args:
    - args: A map of arguments for the constraints transformed box widget or a transform function.
      - `:key` An identifier for the constraints transformed box.
      - `:child` The child widget to be displayed.
      - `:text-direction` (keyword, default: :ltr): The direction of the text. Possible values: :ltr, :rtl.
      - `:alignment` (Alignment, default: Alignment.center): The alignment of the child within the container.
      - `:transform` (BoxConstraints -> BoxConstraints): The transform to apply to the constraints. 
      - `:clip` (keyword, default: :none): The clip behavior of the child. Possible values: :none, :hard-edge, :anti-alias, :anti-alias-with-save-layer.
      - `:debug-transform-type` (string, default: \"\"): The type of transform to use for debugging.
    - child: The child widget to be displayed.

   [Flutter docs](https://api.flutter.dev/flutter/widgets/ConstraintsTransformBox-class.html)"
  [args child]
  (ctr/constraints-transformed* args child))

(defn container
  "A convenience widget that combines common painting, positioning, and sizing widgets.
   A container first surrounds the child with padding (inflated by any borders present in the decoration) and then applies additional constraints to the padded extent 
   (incorporating the width and height as constraints, if either is non-null).
   The container is then surrounded by additional empty space described from the margin.

   During painting, the container first applies the given transform, then paints the decoration to fill the padded extent,
   then it paints the child, and finally paints the `:foreground-decoration`, also filling the padded extent.

   Containers with no children try to be as big as possible unless the incoming constraints are unbounded, in which case they try to be as small as possible.
   Containers with children size themselves to their children. The width, height, and constraints arguments to the constructor override this.

   By default, containers return false for all hit tests. If the color property is specified, the hit testing is handled by `ColoredBox`,
   which always returns true. If the decoration or `:foreground-decoration` properties are specified, hit testing is handled by `Decoration.hitTest`.

   ## Layout behavior
   See BoxConstraints for an introduction to box layout models.

   Since Container combines a number of other widgets each with their own layout behavior, Container's layout behavior is somewhat complicated.

   Summary: Container tries, in order: to honor alignment, to size itself to the child, to honor the width, height, and constraints, to expand to fit the parent, to be as small as possible.

   More specifically:

   If the widget has no child, no height, no width, no constraints, and the parent provides unbounded constraints, then Container tries to size as small as possible.

   If the widget has no child and no alignment, but a height, width, or constraints are provided,
   then the Container tries to be as small as possible given the combination of those constraints and the parent's constraints.

   If the widget has no child, no height, no width, no constraints, and no alignment,
   but the parent provides bounded constraints, then Container expands to fit the constraints provided by the parent.

   If the widget has an alignment, and the parent provides unbounded constraints, then the Container tries to size itself around the child.

   If the widget has an alignment, and the parent provides bounded constraints, then the Container tries to expand to fit the parent, and then positions the child within itself as per the alignment.

   Otherwise, the widget has a child but no height, no width, no constraints, and no alignment, and the Container passes the constraints from the parent to the child and sizes itself to match the child.

   The margin and padding properties also affect the layout, as described in the documentation for those properties. (Their effects merely augment the rules described above.)
   The decoration can implicitly increase the padding (e.g. borders in a BoxDecoration contribute to the padding); see Decoration.padding."
  ([] (cnt/container* {} nil))
  ([child] (if (instance? m/Widget child) (cnt/container* {} child) (cnt/container* child nil)))
  ([args child] (cnt/container* args child)))

;; TODO: Wrap delegate
(defn custom-multi-child-layout [delegate & children]
  (w/CustomMultiChildLayout 
   .delegate delegate 
   .children (ut/flatten-children children)))

(defn expanded 
  "A widget that expands a child of a Row, Column, or Flex so that the child fills the available space.
   
   Using an Expanded widget makes a child of a Row, Column, or Flex expand to fill the available space along the main axis (e.g., horizontally for a Row or vertically for a Column).
   If multiple children are expanded, the available space is divided among them according to the flex factor.
   
   An Expanded widget must be a descendant of a Row, Column, or Flex, and the path from the Expanded widget to its enclosing Row, Column, or Flex must contain only StatelessWidgets or StatefulWidgets (not other kinds of widgets, like RenderObjectWidgets).
   
   ```clojure
   (row (expanded (text \"Hello, World!\")))
   (column (expanded 2 (text \"Hello, World!\")))
   ```

   [Flutter docs](https://api.flutter.dev/flutter/widgets/Expanded-class.html)"
  ([child] (ex/expanded* child))
  ([flex child] (ex/expanded* flex child)))

(defn flex
  "A widget that displays its children in a one-dimensional array.

   The Flex widget allows you to control the axis along which the children are placed (horizontal or vertical).
   This is referred to as the main axis. If you know the main axis in advance, then consider using a Row (if it's horizontal) or Column (if it's vertical) instead, because that will be less verbose.

   To cause a child to expand to fill the available space in the direction of this widget's main axis, wrap the child in an Expanded widget.

   The Flex widget does not scroll (and in general it is considered an error to have more children in a Flex than will fit in the available room). If you have some widgets and want them to be able to scroll if there is insufficient room, consider using a ListView.

   The Flex widget does not allow its children to wrap across multiple horizontal or vertical runs. For a widget that allows its children to wrap, consider using the Wrap widget instead of Flex.

   If you only have one child, then rather than using Flex, Row, or Column, consider using Align or Center to position the child.
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/Flex-class.html)"
  ([direction] (flex direction {}))
  ([direction args & children]
   (apply crf/flex* direction args children)))

(defn flexible 
  "A widget that controls how a child of a `row`, `column`, or `flex` flexes.
   
   Using a `flexible` widget gives a child of a `row`, `column`, or `flex` 
   the flexibility to expand to fill the available space in the main axis (e.g., horizontally for a `row` or vertically for a `column`), but, 
   unlike `expanded`, `flexible` does not require the child to fill the available space.
   
   A `flexible` widget must be a descendant of a `row`, `column`, or `flex`, and the path from the `flexible` widget to its enclosing `row`, `column` or `flex` must contain only `StatelessWidget`s or `StatefulWidget`s (not other kinds of widgets, like `RenderObjectWidget`s)."
  ([args child]
   (fx/flexible* args child))
  ([flex fit child]
   (flexible {:flex flex :fit fit} child))
  ([child]
   (flexible {} child)))

(defn layout-builder
  "Builds a widget tree that can depend on the parent widget's size.

   Similar to the `builder` except that the framework calls the builder function at layout time and provides the parent widget's constraints. This is useful when the parent constrains the child's size and doesn't depend on the child's intrinsic size. The LayoutBuilder's final size will match its child's size.

   The builder function is called in the following situations:

   The first time the widget is laid out.
    - When the parent widget passes different layout constraints.
    - When the parent widget updates this widget. 
    - When the dependencies that the builder function subscribes to change. 
   
   The builder function is not called during layout if the parent passes the same constraints repeatedly."
  [builder]
  (lbd/layout-builder* builder))

(defn row
  "A widget that displays its children in a horizontal array.

   To cause a child to expand to fill the available horizontal space, wrap the child in an Expanded widget.

   The Row widget does not scroll (and in general it is considered an error to have more children in a Row than will fit in the available room).
   If you have a line of widgets and want them to be able to scroll if there is insufficient room, consider using a ListView.

   For a vertical variant, see `column`.

   If you only have one child, then consider using Align or Center to position the child.

   By default, `:cross-axis-alignment` is `:center`, which centers the children in the vertical axis. If several of the children contain text, this is likely to make them visually misaligned if they have different font metrics (for example because they differ in TextStyle.fontSize or other TextStyle properties, or because they use different fonts due to being written in different scripts). Consider using `:cross-axis-alignment` `:baseline` instead.
   
   Args:
    - `:key` An identifier for the row.
    - `:spacing` (number, default: 0): The spacing between each child widget.
    - `:main-axis-alignment` (keyword or MainAxisAlignment, default: `:start`): The alignment of the children along the main axis.
      Possible values: `:center`, `:start`, `:end`, `:space-between`, `:space-around`.
    - `:main-axis-size` (keyword or MainAxisSize, default: :min): The size of the row in the main axis.
      Possible values: :max, :min.
    - `:cross-axis-alignment` (keyword or CrossAxisAlignment, default: `:center`): The alignment of the children along the cross axis.
      Possible values: `:center`, `:start`, `:end`, `:stretch`, `:baseline`.
    - `:text-direction` (keyword or TextDirection, default: `:ltr`): The direction of the text.
      Possible values: `:ltr`, `:rtl`.
    - `:text-baseline` (keyword or TextBaseline, default: `:alphabetic`): The baseline alignment for the text.
      Possible values: `:alphabetic`, `:ideographic`.
    - `:vertical-direction` (keyword or VerticalDirection, default: `:down`): The direction in which the children are placed vertically.
        Possible values: `:top`, `:down`.
   
   ```clojure
    (row {:main-axis-alignment :center :spacing 10} 
      (text \"Hello, World!\")
      (text \"This is a row!\"))
    ```
   
   [Flutter docs](https://api.flutter.dev/flutter/widgets/Row-class.html)"
  ([] (row {}))
  ([args & children]
   (apply crf/row* args children)))

(defn sized
  "Creates a `ConstrainedBox` widget with the specified constraints and child.\\
   The size can be specified as a number, a map, Size, BoxConstraints or two values.\\
   Examples:
   ```clojure
   (sized 100)
   (sized {:width 100 :height 200})
   (sized 100 200)
   (sized {:w 100 :h 200})
   (sized [100 200])
   (sized {:min-width 100 :max-width 200})
   (sized {:min-height 100 :max-height 200})
   (sized {:min-width 100 :max-width 200 :min-height 100 :max-height 200})
   (sized {:width {:min 100 :max 200}})
   ```
   If the size argument is a map, the keys `:width`, `:w`, `:height`, `:min-w`, `:max-height`, `:size`, etc are used to specify the width and height.\\
   If the size argument is a vector of two values, the first number is used for the width and the second number is used for the height.\\
   Width and height may be a numbers or a map of `:min` and `:max` values.
    
   Check `box-constraints` function for more information on how to create constraints.
  
   [Flutter docs](https://api.flutter.dev/flutter/widgets/ConstrainedBox-class.html)"
  ([] (sz/sized*))
  ([value] (sz/sized* value))
  ([value child]
   (sz/sized* value child))
  ([width height child]
   (sz/sized* width height child)))

(defn spacer
  "Spacer creates an adjustable, empty spacer that can be used to tune the spacing between widgets in a Flex container, like Row or Column.

   The Spacer widget will take up any available space, so setting the Flex.mainAxisAlignment on a flex container that contains a Spacer to MainAxisAlignment.spaceAround, MainAxisAlignment.spaceBetween, or MainAxisAlignment.spaceEvenly will not have any visible effect: the Spacer has taken up all of the additional space, therefore there is none left to redistribute."
  ([] (sp/spacer* 1))
  ([flex] (sp/spacer* flex)))

(defn stack
  "A widget that positions its children relative to the edges of its box.
   
   This class is useful if you want to overlap several children in a simple way, for example having some text and an image, overlaid with a gradient and a button attached to the bottom.
   
   [Flutter doc](https://api.flutter.dev/flutter/widgets/Stack-class.html)"
  [& children]
  (apply st/stack* children))

(defn opacity
  ([opacity args child]
   (op/opacity* opacity args child))
  ([opacity child]
   (op/opacity* opacity child)))

(defn decorated
  ([position with-decoration child]
   (m/DecoratedBox
    .decoration (t/decoration with-decoration)
    .position (t/decoration-position position)
    .child child))
  ([with-decoration child]
   (decorated 
    (:position with-decoration m/DecorationPosition.background)
    with-decoration
    child)))

(defn keyed [key child]
  (m/KeyedSubtree
   .key (t/widget-key key)
   .child child))

(defn padding
    "Creates a Padding widget with the specified padding and child.
     The padding can be specified as a number, a map of insets, or four numbers.
     Examples:
     ```clojure
     (padding 8 child) ;; Padding(padding: EdgeInsets.all(8))
     (padding {:all 8} child) ;; Padding(padding: EdgeInsets.all(8))
     (padding {:left 8 :right 16} child) ;; Padding(padding: EdgeInsets.only(left: 8, right: 16))
     (padding [8 16 24 32] child) ;; Padding(padding: EdgeInsets.fromLTRB(8, 16, 24, 32))
     (padding (insets 8) child) ;; Padding(padding: EdgeInsets.all(8))
     (padding 4 {:animation {:duration 0.1}} child) ;; AnimatedPadding(padding: EdgeInsets.all(4), duration: Duration(milliseconds: 100))
     ```
     If the padding argument is a map, the keys :all, :left, :right, :start, :end, :vertical, :horizontal, :top, and :bottom are used to specify the padding.
     If the padding argument is a vector of four numbers, the numbers are used for the left, top, right, and bottom padding."
  ([value args child]
   (pd/padding* value args child))
  ([value child]
   (pd/padding* value child)))

(defn text
  "Creates a text widget with the specified text and arguments.
   
   The string might break across multiple lines or might all be displayed on the same line depending on the layout constraints.

   The style argument is optional. When omitted, the text will use the style from the closest enclosing DefaultTextStyle.
   If the given style's TextStyle.inherit property is true (the default), the given style will be merged with the closest enclosing DefaultTextStyle.
   This merging behavior is useful, for example, to make the text bold while using the default font family and size.
   
   The text can be specified as a string or an InlineSpan object.

   The arguments can be specified as a map with the following keys:
    - `:key` (any, default: nil): An identifier for the text.
    - `:style` (map or TextStyle, default: nil): The style to apply to the text.
      Style map also can be passed directly instead of the arguments map.
      Check text-style function for more details.
    - `:strut-style` (StrutStyle, default: nil): The strut style to use for the text.
    - `:align` (keyword or TextAlign, default: nil): The alignment of the text.
      Possible values: :left, :right, :center, :justify, :start, :end.
    - `:text-direction` (keyword or TextDirection, default: nil): The direction of the text.
      Possible values: :ltr, :rtl.
    - `:locale` (Locale, default: nil): The locale to use for the text.
    - `:soft-wrap` (bool, default: true): Whether the text should wrap at the end of the line.
    - `:overflow` (TextOverflow, default: nil): How the text should behave when it overflows.
    - `:text-scaler` (TextScaler, default: nil): The text scaler to use for the text.
    - `:max-lines` (int, default: nil): The maximum number of lines to display.
    - `:semantics-label` (string, default: nil): The semantics label to use for the text.
    - `:text-width-basis` (TextWidthBasis, default: nil): The basis for the text width.
    - `:text-height-behavior` (TextHeightBehavior, default: nil): The behavior of the text height.
    - `:selection-color` (Color, default: nil): The color to use for the text selection.
   
   Examples:
   ```clojure
    (text \"Hello, World!\") ;; Text(\"Hello, World!\")
    (text \"Hello, World!\" {:color :red}) ;; Text(\"Hello, World!\", style: TextStyle(color: Colors.red))
    (text (text-span \"Hello, \" {:color :red} (text-span \"World!\" {:color :blue})))
  ```
   "
  ([string args]
   (txt/text* string args))
  ([string] (text string {})))

(defn with-text-style
  "The text style to apply to descendant `text` widgets which don't have an explicit style.

   The arguments can be specified as a map with the following keys:
    - `:key` (any, default: nil): An identifier for the text.
    - `:style` (map or `TextStyle`, default: nil): The style to apply to the text.
      Style map also can be passed directly instead of the arguments map with following keys:
      - `:inherit` (boolean, default: true): Whether the style is inherited from the parent. 
      - `:color` (Color, default: nil): The color of the text.
      - `:background-color` (Color, default: nil): The background color of the text.
      - `:font-size` (number, default: nil): The size of the font.
      - `:font-weight` (number or FontWeight, default: nil): The weight of the font.
      - `:font-style` (keyword or FontStyle, default: nil): The style of the font.
      - `:letter-spacing` (number, default: nil): The spacing between letters.
      - `:word-spacing` (number, default: nil): The spacing between words.
      - `:text-baseline` (keyword or TextBaseline, default: nil): The baseline alignment for the text.
      - `:height` or `:h` (number, default: nil): The height of the text.
      - `:leading-distribution` (keyword or TextLeadingDistribution, default: nil): The leading distribution of the text.
      - `:locale` (Locale, default: nil): The locale to use for the text.
      - `:foreground` (Paint, default: nil): The foreground paint of the text.
      - `:background` (Paint, default: nil): The background paint of the text.
      - `:shadows` (list of Shadow, default: nil): The shadows of the text.
      - `:font-features` (list of FontFeature, default: nil): The font features of the text.
      - `:font-variations` (list of FontVariation, default: nil): The font variations of the text.
      - `:decoration` (TextDecoration, default: nil): The decoration of the text.
      - `:decoration-color` (Color, default: nil): The color of the decoration.
      - `:decoration-style` (TextDecorationStyle, default: nil): The style of the decoration.
      - `:decoration-thickness` (number, default: nil): The thickness of the decoration.
      - `:debug-label` (string, default: nil): The debug label of the text.
      - `:font-family` (string, default: nil): The font family of the text.
      - `:font-family-fallback` (list of string, default: nil): The font family fallback of the text.
      - `:package` (string, default: nil): The package of the font family.
      - `:overflow` (TextOverflow, default: nil): How the text should behave when it overflows.
      Check text-style function for more details.
    - `:align` (keyword or `TextAlign`, default: nil): The alignment of the text.
      Possible values: `:left`, `:right`, `:center`, `:justify`, `:start`, `:end`.
    - `:soft-wrap` (bool, default: true): Whether the text should wrap at the end of the line.
    - `:overflow` (TextOverflow, default: nil): How the text should behave when it overflows.
    - `:max-lines` (int, default: nil): The maximum number of lines to display.
    - `:text-width-basis` (TextWidthBasis, default: nil): The basis for the text width.
    - `:text-height-behavior` (TextHeightBehavior, default: nil): The behavior of the text height.
    - `:animation` (map, default: nil): The animation options for the text style changes.
      - `:duration` (number, default: 0.25): The duration of the animation.
      - `:curve` (Curve, default: Curves.linear): The curve of the animation.
      - `:on-end` (fn, default: nil): The callback function to call when the animation ends.
      
   ```clojure
   (-> (column
         {:spacing 5}
         (text \"Hello, World!\")
         (text \"This is a column!\"))
      (with-text-style {:color :red, :font-size 20}))
   ```"
  [args child]
  (m/Builder
   .builder
   (fn [ctx]
     (let [def-style (m/DefaultTextStyle.of ctx)
           args (cond
                  (map? args) args
                  (ifn? args) (args def-style)
                  :else (throw (ex-info "Invalid arguments, expected a map or a fn" args)))
           key (t/widget-key (args :key))
           style (.merge (.-style def-style) (t/text-style (:style args args)))
           align (or (some-> args :align t/text-align) (.-textAlign def-style))
           soft-wrap (:soft-wrap args (if (nil? (.-softWrap def-style)) true (.-softWrap def-style)))
           overflow (:overflow args (.-overflow def-style))
           max-lines (:max-lines args (.-maxLines def-style))
           text-width-basis (:text-width-basis args (.-textWidthBasis def-style))
           text-height-behavior (:text-height-behavior args (.-textHeightBehavior def-style))
           animation (some-> args :animation t/animation-options)]
       (if (nil? animation)
         (m/DefaultTextStyle
          .key key
          .style style
          .textAlign align
          .softWrap soft-wrap
          .overflow overflow
          .maxLines max-lines
          .textWidthBasis text-width-basis
          .textHeightBehavior text-height-behavior
          .child child)
         (m/AnimatedDefaultTextStyle
          .key key
          .child child
          .style style
          .textAlign align
          .softWrap soft-wrap
          .overflow overflow
          .maxLines max-lines
          .textWidthBasis text-width-basis
          .textHeightBehavior text-height-behavior
          .duration (animation :duration)
          .curve (animation :curve)
          .onEnd (animation :on-end)))))))

;; MARK: Animated

;; (defn animated
;;   ([child-fn] (animated {} child-fn))
;;   ([animation? child-fn]
;;    (if (fn? animation?)
;;      (animated {} animation? child-fn)
;;      (animated animation? child-fn :none)))
;;   ([animation? child-fn child]
;;    (f/widget
;;     :vsync vsync
;;     :managed [anim-contr (m/AnimationController 
;;                           .vsync vsync 
;;                           .value 0.0 
;;                           .duration (:duration (animation-options animation?)))]
;;     :let [animation (if (instance? m/Listenable animation?) 
;;                       animation?
;;                       (let [options (animation-options animation?)]
;;                         (set! (.duration anim-contr) (options :duration))
;;                         anim-contr))]
;;     (m/AnimatedBuilder
;;      .animation animation
;;      .child (if (instance? m/Widget child) child nil)
;;      .builder (fn [ctx child]
;;                 (binding [*anim-ctx* (assoc *anim-ctx* :is-animated? true)]
;;                   (if (= child :none)
;;                     (child-fn (.-value animation) ctx)
;;                     (child-fn child (.-value animation) ctx))))))))

;; (defn tt []
;;   (animated
;;    {:duration 0.25 :curve :linear}
;;    (fn [t, ctx]
;;      (->>
;;       (text "Text" {:color (color :white)})
;;       (padding (insets 10))
;;       (colored :red))))
  
;;   (->>
;;    (text "Text" {:color :red})
;;    (animated
;;     ;; [insets (insets 10)]
;;     {:duration 0.25 :curve :linear}
;;     #(padding 4 %)))
  
;;   (->>
;;    (text "Text" {:color :red})
;;    (padding 10 {:animation {:duration 0.25 :curve :linear}}))
;;   )
