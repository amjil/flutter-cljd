(ns flutter-cljd.animations-test
  (:require [clojure.test :refer [deftest is testing]]
            [flutter-cljd.curves :as c]
            [flutter-cljd.animations :as a]))

(defn- unwrap
  ([animation] (unwrap nil animation nil))
  ([animation dur] (if (fn? animation) (unwrap nil animation dur) (unwrap animation dur nil)))
  ([value animation dur]
   (let [anim (:anim (animation value dur))]
     (fn [t] (:value (anim (double t) {:last-t 0}))))))

(def ^:private percents
  (fn [_ dur] {:dur dur
               :anim (fn [t cache]
                       {:value (int (* 100 t))
                        :cache cache})}))

(deftest test-to
  (testing "Single value"
    (let [anim (unwrap (a/to 100))]
      (is (= (anim 0) 100))
      (is (= (anim 0.5) 100))
      (is (= (anim 1) 100))))

  (testing "Valid between two values"
    (let [anim (unwrap (a/to 0 100))]
      (is (= (anim 0) 0))
      (is (= (anim 0.25) 25))
      (is (= (anim 0.5) 50))
      (is (= (anim 0.75) 75))
      (is (= (anim 1) 100))))

  (testing "Valid between many values"
    (let [anim (unwrap (a/to 0 100 200 300 400 500))]
      (is (= (anim 0) 0))
      (is (= (anim 0.2) 100))
      (is (= (anim 0.4) 200))
      (is (= (anim 0.6) 300))
      (is (= (anim 0.8) 400))
      (is (= (anim 1) 500))))

  (testing "With initial value"
    (let [anim (unwrap 100 (a/to 200))]
      (is (= (anim 0) 100))
      (is (= (anim 0.5) 150))
      (is (= (anim 1) 200)))))

(deftest test-with
  (testing "Duration option"
    (let [anim ((a/with {:dur 100} percents) nil nil)]
      (is (= (.-inMilliseconds (:dur anim)) 100))))

  (testing "Start time option"
    (let [anim (unwrap (a/with {:at 500 :dur 1000} percents))]
      (is (= (anim 0) 0))
      (is (= (anim 0.25) 0))  ; Before start
      (is (= (anim 0.5) 25))  ; After start
      (is (= (anim 0.75) 62)) ; Mid-animation
      (is (= (anim 1) 100)))) ; End

  (testing "Duration ratio option"
    (let [anim (unwrap (a/with {:dur-ratio 0.5} percents))]
      (is (= (anim 0) 0))
      (is (= (anim 0.25) 50))
      (is (= (anim 0.5) 100))
      (is (= (anim 0.75) 100))
      (is (= (anim 1) 100))))

  (testing "Start time ratio option"
    (let [anim (unwrap (a/with {:at-ratio 0.5 :dur-ratio 0.5} percents))]
      (is (= (anim 0) 0))
      (is (= (anim 0.5) 0))
      (is (= (anim 0.75) 50))
      (is (= (anim 1) 100))))

  (testing "Curve option"
    (let [anim (unwrap (a/with {:curve (constantly 0)} percents))]
      (is (= (anim 0) 0))
      (is (= (anim 0.5) 0))
      (is (= (anim 1) 0))))

  (testing "Curve :ease-in option"
    (let [anim (unwrap (a/with {:curve :ease-in} percents))]
      (is (= (anim 0) 0))
      (is (< (anim 0.5) 50))
      (is (= (anim 1) 100))))

  (testing "Combined options"
    (let [anim (unwrap (a/with {:dur 1000
                                :at 500
                                :curve :ease-in-out}
                               percents))]
      (is (= (anim 0) 0))
      (is (= (anim 0.25) 0))
      (is (not= (anim 0.75) 50)) ; Should not be linear due to ease-in-out
      (is (= (anim 1) 100)))))

(deftest test-repeat
  (testing "Basic repeat functionality"
    (let [base-dur 1000
          repeated (a/repeat 2 (a/with {:dur base-dur} (a/to 0 100)))
          {:keys [dur]} (repeated nil nil)]
      (is (= (.-inMilliseconds dur) (* base-dur 2)) "Duration should be doubled")

      (let [anim (unwrap repeated)]
        (is (= (anim 0) 0))
        (is (= (anim 0.25) 50))  ; First iteration at 50%
        (is (= (anim 0.5) 0))    ; Start of second iteration
        (is (= (anim 0.75) 50))  ; Second iteration at 50%
        (is (= (anim 1) 100)))))  ; End

  (testing "Zero or negative count"
    (let [anim (unwrap 0 (a/repeat 0 percents))]
      (is (= (anim 0) 0))
      (is (= (anim 0.5) 0))
      (is (= (anim 1) 0)))

    (let [anim (unwrap 0 (a/repeat -1 percents))]
      (is (= (anim 0) 0))
      (is (= (anim 0.5) 0))
      (is (= (anim 1) 0)))))

(deftest test-autoreverse
  (testing "Basic autoreverse functionality"
    (let [base-dur 1000
          reversed (a/autoreverse (a/with {:dur base-dur} percents))
          {:keys [dur]} (reversed nil nil)]
      (is (= (.-inMilliseconds dur) (* base-dur 2)) "Duration should be doubled")

      (let [anim (unwrap reversed)]
        (is (= (anim 0) 0))      ; Start
        (is (= (anim 0.25) 50))  ; Forward halfway
        (is (= (anim 0.5) 100))  ; Forward complete
        (is (= (anim 0.75) 50))  ; Reverse halfway
        (is (= (anim 1) 0))))))    ; Back to start

(deftest test-par
  (testing "Basic parallel animation"
    (let [anim (unwrap (a/par 
                        :color (a/to 0 100)
                        :offset (a/to 200 300)))]
      (is (= (anim 0) {:color 0 :offset 200}))
      (is (= (anim 0.5) {:color 50 :offset 250}))
      (is (= (anim 1) {:color 100 :offset 300}))))
  
  (testing "With different durations"
    (let [anim (unwrap (a/par
                        :fast (a/with {:dur-ratio 0.5} (a/to 0 100))
                        :slow (a/to 0 100)))]
      (is (= (anim 0) {:fast 0 :slow 0}))
      (is (= (anim 0.5) {:fast 100 :slow 50}))
      (is (= (anim 1) {:fast 100 :slow 100}))))
  
  (testing "Nested parallel animations"
    (let [anim (unwrap (a/par
                        :outer (a/to 0 100)
                        :inner (a/par
                               :x (a/to 0 10)
                               :y (a/to 0 20))))]
      (is (= (anim 0) {:outer 0 :inner {:x 0 :y 0}}))
      (is (= (anim 0.5) {:outer 50 :inner {:x 5 :y 10}}))
      (is (= (anim 1) {:outer 100 :inner {:x 10 :y 20}}))))
  
  (testing "With options"
    (let [anim (unwrap (a/with {:dur 1000} 
                        (a/par
                         :a (a/to 0 100)
                         :b (a/with {:dur-ratio 0.5} (a/to 0 50)))))]
      (is (= (anim 0) {:a 0 :b 0}))
      (is (= (anim 0.5) {:a 50 :b 50}))
      (is (= (anim 1) {:a 100 :b 50}))))
  
  (testing "Duration computation"
    (let [anim1 (a/par
                 :a (a/with {:dur 1000} (a/to 0 100))
                 :b (a/with {:dur 2000} (a/to 0 100)))
          {:keys [dur]} (anim1 nil nil)]
      (is (= (.-inMilliseconds dur) 2000) "Should use longest child duration"))
    
    (let [anim2 (a/par
                 :a (a/with {:dur-ratio 0.5} (a/to 0 100))
                 :b (a/with {:dur-ratio 0.7} (a/to 0 100)))
          {:keys [dur]} (anim2 nil nil)]
      (is (nil? dur) "Should not compute duration from ratios alone"))
    
    (let [anim3 (a/with {:dur 1000}
                 (a/par
                  :a (a/with {:dur 500} (a/to 0 100))
                  :b (a/with {:dur 2000} (a/to 0 100))))
          {:keys [dur]} (anim3 nil nil)]
      (is (= (.-inMilliseconds dur) 2000) "Should use max of parent and children durations")))))

(deftest test-curves
  (testing "Constant curve"
    (let [curve (c/constant 0.5)]
      (is (= (.transform curve 0.0) 0.5))
      (is (= (.transform curve 0.5) 0.5))
      (is (= (.transform curve 1.0) 0.5))))

  (testing "Reversed curve"
    (let [curve (c/reversed :ease-in)]
      (is (= (.transform curve 0.0) 1.0))
      (is (< (.transform curve 0.5) 0.5))
      (is (= (.transform curve 1.0) 0.0))))

  (testing "Inversed curve"
    (let [curve (c/inversed :ease-in)]
      (is (= (.transform curve 0.0) 1.0))
      (is (> (.transform curve 0.5) 0.5))
      (is (= (.transform curve 1.0) 0.0))))

  (testing "Autoreversed curve"
    (let [curve (c/autoreversed :ease-in)]
      (is (= (.transform curve 0.0) 0.0))
      (is (< (.transform curve 0.25) 0.5) "First half ease-in")
      (is (= (.transform curve 0.5) 1.0))
      (is (< (.transform curve 0.75) 0.5) "Second half ease-in reversed")
      (is (= (.transform curve 1.0) 0.0))))

  (testing "Repeated curve"
    (let [curve (c/repeat 2 :ease-in)]
      (is (= (.transform curve 0.0) 0.0))
      (is (< (.transform curve 0.25) 0.5) "First iteration ease-in")
      (is (= (.transform curve 0.5) 0.0))
      (is (< (.transform curve 0.75) 0.5) "Second iteration ease-in")
      (is (= (.transform curve 1.0) 1.0))))

  (testing "Concatenated curves"
    (let [curve (c/concat :ease-in :ease-out)]
      (is (= (.transform curve 0.0) 0.0))
      (is (< (.transform curve 0.25) 0.5) "First half ease-in")
      (is (> (.transform curve 0.75) 0.5) "Second half ease-out")
      (is (= (.transform curve 1.0) 1.0))))

  (testing "Average of curves"
    (let [curve (c/average :ease-in :ease-out)]
      (is (= (.transform curve 0.0) 0.0))
      (is (= (.transform curve 0.5) 0.5) "Should be linear at midpoint")
      (is (= (.transform curve 1.0) 1.0))))

  (testing "Multiply curves"
    (let [curve (c/multiply :ease-in :ease-out)]
      (is (= (.transform curve 0.0) 0.0))
      (is (< (.transform curve 0.5) 0.25) "Product should be less than either curve")
      (is (= (.transform curve 1.0) 1.0))))

  (testing "Segment"
    (let [curve (c/segment 0.25 0.75 :ease-in)]
      (is (= (.transform curve 0.0) 0.0))
      (is (= (.transform curve 0.25) 0.0))
      (is (< (.transform curve 0.5) 0.5))
      (is (= (.transform curve 0.75) 1.0))
      (is (= (.transform curve 1.0) 0.0)))))
